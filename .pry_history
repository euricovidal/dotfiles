name
msg
flahs
flash
exit
next
params
whereami
next
nex
exit
next
@retrospective.errors
@retrospective.valid?
@retrospective.errors
exit
FactoryGirl.create(:book)
FactoryGirl.create(:book_with_mandatory_fields)
require 'spec/spec_helper'
require './spec/spec_helper'
FactoryGirl.create(:book_with_mandatory_fields)
exit
next
mext
next
CatalogueClient::Book.all_on_store(1, 1, CommerceClient::Currency.with_rates, fetch: true, key: CGI::unescape(params[:key]))
CatalogueClient::Book.all_on_store(1, 1, CommerceClient::Currency.with_rates, key: CGI::unescape(params[:key]))
x=CatalogueClient::Book.all_on_store(1, 1, CommerceClient::Currency.with_rates, key: CGI::unescape(params[:key]))
x.get(0)
mextx=x.get(0)
y=CatalogueClient::Book.all_on_store(1, 1, CommerceClient::Currency.with_rates, fetch: true, key: CGI::unescape(params[:key]))
x==y
x-y
x
y
exit
xit
exit
next
continue
@book
books.results
@book
whereami
books
whereami
books.get(0)
BookPresenter.new(@book)
exit
books.results
books.get(0)
CatalogueClient::Book.new(books.get(0))
books.get(0).tags
books.first
whereami
CatalogueClient::Book.all_on_store(1, 1, CommerceClient::Currency.with_rates, fetch: true, key: CGI::unescape(params[:key]))
exit
CatalogueClient::Book.all_on_store(1, 1, CommerceClient::Currency.with_rates, fetch: true, key: CGI::unescape(params[:key]))
exit
books
books.first
exit
nexxt
next
books.results
books.get(0)
books.first
books.results
x=books.get(0)
y=books.first
x==y
z=books.results.first
x
y
z
z==y
exit
continue
exit
index
@client_class
continue
exit
index
@client_class
exit
@client_class
exit
@client_class
exit
@client_class
exit
@client_class
exit
books.results.first
books.results.first.tags
BookPresenter.new(books.results.first)
exit
books.results.class
books.results.first.class
books.results.to_a
books.results.to_a.first
books.results.get(0)
books.results.to_a.first.class
exit
books.results
books.results.class
books.results.first.class
exit
books
whereami
@book = books.results.first
@books.class
@book.class
@book.href
@book['href']
books.results.first.class
books.results.first.href
books.results.first['href']
exit
criteria
response.body
exit
response.body
criteria
exit
response.body
criteria
exit
next
books.count
next
books.count
books.results
whereami
wtf?
next
exception
exit
next
exception
exit
next
step
books.class
exit
books.first
continue
next
continue
next
exception
books.first
exit
assings
assing
assign
assigns
assigns[:newspaper_edition]
assigns[:newspaper_edition] == newspaper_edition
exit
next
profiles_users
CSV.open('asi_users.csv')
CSV.open('asi_users.csv').count
CSV.open('asi_users.csv').first
CSV.open('asi_users.csv').map{|u| {subscriber_code: u[0], email: u[1], name: [2], document: u[3]} }
x=_
(0..10).to_a
(0..10).to_a.pop
(0..10).to_a.shift
(0..10).to_a.slice
(0..10).to_a.slice 0
y=(0..10).to_a
y.slice! 0
y
y.first.slice
x
x.slice! 0
u=profiles_users.find(email: x.first[:email])
u.count
exit
next
asi_user.first
asi_users.first
profiles_users.find({email: asi_users.first[:email]}).count
Mongoid.load!('mongo.yml', :production)
profiles_users = Mongoid.session(:default)[:profiles_users]
profiles_users.find({email: asi_users.first[:email]}).count
profiles_users.find({}).count
profiles_users.find({email_normalized: asi_users.first[:email]}).count
profiles_users.find({email_normalized: asi_users.first[:email]}).present?
profiles_users.find({email_normalized: asi_users.first[:email]}).blank?
profiles_users.find({email_normalized: asi_users.first[:email]}).name
profiles_users.find({email_normalized: asi_users.first[:email]}).first
profiles_users.find({email_normalized: asi_users.first[:email]}).first.name
profiles_users.find({email_normalized: asi_users.first[:email]}).first['name']
profiles_users.find({email_normalized: asi_users.first[:email]}).first[:name]
exit
qq
profiles_users.find({}).first
exit
user
exit
@1
$1
$0
ARGV
exit
asi_users
exit
profiles_users.find(email_normalized: assine[:email]).first
next
user.present?
next
"#{user['name']},#{user['email_normalized']},#{user['cpf']},#{user['source']}\n"
print_users_not_found
next
profiles_users.find(email_normalized: assine[:email]).first
next
profiles_users.find(email_normalized: assine[:email]).first
next
exit
profiles_users.find(email_normalized: assine[:email]).first
exit
ARGV
ARGV.include? /scenario/
ARGV.include? /scenario=/
ARGV.select {|arg| arg.match /scenario=/ }
ARGV.select {|arg| arg.match /scenario=/ }.first
ARGV.select {|arg| arg.match /scenario=/ }.first.split('='
)
ARGV.select {|arg| arg.match /scenario=/ }.first.split('=').last
"0".to_i
exit
next
nil.to_i
nil.to_i!
x=nil
x.to_i!
exit
by_scenario
exit
subscriptions_subscribers.find(user_href: {:$ne => nil})
subscriptions_subscribers.find(user_href: {:$ne => nil}).count
subscriptions_subscribers.find({}).count
exit
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10)
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).to_a
users.count
user.map(&:name)
user.map(&:email)
users.map(&:name)
users.first
users.map(&'name')
users.map{|u| u['name'] }
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).order('name').to_a
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).order_by('name').to_a
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).sert_by('name').to_a
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).sort_by('name').to_a
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).sort('name').to_a
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).sort(:name).to_a
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).sort(:name).count
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).sort(:name).count
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).sort(:name).to_a
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).sort(:name).limit(10).count
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).sort(:name).limit(10)
users.count
users[0..10]
users.first
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).order_by(:name.asc)
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).order_by(:name.asc)
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).asc(:name)
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10)
users = profiles_users.find(source: what_is_the_scenario(by_scenario)).limit(10).to_a
users.map{|u| u['name']
}
users.sort{|u| u['name'] }
users.sort_by{|u| u['name'] }
users.sort_by{|u| u['name'] }.map{|u| u['name'] }
exit
user
subscriber
exit
initial_item = DlsClient::InitialItem.new(product_id: params[:product_id])
initial_item = DlsClient::InitialItem.new(product_id: '123456')
initial_item.save
initial_item.errors
initial_item.errors.messages
initial_item.links
exit
initial_item = DlsClient::InitialItem.new(product_id: '7754')
initial_item.save
initial_item.errors
initial_item.save
initial_item.errors
initial_item
initial_item.links
initial_item
initial_items
initial_item = DlsClient::InitialItem.new(product_id: '4062')
initial_item.save
exit
books = DlsClient::InitialItems.get(publication_type: 'livro')
books = DlsClient::InitialItem.get(publication_type: 'livro')
books = DlsClient::InitialItem.get('publication_type' => 'livro')
books = DlsClient::InitialItem.get()
books = DlsClient::InitialItem.get('')
books = DlsClient::InitialItem.get('publication_type' => 'livro')
books = DlsClient::InitialItem.get(publication_type: 'livro')
books = DlsClient::InitialItem.search(publication_type: 'livro')
books = DlsClient::InitialItem.search(publication_type: 'Livro')
books = DlsClient::InitialItem.search(publication_type: 'livro')
exit
books = DlsClient::InitialItems.search(publication_type: 'livro')
books = DlsClient::InitialItem.search(publication_type: 'livro')
books.results
exit
DlsClient::InitialItem.search(publication_type: 'livro').results
DlsClient::InitialItem.search(publication_type: 'livro')
DlsClient::InitialItem.search('publication_type' => 'livro')
DlsClient::InitialItem.search('publication_type' => 'livro').results
exit
page.body
visit initial_items_book_index_path
page.body
exit
x=DlsClient::InitialItem.new(product_id: '4062')
x.save
x=DlsClient::InitialItem.new(product_id: '1022876')
x.save
exit
continue
puts page.body
DlsClient
DlsClient.InitialItems
DlsClient.InitialItem
DlsClient::InitialItem
DlsClient::InitialItem.all
DlsClient::InitialItem.search({})
DlsClient::InitialItem.search({pulication_type : "livro"})
DlsClient::InitialItem.search({pulication_type: "livro"})
DlsClient::InitialItem.search({pulication_type: "Livro"})
DlsClient::InitialItem.search({publication_type: "Livro"})
DlsClient::InitialItem.search({publication_type: "livro"})
DlsClient::InitialItem.search({publication_type: "livro"})e
exit
puts page.body
exit
page.get_alert
page.driver.browser.switch_to.alert
exit
self.parent
self.parent_id
exit
Dir.glob("public/assets/#{params[:controller]}*")
Dir.glob("public/assets/javascript/#{params[:controller]}*")
params
Dir.glob("public/assets/javascript/#{params[:controller]}.js")
Dir.glob("app/assets/javascript/#{params[:controller]}.js")
Dir.glob("#{Rails.root}/app/assets/javascript/#{params[:controller]}.js")
"#{Rails.root}/app/assets/javascript/#{params[:controller]}.js"
File.exists? "#{Rails.root}/app/assets/javascript/#{params[:controller]}.js"
File.exists? "#{Rails.root}/app/assets/javascript/#{params[:controller]}.js.coffee"
File.exists? "#{Rails.root}/app/assets/javascripts/#{params[:controller]}.js.coffee"
Dir.glob("public/assets/javascripts/#{params[:controller]}*")
Dir.glob("app/assets/javascripts/#{params[:controller]}*")
exit
params[:value].gsub!(/[^0-9,]/, '')
params[:value]
params[:value].gsub(/[^0-9,]/, '')
params[:value].gsub(/[^0-9,]/, '')exit
exit
FactoryGirl.create(:free_book, title: 'Beleza Sustentvel', external_id: DLS_PRODUCT_ID)
whereami
next
step
next
@exception
next
@failed
success
next
FactoryGirl.create(:free_book, title: 'Beleza Sustentvel', external_id: DLS_PRODUCT_ID)
FactoryGirl.create(:free_book, title: 'Beleza Sustentvel1', external_id: DLS_PRODUCT_ID)
FactoryGirl.create(:free_book, title: 'Beleza Sustentvel', external_id: DLS_PRODUCT_ID+1)
exit
next
e
exit
special_combo_sold_separately.present?
@special_combo = FactoryGirl.create(:special_combo, special_combo_attributes, sold_separately: special_combo_sold_separately.present?)
exit
next
exit
JSON.parse(last_response.body)['search_results'].first['resource']
exit
JSON.parse(last_response.body)['search_results'].first['resource']['newspaper']['sold_separately'].should eql @special_combo.sold_separately
exit
next
special_combos
special_combos.to_a
next
boom
exit
next
boom
exit
next
@newspapers.map(&:keys)
@newspapers.map(&:key)
exit
nexty
next
items
items.to_a
items.first
items.first.newspaper
exit
JSON.parse(last_response.body)['search_results'].first['resource']
exiot
exit
@newspapers
next
exception
next
e
next
exit
params[:newspaper_form]
exit
next
parameters
next
exception
exit
next
@newspaper.save
@newspaper.errors
exit
next
exit
@newspaper_form
@newspaper_form.errors
@newspaper_form.errors.messages
f.error_notification
exit
next
eit
exit
@newspaper_form.save
@newspaper_form.errors
exit
@newspaper_form.save
@newspaper_form.errors
exit
mexit
exit
@newspaper
@newspaper.links
@newspaper.links.self
exit
next
params[:id]
next
@newspaper_form
next
@newspaper_form
@newspaper_form.valid?
exit
@newspaper_form
next
$("#catalogue_client_publisher_cnpj")
@newspaper_form.update_attributes(normalize_params)
@newspaper_form.errors
exit
@newspaper_form = CatalogueClient::Newspaper.get(params[:id])
@newspaper_form = CatalogueClient::Newspaper.get(params[:id]+"a")
@newspaper_form = CatalogueClient::Newspaper.get(params[:id])
whereami
normalize_params
@newspaper_form.update_attributes(normalize_params)
exit
@newspaper_form.update_attributes(normalize_params)
exit
@newspaper_form.update_attributes(normalize_params)
normalize_params
@newspaper_form.update_attributes(normalize_params)
@newspaper_form
@newspaper_form.errors
exit
normalize_params
exit
normalize_params
xit
exit
normalize_params
exit
@newspaper
exit
@newspaper
exit
@newspaper
exiut
exit
@newspaper
exit
JSON.parse(last_response.body)['search_results'].first['resource']['newspaper']
exit
@newspaper
exit
newspaper.id
exit
rray(newspaper.regions)
Array(newspaper.regions)
Array(newspaper.regions).flatten
Array(newspaper.regions).compact
puts "a" if newspaper.regions.first
puts "a" if newspaper.regions.first.present?
exit
Array(@newspaper.regions)
Array(@newspaper.regions).map {|region| I18n.t("states.#{region}") }.join(', ')
exit
@newspaper.regions
@newspaper_presenter.regions
@newspaper_presenter.region
@newspaper_presenter
@newspaper_presenter = NewspaperPresenter
@newspaper_presenter = NewspaperPresenter.new @newspaper
@newspaper_presenter.regions
exit
params
exit
params
exit
params
exit
x = {:a => 1, :b => 2}
x.delete(:a)
x.reject(:a)
x.delete!(:a)
x
x = {:a => 1, :b => 2}
x.delete(:a)
x
whereami
parameters
exit
page.find('#catalogue_client_newspaper_language')
page.find('#catalogue_client_newspaper_language').value
next
find('#catalogue_client_newspaper_supported_platforms_ios')
find('#catalogue_client_newspaper_supported_platforms_ios').checked
find('#catalogue_client_newspaper_supported_platforms_ios').check
find('#catalogue_client_newspaper_supported_platforms_ios'
)
next
e
exit
eexit
exit
find('#catalogue_client_newspaper_supported_platforms_ios')
next
e
exit
page.find('#catalogue_client_newspaper_language')
puts page.body
exit
@newspaper
@newspaper.support_platform
@newspaper.support_platforms
@newspaper.supported_platforms
@newspaper.supported_platforms.ios
@newspaper.supported_platforms.new
@newspaper.supported_platforms
exit
@newspaper
exit
next
exit
next
puts page.body
exit
puts page.body
exit
page.all(".token-input-list-facebook li p").map(& :text)
exit
next
{post: '/retrospectives/1/bads'}.should route_to(controller: 'Retrospectives::Bads', action: 'create', id: 1)
exit
whereami
@retro_items
@retro_items.sort
exit
@retro_items
search_words
exit
search_words
@retro_items
@retro_items.sort
@retro_items.sort(&:value)
@retro_items.sort(&:values)
@retro_items.sort_by{|x| x.value }
@retro_items.sort_by{|x| puts x }
@retro_items.sort_by{|x, y| puts x }
@retro_items.sort_by{|x, y| puts y }
@retro_items.sort_by{|x, y| y }
@retro_items.sort_by{|x, y| y }.reverse
exit
wheremai
whereami
results_array
exit
whereami
search_words
exit
search_words
exit
search_words
res
results_array
exit
results_array
exit
@retro_items
exit
parse_json
exit
next
exit
order_href
exit
raise
exit
Resque.all
Resque::Failure.all
xit
exit
order_href
raise
exit
Resque::Failure.all
Resque::Failure
Resque::Success
Resque::Worker.all
Resque::Failure.all(0,10
)
Resque::Failure.all(10)
Resque::Failure.all(0,10)
exit
Resque::Worker.all
Resque::Worker
Resque
exit
Invoice::Cat156Job.perform(@order_href)
exit
Invoice::Cat156Job.perform(@order_href)
expect(Invoice::Cat156Job.perform(@order_href)).to raise_error(Exception)
exit
OrdersClient
OrdersClient::Order.get('/order/520a98e34cc4257009000001')
exit
OrdersClient::Order.get('/order/520a98e34cc4257009000001')
OrdersClient::Order.get('/order/520a98e34cc42570090000011')
whereami
exit
next
order.links.self
exit
@cat156
@order
exit
@order
whereami
@order.items
@order.order_number
@order.created_at
@order.order_date
@order
@order.created_at
@order.created_at.month
@order.created_at.class
Date.new(@order.created_at)
Date.from_string(@order.created_at)
@order.created_at.to_date
@order.created_at.to_date.month
@order.created_at.to_date.trimester_code
@order.created_at.to_date
@order.created_at.to_date.year
rand
@order.user
@order.user.href
user=ProfilesClient::User.get @order.user.href
user.document
user.cpf
@order.items
@order
user
user.address
FactoryGirl
FactoryGirl.create(:order_with_payment)
exit
@order
exit
FactoryGirl.create(:boleto_payment)
FactoryGirl.build(:boleto_payment)
FactoryGirl.build(:boleto_payment)FactoryGirl.create(:assine_order, payment: FactoryGirl.create(:boleto_payment))
end
FactoryGirl.create(:assine_order, payment: FactoryGirl.build(:boleto_payment))
exit
@bank_account.valid?
@bank_account.save
next
exit
page.html
puts page.html
find('boleto')
exit
content.click_button 'Concluir compra com boleto'
page.html
puts page.html
current_path
exit
next
exit
whereami
f
exit
error_messages_for
f.error_messages_for
@associate.error_messages_for
f.error_messages_for
f.error_messages
error_messages_for :associate
error_messages_for @associate
@associate.errors.full_messages
exit
card_one
card_one.errors
card_one.errors.messages
:card_one
exit
card_one.valid?
card_one.errros
card_one.errors
card_one.errors.full_messages
exit
params[:card_one]
next
exit
@card_one.valid?
@card_one.errors
@card_one.errors.full_messages
exit
params[:cards]
params[:cards] == 2
params[:cards] == "2"
params[:cards].to_i == 2
exit
subscription
params[:type]
subscription.user
subscription.user.credit_cards
whereami
params[:credit_cards]
next
e
next
exit
next
exception
exit
credit_card
params[:credit_cards]
params[:credit_cards].first
params[:credit_cards].each{|k,v| v}
params[:credit_cards]
params[:credit_cards].first
params[:credit_cards].first.last
exit
next
credit_card.last
next
subscription
subscription.user
subscription.user.credit_cards
subscription.user.credit_cards.first.number
subscription.user.credit_cards.last.number
subscription.valid?
subscription.errors
whereami
credit_cards
exit
model
model.errors
model.errors.any?
model.errors.full_messages
exit
model
exit
@associate.valid?
@associate.errors
@associate.credit_cards.erros
@associate.credit_cards.first.errors
exit
subscription.valid?
exit
next
subscription.errors
exit
next
subscription.errors
subscription.user.credit_cards.first.errors
exit
next
subscription.errors
params[:type]
params
exit
subscription.user.credit_cards
subscription.save
@associate.subscription
exit
subscription.user
subscription.user.credit_cards
subscription.valid?
subscription.save
subscription.user.mobile
subscription.user.mobile.length
subscription.user.mobile
exit
subscription.user.mobile
subscription.save
exit
subscription.save
Subscription
Subscription.first
subscription.type
subscription
subscription.user
User
User.first
User.first.subscription
User.first.subscriptions
User.first.credit_cards
exit
Subscription
Subscription.all
exit
Subscription.all
subscription.save
Subscription.all
Subscription.first
Subscription.first.user
Subscription.first
exit
subscription.save
Subscription.first
Subscription.first.user
Subscription.delete_all
User.delete_all
CreditCard.delete_all
exit
subscription.save
Subscription.first
Subscription.first.user
Subscription.first.user.credit_cards
User
User.first
User.first.subscription
User.first.subscriptions
exit
User.first.subscription
exit
subscription.save
Subscription.first.user
User.first
User.first.subscription
User.first.subscriptions
exit
Subscription.actives
Subscription.all
User.first
User.first.subscriptions
User.first.subscriptions.actives
exit
model.errors
model.errors.messages
model.errors.messages.last
model.errors.messages
model.errors.messages.class
model.errors.messages.to_a
model.errors.messages.to_hash
model.errors.messages.to_hash.last
model.errors.messages
model.errors.messages['mobile']
model.errors.messages[:mobile]
model.errors.messages.each{|x| x}
model.errors.messages.each{|x| x.to_s}
model.errors.each{|x| x}
model.errors.first
model.errors.last
model.errors.seond
model.errors.second
model.errors.first(2)
model.errors
model.errors.base
model.errors.only
model.errors.user
whereami
next
model.errors.full_messages
exit
next
model.errors
model.errors.full_messages
exit
model.errors.full_messages
model.errors.full_message
model.errors.full_messages
exit
params
params[:cards]
exit
content
content.click_button
content.click_button 'Concluir'
content.click_button 'Concluir compra com boleto'
content.find 'Concluir compra com boleto'
irb
exit
subscription.errors
exit
content.click
content.click ''
content.click_link
content.click_link ''Concluir compra com boleto'
content.click_link 'Concluir compra com boleto'
content.click_button 'Concluir compra com boleto'
exit
content.click_button 'Concluir compra com boleto'
exit
page.find('Nome')
page.find('.name')
page.find('#user_name')
exit
page.find('.field_name')
page.find('.field_name label')
page.find('.field_name .error')
page.find('.field_name label.error')
page.find('.field_name label.error').text
exit
expect(page.find('.field_name label.error')).to have_content 'não pode ficar vazio'
exit
page.body
page.html
exit
page
page.body
exit
page.find('.xxx')
exit
page.find('.agree_boleto')
page.find('.agree_boleto').is_checked
page.find('.agree_boleto').is_check
page.find('.agree_boleto').checked
page.find('.agree_boleto').checked?
check('.agree_boleto')
exit
find('x')
find('#user_mobile_operator')
page.find('#user_mobile_operator')
page.body
puts page.body
find '#one'
find('#one').find('select')
find('#one').find('Operadora')
find('#one').find('.gray')
find('#one').find('#user_name')
find('#one').find('#user_mobile_operator')
find('#one').find('#user_mobile')
find('#one').find('#user_mobile,')
exit
User.all
puts page.body
exit
params[:type]
params[:user]
params
exit
params
params[:user][:type]
params[:type]
params
exit
params[:user]
exit
params
exit
params
exit
params
exit
params
exit
params[:user]
exit
c
c.label
next
step
next
step
@object_name
eixt
exit
next
step
method
step
options
next
step
value
next
exit
c.label :amount
exit
puts page.body
puts page.find('#one')
page.find('#one')
page.find('#one').find('.errors')
page.find('#one').body
page.find('#one').html
puts page.body
exit
click_button 'Concluir com boleto'
click_button 'Concluir compra com boleto'
exit
params1.merge(params2)
params2
params2.reject{|k,v| v.nil?}
params2.reject{|k,v| v.blank?}
params2.reject!{|k,v| v.blank?}
params1.reject!{|k,v| v.blank?}
exit
page.find('#one')
puts page
page.current_pah
page.current_path
puts page.body
exit
page.find('#one')
puts page.bodu
puts page.body
exit
puts page.body
exit
find 'Li e aceito os termos de uso'
find '[content="Li e aceito os termos de uso"]'
find '[content=Li e aceito os termos de uso]'
find "[content='Li e aceito os termos de uso']"
find '#agree'
first '#agree'
first('#agree').click
first('#agree').check
exit
first('.agree')
first('agree')
first('#agree')
first('#agree').click
eit
exit
page.find('.term')
page.first('.term')
exit
page.first('.term')
page.first('.term').visible?
page.first('.term label.error').visible?
page.first('.term')
page.first('.term').text
page.last('.term').text
page.second('.term').text
page.second('.term').texte
exit
page.find('#one')
page.find('#one .about-card')
exit
page.click_button 'Concluir compra com boleto'
exit
expect(page.find('.first-card .field_amount')).to_not visible
page.find('.first-card .field_amount')
expect(page.find('.first-card')).to_not have_css('.field_amount')
exit
eixt
exit
page.find('.second-card')
page.find('.second-card .field_name')
page.find('.second-card .field_name').text
exit
next
step
method_name
self.url_for(method_name)
step
next
method
data
Date.today + 2.day
Date.today + 2.days
Date.today + 20.days
Date.today + 16.days
Date.today + 16
Date.today + 17
Date.today + "17"
class X
  def y(*a)
    puts a
  end
end
g=X.new
g.y
g.y 'a
'
g.y 'a', 'b'
class X
  def y(*a)
    puts a.inspect
  end
end
g=X.new
g.y 'a', 'b'
g.y type: 'a', 'b'
g.y {type: 'a'}, 'b'
g.y type: 'a', x: 'b'
exit
next
step
self.url_for(method_name)
step
next
response
exit
data
exit
order.customer
order.customer.to_s
order
connection.merchant_id
order.id.to_s
order
order.customer
order.customer.name
next
response
exit
data
method
exit
data
exit
next
@request.body
exit
data
exit
next
::HTTPI.post @request
@request
def post_xml path, xml
  host = "https://homologacao.pagador.com.br"
  http = Net::HTTP.new(host)
  resp = http.post(path, xml, {'Content-Type' => 'application/soap+xml; charset=utf-8' })
  resp.body
end
h = {
  "request" => {
    "OrderData"      => {"MerchantId" => connection.merchant_id, "OrderId" => order.id.to_s},
    "PaymentDataCollection" => [{"PaymentMethod" => order.payment_method, "Amount" => order.amount, "Currency" => "BRL", "Country" => "BRA"}],
    "CustomerData"          => {"CustomerName" => order.customer.name}
  }
}
response = gateway.purchase order, credit_card
whereami
exit
next
{
  "request" => {
    "OrderData"      => {"MerchantId" => connection.merchant_id, "OrderId" => order.id.to_s},
    "PaymentDataCollection" => [{"PaymentMethod" => order.payment_method, "Amount" => order.amount, "Currency" => "BRL", "Country" => "BRA"}],
    "CustomerData"          => {"CustomerName" => order.customer.name}
  }
}
x=_
exit
next
headers
@request.headers
@request.headers = { 'Content-Type' => 'application/soap+xml; charset=utf-8' }
::HTTPI.post @request
data
@request.body = data.xml
@request.body = data.to_xml
::HTTPI.post @request
data.merge("Version"=>"1.9.5.1")
@request.body = data.merge("Version"=>"1.9.5.1").to_xml
::HTTPI.post @request
exit
Savon.log = true
HTTPI::Adapter.use = :net_http
exit
next
exc.backtrace
exit
next
exit
@savon_client.call(:authorize_transaction)
@savon_client.call(:authorize_transaction, message: body)
@savon_client.call(:authorize_transaction, namespace: '')
@savon_client.call(:authorize_transaction, xml: body)
whereami
next
response
response.to_hash
exit
@savon_client.call(:authorize_transaction)
@savon_client.call('authorize_transaction')
exit
@savon_client.call(:authorize_transaction)
xml = '<request>  <OrderData>  <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId>  <OrderId>0000</OrderId>  <BraspagOrderId xsi:nil="true" />  </OrderData>  <CustomerData>  <CustomerIdentity>99999999999</CustomerIdentity>  <CustomerName>Comprador Teste</CustomerName>  <CustomerEmail>compradot@teste.com</CustomerEmail>  <CustomerAddressData xsi:nil="true" />  <DeliveryAddressData xsi:nil="true" />  </CustomerData>  <PaymentDataCollection>  <PaymentDataRequest xsi:type="CreditCardDataRequest">  <PaymentMethod>997</PaymentMethod>  <Amount>500</Amount>  <Currency>BRL</Currency>  <Country>BRA</Country>  <NumberOfPayments>1</NumberOfPayments  <PaymentPlan>0</PaymentPlan>  <TransactionType>1</TransactionType>  <CardHolder>Comprador Teste</CardHolder>  <CardNumber>0000000000000001</CardNumber>  <CardSecurityCode>123</CardSecurityCode>  <CardExpirationDate>05/2018</CardExpirationDate>  <AdditionalDataCollection xsi:nil="true" />  </PaymentDataRequest>  </PaymentDataCollection>  <RequestId>309DC2AE-B327-E311-93FD-0026B939D54B</RequestId>  <Version>1.0</Version>  </request>'
@savon_client.call(:authorize_transaction, message: xml)
xml = '<?xml version="1.0" encoding="utf-8"?> <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">  <soap:Body>  <AuthorizeTransaction xmlns="https://www.pagador.com.br/webservice/pagador">  <request>  <OrderData>  <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId>  <OrderId>0000</OrderId>  <BraspagOrderId xsi:nil="true" />  </OrderData>  <CustomerData>  <CustomerIdentity>99999999999</CustomerIdentity>  <CustomerName>Comprador Teste</CustomerName>  <CustomerEmail>compradot@teste.com</CustomerEmail>  <CustomerAddressData xsi:nil="true" />  <DeliveryAddressData xsi:nil="true" />  </CustomerData>  <PaymentDataCollection>  <PaymentDataRequest xsi:type="CreditCardDataRequest">  <PaymentMethod>997</PaymentMethod>  <Amount>500</Amount>  <Currency>BRL</Currency>  <Country>BRA</Country>  <NumberOfPayments>1</NumberOfPayments  <PaymentPlan>0</PaymentPlan>  <TransactionType>1</TransactionType>  <CardHolder>Comprador Teste</CardHolder>  <CardNumber>0000000000000001</CardNumber>  <CardSecurityCode>123</CardSecurityCode>  <CardExpirationDate>05/2018</CardExpirationDate>  <AdditionalDataCollection xsi:nil="true" />  </PaymentDataRequest>  </PaymentDataCollection>  <RequestId>309DC2AE-B327-E311-93FD-0026B939D54B</RequestId>  <Version>1.0</Version>  </request>  </AuthorizeTransaction> </soap:Body></soap:Envelope>'
xml
@savon_client.call(:authorize_transaction, xml: xml)
xml = '<?xml version="1.0" encoding="utf-8"?> <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">  <soap:Body>  <AuthorizeTransaction>  <request>  <OrderData>  <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId>  <OrderId>0000</OrderId>  <BraspagOrderId xsi:nil="true" />  </OrderData>  <CustomerData>  <CustomerIdentity>99999999999</CustomerIdentity>  <CustomerName>Comprador Teste</CustomerName>  <CustomerEmail>compradot@teste.com</CustomerEmail>  <CustomerAddressData xsi:nil="true" />  <DeliveryAddressData xsi:nil="true" />  </CustomerData>  <PaymentDataCollection>  <PaymentDataRequest xsi:type="CreditCardDataRequest">  <PaymentMethod>997</PaymentMethod>  <Amount>500</Amount>  <Currency>BRL</Currency>  <Country>BRA</Country>  <NumberOfPayments>1</NumberOfPayments  <PaymentPlan>0</PaymentPlan>  <TransactionType>1</TransactionType>  <CardHolder>Comprador Teste</CardHolder>  <CardNumber>0000000000000001</CardNumber>  <CardSecurityCode>123</CardSecurityCode>  <CardExpirationDate>05/2018</CardExpirationDate>  <AdditionalDataCollection xsi:nil="true" />  </PaymentDataRequest>  </PaymentDataCollection>  <RequestId>309DC2AE-B327-E311-93FD-0026B939D54B</RequestId>  <Version>1.0</Version>  </request>  </AuthorizeTransaction> </soap:Body></soap:Envelope>'
@savon_client.call(:authorize_transaction, xml: xml)
@savon_client.call(:AuthorizeTransaction, xml: xml)
@savon_client.call(:authorize_transaction, xml: xml)
xml = '<?xml version="1.0" encoding="utf-8"?> 
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"> 
 <soap:Body> 
 <AuthorizeTransaction xmlns="https://www.pagador.com.br/webservice/pagador"> 
 <request> 
 <OrderData> 
 <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId> 
 <OrderId>0000</OrderId> 
 <BraspagOrderId xsi:nil="true" /> 
 </OrderData> 
 <CustomerData> 
 <CustomerIdentity>99999999999</CustomerIdentity> 
 <CustomerName>Comprador Teste</CustomerName> 
 <CustomerEmail>compradot@teste.com</CustomerEmail> 
 <CustomerAddressData xsi:nil="true" /> 
 <DeliveryAddressData xsi:nil="true" /> 
 </CustomerData> 
 <PaymentDataCollection> 
 <PaymentDataRequest xsi:type="CreditCardDataRequest"> 
 <PaymentMethod>997</PaymentMethod> 
 <Amount>500</Amount> 
 <Currency>BRL</Currency> 
 <Country>BRA</Country> 
 <NumberOfPayments>1</NumberOfPayments> 
 <PaymentPlan>0</PaymentPlan> 
 <TransactionType>1</TransactionType> 
 <CardHolder>Comprador Teste</CardHolder> 
 <CardNumber>0000000000000001</CardNumber> 
 <CardSecurityCode>123</CardSecurityCode> 
 <CardExpirationDate>05/2018</CardExpirationDate> 
 <AdditionalDataCollection xsi:nil="true" /> 
 </PaymentDataRequest> 
 </PaymentDataCollection> 
 <RequestId>10000000-0000-0000-0000-000000000000</RequestId> 
 <Version>1.0</Version> 
 </request> 
 </AuthorizeTransaction> 
 </soap:Body> '
@savon_client.call(:authorize_transaction, xml: xml)
xml = '<?xml version="1.0" encoding="utf-8"?> 
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"> 
 <soap:Body> 
 <AuthorizeTransaction> 
 <request> 
 <OrderData> 
 <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId> 
 <OrderId>0000</OrderId> 
 <BraspagOrderId xsi:nil="true" /> 
 </OrderData> 
 <CustomerData> 
 <CustomerIdentity>99999999999</CustomerIdentity> 
 <CustomerName>Comprador Teste</CustomerName> 
 <CustomerEmail>compradot@teste.com</CustomerEmail> 
 <CustomerAddressData xsi:nil="true" /> 
 <DeliveryAddressData xsi:nil="true" /> 
 </CustomerData> 
 <PaymentDataCollection> 
 <PaymentDataRequest xsi:type="CreditCardDataRequest"> 
 <PaymentMethod>997</PaymentMethod> 
 <Amount>500</Amount> 
 <Currency>BRL</Currency> 
 <Country>BRA</Country> 
 <NumberOfPayments>1</NumberOfPayments> 
 <PaymentPlan>0</PaymentPlan> 
 <TransactionType>1</TransactionType> 
 <CardHolder>Comprador Teste</CardHolder> 
 <CardNumber>0000000000000001</CardNumber> 
 <CardSecurityCode>123</CardSecurityCode> 
 <CardExpirationDate>05/2018</CardExpirationDate> 
 <AdditionalDataCollection xsi:nil="true" /> 
 </PaymentDataRequest> 
 </PaymentDataCollection> 
 <RequestId>10000000-0000-0000-0000-000000000000</RequestId> 
 <Version>1.0</Version> 
 </request> 
 </AuthorizeTransaction> 
 </soap:Body> '
@savon_client.call(:authorize_transaction, xml: xml)
exit
whereami
xml = '<?xml version="1.0" encoding="utf-8"?> 
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"> 
 <soap:Body> 
 <AuthorizeTransaction> 
 <request> 
 <OrderData> 
 <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId> 
 <OrderId>0000</OrderId> 
 <BraspagOrderId xsi:nil="true" /> 
 </OrderData> 
 <CustomerData> 
 <CustomerIdentity>99999999999</CustomerIdentity> 
 <CustomerName>Comprador Teste</CustomerName> 
 <CustomerEmail>compradot@teste.com</CustomerEmail> 
 <CustomerAddressData xsi:nil="true" /> 
 <DeliveryAddressData xsi:nil="true" /> 
 </CustomerData> 
 <PaymentDataCollection> 
 <PaymentDataRequest xsi:type="CreditCardDataRequest"> 
 <PaymentMethod>997</PaymentMethod> 
 <Amount>500</Amount> 
 <Currency>BRL</Currency> 
 <Country>BRA</Country> 
 <NumberOfPayments>1</NumberOfPayments> 
 <PaymentPlan>0</PaymentPlan> 
 <TransactionType>1</TransactionType> 
 <CardHolder>Comprador Teste</CardHolder> 
 <CardNumber>0000000000000001</CardNumber> 
 <CardSecurityCode>123</CardSecurityCode> 
 <CardExpirationDate>05/2018</CardExpirationDate> 
 <AdditionalDataCollection xsi:nil="true" /> 
 </PaymentDataRequest> 
 </PaymentDataCollection> 
 <RequestId>10000000-0000-0000-0000-000000000000</RequestId> 
 <Version>1.0</Version> 
 </request> 
 </AuthorizeTransaction> 
 </soap:Body> '
whereami
@savon_client.call(:authorize_transaction, xml:xml)
xml
r=@savon_client.call(:authorize_transaction, xml:xml)
@savon_client.get_projects
@savon_client.get_methods
host = "https://homologacao.pagador.com.br"
http = Net::HTTP.new(host)
resp = http.post(path, xml, { 'Content-Type' => 'application/soap+xml; charset=utf-8' })
xml = '<?xml version="1.0" encoding="utf-8"?> 
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"> 
 <soap:Body> 
 <AuthorizeTransaction> 
 <request> 
 <OrderData> 
 <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId> 
 <OrderId>0000</OrderId> 
 <BraspagOrderId xsi:nil="true" /> 
 </OrderData> 
 <CustomerData> 
 <CustomerIdentity>99999999999</CustomerIdentity> 
 <CustomerName>Comprador Teste</CustomerName> 
 <CustomerEmail>compradot@teste.com</CustomerEmail> 
 <CustomerAddressData xsi:nil="true" /> 
 <DeliveryAddressData xsi:nil="true" /> 
 </CustomerData> 
 <PaymentDataCollection> 
 <PaymentDataRequest xsi:type="CreditCardDataRequest"> 
 <PaymentMethod>997</PaymentMethod> 
 <Amount>500</Amount> 
 <Currency>BRL</Currency> 
 <Country>BRA</Country> 
 <NumberOfPayments>1</NumberOfPayments> 
 <PaymentPlan>0</PaymentPlan> 
 <TransactionType>1</TransactionType> 
 <CardHolder>Comprador Teste</CardHolder> 
 <CardNumber>0000000000000001</CardNumber> 
 <CardSecurityCode>123</CardSecurityCode> 
 <CardExpirationDate>05/2018</CardExpirationDate> 
 <AdditionalDataCollection xsi:nil="true" /> 
 </PaymentDataRequest> 
 </PaymentDataCollection> 
 <RequestId>10000000-0000-0000-0000-000000000000</RequestId> 
 <Version>1.0</Version> 
 </request> 
 </AuthorizeTransaction> 
 </soap:Body> '
host = "https://homologacao.pagador.com.br"
http = Net::HTTP.new(host)
resp = http.post('/webservice/pagadorTransaction.asmx?op=AuthorizeTransaction', xml, { 'Content-Type' => 'application/soap+xml; charset=utf-8' })
return resp.body
exit
xml = '<?xml version="1.0" encoding="utf-8"?> 
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"> 
 <soap:Body> 
 <AuthorizeTransaction> 
 <request> 
 <OrderData> 
 <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId> 
 <OrderId>0000</OrderId> 
 <BraspagOrderId xsi:nil="true" /> 
 </OrderData> 
 <CustomerData> 
 <CustomerIdentity>99999999999</CustomerIdentity> 
 <CustomerName>Comprador Teste</CustomerName> 
 <CustomerEmail>compradot@teste.com</CustomerEmail> 
 <CustomerAddressData xsi:nil="true" /> 
 <DeliveryAddressData xsi:nil="true" /> 
 </CustomerData> 
 <PaymentDataCollection> 
 <PaymentDataRequest xsi:type="CreditCardDataRequest"> 
 <PaymentMethod>997</PaymentMethod> 
 <Amount>500</Amount> 
 <Currency>BRL</Currency> 
 <Country>BRA</Country> 
 <NumberOfPayments>1</NumberOfPayments> 
 <PaymentPlan>0</PaymentPlan> 
 <TransactionType>1</TransactionType> 
 <CardHolder>Comprador Teste</CardHolder> 
 <CardNumber>0000000000000001</CardNumber> 
 <CardSecurityCode>123</CardSecurityCode> 
 <CardExpirationDate>05/2018</CardExpirationDate> 
 <AdditionalDataCollection xsi:nil="true" /> 
 </PaymentDataRequest> 
 </PaymentDataCollection> 
 <RequestId>10000000-0000-0000-0000-000000000000</RequestId> 
 <Version>1.0</Version> 
 </request> 
 </AuthorizeTransaction> 
 </soap:Body> '
@savon_client.call(:authorire_transaction, xml:xml)
@savon_client.call(:authorize_transaction, xml:xml)
xml = '<?xml version="1.0" encoding="utf-8"?> <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">  <soap:Body>  <AuthorizeTransaction>  <request>  <OrderData>  <MerchantId>{309DC2AE-B327-E311-93FD-0026B939D54B}</MerchantId>  <OrderId>0000</OrderId>  <BraspagOrderId xsi:nil="true" />  </OrderData>  <CustomerData>  <CustomerIdentity>99999999999</CustomerIdentity>  <CustomerName>Comprador Teste</CustomerName>  <CustomerEmail>compradot@teste.com</CustomerEmail>  <CustomerAddressData xsi:nil="true" />  <DeliveryAddressData xsi:nil="true" />  </CustomerData>  <PaymentDataCollection>  <PaymentDataRequest xsi:type="CreditCardDataRequest">  <PaymentMethod>997</PaymentMethod>  <Amount>500</Amount>  <Currency>BRL</Currency>  <Country>BRA</Country>  <NumberOfPayments>1</NumberOfPayments  <PaymentPlan>0</PaymentPlan>  <TransactionType>1</TransactionType>  <CardHolder>Comprador Teste</CardHolder>  <CardNumber>0000000000000001</CardNumber>  <CardSecurityCode>123</CardSecurityCode>  <CardExpirationDate>05/2018</CardExpirationDate>  <AdditionalDataCollection xsi:nil="true" />  </PaymentDataRequest>  </PaymentDataCollection>  <RequestId>309DC2AE-B327-E311-93FD-0026B939D54B</RequestId>  <Version>1.0</Version>  </request>  </AuthorizeTransaction> </soap:Body></soap:Envelope>'
@savon_client.call(:authorize_transaction, xml:xml)
exit
next
exit
next
exit
next
@savon_client.call(:authorize_transaction, message: body)
exit
next
@savon_client.call(:authorize_transaction, xml:xml)
exit
card_one
@gateway.mount_credit_card(card_one)
exit
invoice.bill
exit
params[:credit_cards]
params[:credit_cards].each{|x| x}
params[:credit_cards].each{|x,y| y}
params[:credit_cards].each{|x| x.last}
params[:credit_cards].each{|x| putz x.last}
params[:credit_cards].each{|x| puts x.last}
params[:credit_cards].each{|x,y| puts y}
params[:credit_cards].each{|x,y| puts x}
exit
next
credit_cards
next
@card_one
@associate.credit_cards.second
exit
next
subscription.valid?
subscription.errors
exit
next
subscription.valid?
subscription.errors
exit
next
exception
exit
next
exit
invoice = Invoice.new subscription
next
exception
exit
@xml_data
exit
@xml_data
next
xml
xml.gsub('\n', '')
xml.gsub("\n", '')
xml.gsub("\n", '').gsub('  ', '')
xml = xml.gsub("\n", '').gsub('  ', '')
whereami
@client.call(:authorize_transaction, xml:xml)
xml = xml.gsub('  ', '')
@client.call(:authorize_transaction, xml:xml)
exit
@client.call(:authorize_transaction, xml:xml)
exit
@client.call(:authorize_transaction, xml:xml)
exit
@client.call(:authorize_transaction, xml:xml)
exit
@client.call(:authorize_transaction, xml:xml)
exity
exit
invoice
exit
invoice.response
exit
next
exception
exit
@response
@response.success?
response.success?
success?
exit
@invoice
@invoice.error
@invoice.errors
@invoice.error
exit
@invoice.error
response
next
exit
exite
exitee
e
e.to_s
exit
next
exception
exit
next
exception
exit
next
exception
exit
next
exception
exit
Product
Product.find_by_plan_type params[:user][:type]
next
procut
product
next
product
next
exception
exit
next
exception
exit
next
order_item.valid?
exit
next
exception
exit
next
exception
exit
next
exit
next
exit
next
exit
product
@dependent
next
step
next
exception
exit
next
exception
exit
next
exception
exit
next
exception
exit
whereami
exit
next
order_item.valid?
order.valid?
exit
next
order.valid/
order.valid?
order.errors
exit
next
step
next
exception
exit
response
@incoive.payment_data
@incoice.payment_data
@invoice.payment_data
raise
raise Exception
exit
@invoice.payment_data
@invoice.response
exit
@invoice.payment_data
exit
method_hash
@config_hash[:payment_methods][method_hash[:flag]]
exit
|
order
order.total
order.set_total
order.items
order.order_items
order.order_items.sum{|i| i.exit
  exit
order.total
order.set_total
order.order_items.sum{|i| i.total_price}
order.order_items.first.total_price
order.order_items
order.order_items.sum{|i| i.total_price }
order.order_items.sum(&:total_price)
order.order_items.sum(:total_price)
order.order_items.sum('total_price')
order.order_items.inject(0){|sum, item| sum + item.total_price }
exit
self.order_items.inject(0) { |sum, item| sum + item.total_price }
self.order_items
exit
self.order_items.inject(0) { |sum, item| sum + item.total_price }
self.order_items
exit
self.unit_price * self.quantity
self
self.product
self.producte
exit
next
self.unit_price * self.quantity
exit
self.order_items.inject(0) { |sum, item| sum + item.total_price }
exit
self.order_items
self.order_items.sum(&:total_price)
self.order_items.sum{|item| item.total_price}
self.order_items.summary
self.order_items.summarize
exit
raise Exception
exit
self.product
self.product.plan_type
self.product.plan_type == :single
raise Exception
exit
self.order
self
self.product
self.product.new title: 'x', price: 10
self.products.new title: 'x', price: 10
self.product.new title: 'x', price: 10
self.product = Product.new title: 'x', price: 10
self.product
self.product.order_item
o = Order.new
o.order_item = [OrderItem.new]
o.order_items = [OrderItem.new]
o.order_items
o.order_items.first
o.order_items.first.order
exit
self.user_for_subscription
self.dependent_for_subscription
exit
@invoice
@invoice.response
whereami
exit
data
exit
next
order.valid?
exit
next
credit_cards
credit_cards.map(&:amount)
credit_cards.map{|c| c.amount.to_f}
exit
next
self.total
total
self.user.credit_cards
self.user.credit_cards.each {|card| card.errors.add :amount, :invalid }
exit
expire_date
Date.today < expire_date
Date.today
exit
order.valid?
next
credit_cards
next
self.total
total
exit
order.errors
exit
order.valid?
exit
order.errors
exit
order.valid?
exit
order.valid?
reload!
order.set_total
order.user.credit_cards
order.user.credit_cards.map(&:amount)
exit
next
self.total
total
self.total != total
self.user.credit_cards.each { |card| card.errors.add :amount, :invalid } 
self.valid?
exit
next
self.total
total
self.user.credit_cards.each { |card| card.errors.add :amount, :invalid } 
self.valid?
exit
whereami
self.errors.add :user, :credit_cards, :amount, :invalid
exit
next
self.user
self.parent
parent
self.user
exit
order.valid?
order.errors
order.errors[:basee]
order.errors[:base]
exit
next
exception
exit
next
exception
exit
next
exit
@associate
@associate.type
params
params[:user]
exit
params[:cards]
exit
params[:cards]
exit
params[:cards]
exit
method_hash
exit
next
exit
mail.response
mail
mail.delive!
whereami
Notification.send_sign_up(@associate).deliver!
exit
order.id
next
order
order.id
invoiced? orde
invoiced? orded
invoiced? order
exit
next
exception
exit
next
method_hash
exit
next
exit
order.id
exit
next
exit
order.valid?
next
exception
exit
order
order.errors
order.errors[:base]
order.errors[:base].present?
@invoice
@invoice.errors
@invoice.error
@invoice.response
exit
@invoice.success?
@invoice.response
exit
puts page.body
User.all
User.first
User.first.email
exit
page.body
exit
next
step
next
step
exit
next
step
exit
params
whereami
next
credit_cards
next
order.valid?
order.errors
exit
next
exit
next
exit
next
credit_cards
next
credit_cards.first.amount
next
credit_cards.last.amount
total
exit
next
total
self.total
set_total
self.order_items
self.products
exit
self.total
exit
self.products
products
attrs
attrs[:products]
exit
self.products
exit
return
exit
self.products
next
exception
exit
next
product
exit
next
self.product
step
exit
self
self.subscription
self.subscription.build
self.order_items
self.discounts
self.discounts.build
exit
self.subscription
self.subscription.build
exit
next
order.valid?
exit
whereami
self.product
self.product.get_automatic_discount
exit
self.discounts
self.discounts.build product_discount: self.product.get_automatic_discount, friend_id: self.dependent_for_subscription
self.discounts
self.product
self.product.get_automatic_discount
self.discounts.first
self.discounts.first.product_discount
exit
next
self.discounts
exit
self.unit_price
self.quantity
self.discount
exit
whereami
next
self.config_hash
self.config_hash.include? method_name
method_name
self.config_hash.include? method_name.to_s
exit
method_name
exit
next
exit
method_name
self.config_hash.keys.include? method_name.to_s
self.config_hash[method_name.to_s]
exit
credit_cards
@associate_credit_cards
@associate.credit_cards
@associate.credit_cards.first
@associate.credit_cards.secound
@associate.credit_cards.second
@associate.credit_cards.third
exit
order.errors
exit
next
exit
order.valid?
order.errors
order.errors.present?
order.errors[:base]
order.errors[:base] ? 1 : 2
exit
next
exit
next
order.errors
exit
next
invoice.error
exit
next
exit
FactoryGirl.create(:single_subscription)
FactoryGirl.create(:dual_subscription)
exit
FactoryGirl.create(:dual_subscription)
x=_
x.product_discounts
exit
x
exit
user_params
next
@associate
@dependent
whereami
nextexit
exit
next
exit
auth_options
warden.authenticate!(auth_options)
next
exit
flash
flash.present?
flash.first
exit
flashe
exit
flash
flashes
flash.first
flash.each{|x| puts x}
flash.each{|x, y| puts x}
flash.each{|x, y| puts y}
exit
root_path
user_confirmation_url
user_confirmation_url email: 'aaaa'
user_confirmation_url User.first
exit
current_user
current_user.orders
exit
self.payments
exit
self.payments.valided
self.payments
self.payments.valided
exit
self.payments.valided
self.payments.valided.first
exit
self.payments.valided
self.payments.valided.sum(:amount)
exit
self.payments.valided
exit
self.payments.valided
self.payments.valided.sum(:amount)
self.total
"%.2f" % self.payments.valided.sum(:amount)
self.payments.valided.sum(:amount)
self.payments.valided.sum(:amount_f)
self.payments.first
self.payments.first.amount
self.payments.first.amount.to_s
self.payments.first.amount.to_s[0..-2]
self.payments.first.amount.to_s[0..-1]
self.payments.first.amount.to_s[0..-3]
self.payments.first.amount.to_s[1..-3]
self.payments.first.amount.to_s[0...-3]
self.payments.first.amount.to_s[0..-3]
"100.01".to_f
self.payments.first.amount.to_s[-3..-1]
self.payments.first.amount.to_s[-2..-1]
exit
self.payments.valided
self.payments.valided.map(&:amount_f)
self.payments.valided.sum(&:amount_f)
self.payments.valided.sum(:amount_f)
self.payments.valided.sum(&:amount_f)
self.total
exit
self.payments.valided.sum(&:amount_f) == self.total
next
orders_with_debts
orders_with_debts.any?
orders_with_debts.present?
exit
session
aaaaa
exit
session
exit
current_user
exit
eexit
exit
credit_cards
index
data
credit_cards[data]
self.user.credit_cards
self.user.credit_cards.find credit_cards[data]
self.user.credit_cards.find credit_cards[data].slice(:number, :expire_month, :expire_year)
raise
exit
next
exit
format_to_find_credit_card(credit_cards[index]) 
self.user.credit_cards.find format_to_find_credit_card(credit_cards[index])
self.user.credit_cards.first
self.user.credit_cards.where format_to_find_credit_card(credit_cards[index])
self.user.credit_cards.where(format_to_find_credit_card(credit_cards[index]))
self.user.credit_cards.where(format_to_find_credit_card(credit_cards[index])).first
exit
self.user.credit_cards.find format_to_find_credit_card(credit_cards[index])
self.user.credit_cards.where(format_to_find_credit_card(credit_cards[index]))
self.user.credit_cards.find_by format_to_find_credit_card(credit_cards[index])
self.user.credit_cards.first format_to_find_credit_card(credit_cards[index])
self.user.credit_cards.find(condition: format_to_find_credit_card(credit_cards[index]))
self.user.credit_cards.find(conditions: format_to_find_credit_card(credit_cards[index]))
self.user.credit_cards.find(:first, conditions: format_to_find_credit_card(credit_cards[index]))
exit
format_to_find_credit_card(credit_cards[index])
exit
format_to_find_credit_card(credit_cards[index])
exit
next
exit
order.class
order
order.payments
order.payments.each { |p| p.amount }
order.payments.each { |p| puts p.amount }
order.payments.each { |p| puts p.valided? }
order.payments.each { |p| puts p.amount_f }
order.payments.each { |payment| puts payment.amount_f }
exit
order.payments
order.payments.first
exit
exuit
exit
order.payments.invalided
order.payments.invalided.sum(&:amount_f)
exit
current_user
exit
referer
request
request.path
exit
render params
params
exit
params
exit
next
exception
exit
next
exception
exit
nxt
next
exception
exit
next
exception
exit
next
exception
exit
next
exit
order.pending_amount
next
invoice.bill?
exit
amount_for_billet
by_billet(amount: amount_for_billet || order.total)
amount_for_billet || order.total
exit
next
orders_with_debts
orders_with_debts.first.pending_amount
orders_with_debts.first.payments
orders_with_debts.first.payments.last.delete
orders_with_debts.first.payments.last.delete!
orders_with_debts.first.payments.last.delete_all
orders_with_debts.first.payments
orders_with_debts.first.payments.invalided
exit
credit_cards_params
next
exception
exit
credit_cards.blank?
self.user.credit_cards
self.user.credit_cards.select { |c| c.inactive == false }
self.user.credit_cards.select { |c| not c.inactive }
exit
next
orders_with_debts
orders_with_debts.payments
orders_with_debts.first.payments
exit
order.payments
next
order.payments
order.reload.payments
exit
order
order.valid?
order.errors
order.user.credit_cards
exit
next
credit_cards
credit_cards.map(:amount)
credit_cards.map(&:amount)
exit
next
exit
next
self.total
paid
total
exit
next
exit
next
exception
exit
next
order.payments
order.payments.valided
order.payments.valided.present?
next
order.user.credit_cards.valided.last
order.user.credit_cards
order.user.credit_cards.map(&:amount)
exit
next
order.user.credit_cards.select{|c| c.amount.present? }.last
exit
next
exit
next
orders_with_debts
next
exit
@orders_with_debts
@orders_with_debts.present?
next
@pending_orders.present?
exit
@orders_with_debits.present?
@orders_with_debts
@orders_with_debts.present?
exit
next
pending_orders
next
session
exit
next
orders_with_debits
next
exit
next
orders_with_debits
next
exit
next
orders_with_debits
exit
next
pending_orders
next
exit
next
exit
next
step
next
exit
next
with_card
order.payments.blank?
order.payments.valided.present?
order.payments.valided
exit
next
order.user.credit_cards.select{|c| c.amount.present? }.last
exit
verify_if_user_has_debits
verify_if_user_has_pending_billet
current_user.orders
current_user.orders.pendings
current_user.orders.first.payments
current_user.orders.first.payments.map(&:status)
exit
verify_if_user_has_debits 
current_user.orders
current_user.orders.first.all_right?
current_user.orders.first.payments.valided.sum(&:amount_f)
current_user.orders.first.payments.valided
exit
verify_if_user_has_debits
current_user.orders.first.all_right?
current_user.orders.first.payments.valided
exit
verify_if_user_has_pending_billet 
exit
verify_if_user_has_pending_billet
current_user.orders.pendings
exit
current_user.orders.pendings
exit
verify_if_user_has_pending_billet
current_user.orders.pendings
current_user.orders.pendings.payments
current_user.orders.pendings.payment
current_user.orders.pendings.first
current_user.orders.pendings.first.payments
current_user.orders.first.status
exit
current_user.orders.first.status
verify_if_user_has_pending_billet
exit
verify_if_user_has_pending_billet 
exit
params
exit
params
exit
Category.xxx
exit
Category.xxx
Category.where(parent_id: nil)
Category.where(parent_id: nil).select(:name)
Category.where(parent_id: nil).inject({}){|c, h| h << c}
Category.where(parent_id: nil).inject({}){|c, h| h << c; h}
Category.where(parent_id: nil).inject({}){|c, h| h << {parent: c}; h}
Category.where(parent_id: nil).inject({}){|c,h| h << {parent: c}; h}
x=Category.where(parent_id: nil).inject({}){|c,h| h << {parent: c}; h}
x
x=Category.where(parent_id: nil).inject([]){|c,h| h << {parent: c}; h}
x=Category.where(parent_id: nil).inject([]){|c,h| h << {parent: c}; h}; nil
x
x=Category.where(parent_id: nil).inject([]){|c,h| h.push {parent: c}; h}; nil
x=Category.where(parent_id: nil).inject([]){|c,h| h.push({parent: c}); h}; nil
x=Category.where(parent_id: nil).inject([]){|c,h| h.push(parent: c); h}; nil
x=Category.where(parent_id: nil).inject([]){|h,c| h.push(parent: c); h}; nil
x
x=Category.where(parent_id: nil).inject([]){|h,c| h.push(parent: c, children: Category.where(parent_id); h}; nil
exit
Category.xxx
exit
Category.xxx
exit
Category.xxx
exit
Category.xxx
exit
current_user.categories.xxx
exit
current_user.categories.xxx
Category.xxx
exiut
exit
Category.xxx
Category.where(parent_id: nil)
Category.where(parent_id: nil).count
Category.where(parent_id: nil).map(&:name)
Category.where('parent_id IS NULL').map(&:name)
Category.map(&:name)
Category.all.map(&:name)
Category.all.map(&:parent_id)
Category.all.map(&:name)
exit
Category.all.map(&:name)
Category.all.map(&:parent_id)
exit
Category.xxx
Category.find(3)
exit
Category.xxx
eit
exit
Category.xxx
exit
Category.xxx
exit
Category.xxx
exit
Category.xxx
exit
Category.xxx
exit
category
category.first
category.firstexit
exit
current_user.categories.tree
exit
child
exit
user
user.delete
user.delete!
exit
user
next
exception
exit
next
user.unconfirmed_email
user.email
next
exit
is_navigational_format?
exit
@user
User.where(email: @user.email)
User.where(email: @user.email).any?
User.where(email: "x").any?
exit
@category.parent
@category.children
@category.destroyed?
exit
whereami
next
User.where email: user.email
next
User.where(email: @user.email).any?
next
session['devise.facebook_data']
session['devise.facebook_data']='a'
request.env['omniauth.auth']
next
exit
request.env['omniauth.auth']
request.env['omniauth.auth'].slice(:uid)
exit
request.env['omniauth.auth'].slice(:uid)
request.env['omniauth.auth']
exit
request.env['omniauth.auth']
exit
data['extra']
data
data['info']
data['info']['email']
data['email']
exit
params
exit
params
exit
params
session
exit
session
exit
next
step
next
resource
next
step
next
response_body
exit
eixt
exit
resource
resource.errors
resource.errors.messages
resource.errors.full_messages
exit
resource
resource.provider
resource.provider.present?
exit
next
params
next
def update
  self.resource = resource_class.to_adapter.get!(send(:"current_#{resource_name}").to_key)
  prev_unconfirmed_email = resource.unconfirmed_email if resource.respond_to?(:unconfirmed_email)
  if resource.update_with_password(resource_params)
    if is_navigational_format?
      flash_key = update_needs_confirmation?(resource, prev_unconfirmed_email) ?
      :update_needs_confirmation : :updated
      set_flash_message :notice, flash_key
    end
    sign_in resource_name, resource, :bypass => true
    respond_with resource, :location => after_update_path_for(resource)
  else
    clean_up_passwords resource
    respond_with resource
  end
end
eval("#{params[:controller]}_path")
exit
w
whereami
next
exception
exit
self.
end
self
self.email_changed?
self.email_was
exit
params
exit
params
exit
params
exit
params
@transactions = current_user.transactions.where category_id: params[:categories]
@transactions = current_user.transactions
exit
next
current_user
current_user.transactions
params
current_user.transactions.find 1
next
exit
next
@transaction.errors
params
exit
params
exit
transaction.expired_at
Date.today
transaction.expired_at < Date.today
transaction.it_paid?
exit
next
exception
exit
self.create
self.create name: 'Alimentação'
exit
feed = self.create(name: 'Alimentação')
self.create name: 'Restaurante', parent_id: feed
]
self.create name: 'Supermercado', parent_id: feed
self.create name: 'Animal de estimação', parent_id: feed
exit
next
self.total
next
self.bank_account
self.bank_account.value
self.bank_account.value.to_f
exit
request.env
request.env['HTTP_X_FORWARDED_FOR']
request
request.remote_ip
request.env['HTTP_X_REAL_IP']
request.navigator
request.navigation
request
exit
params
exit
next
exit
request.url
request.request_uri
request.fullpath
request.curretn-path
"".nil?
"".empty?
"".blank?
app
helper
context
exit
flow
Flow.all
Flow.count
exit
@params
exit
parsed_body.keys.first
next
n
continue
exit
parsed_body[key]
JSON.parse(object.class::Entity.represent(object).to_json)
exit
object.class::Entity.represent(object)
object.class::Entity.represent(Flow.find(object))
object.class::Entity.represent(object).to_json
object.class::Entity.represent(Flow.find(object)).to_json
User.first.groups
exit
JSON.parse(object.class::Entity.represent(object).to_json)
parsed_body[key]
exit
Flow
Group.find_by(name: 'Admins')
Group.find_by(name: 'Admins') || create(:group_for_admins, name: 'Admins')
exit
flow
flow.reload
flow.reload.title
exit
Flow.all
Flow::Entity.represent(Flow.all)
exit
object.class.to_s.downcase
object.class.to_s.downcase.pluralizeze
object.class.to_s.downcase.pluralize
whereami
JSON.parse(object.class::Entity.represent(object).to_json)
continue
exit
parsed_body[key]
exit
Flow.all
exit
Flow.all
Flow::Entity.represent(Flow.all)
exit
parsed_body[key]
parsed_body[key].include? JSON.parse(object.class::Entity.represent(object).to_json)
exit
JSON.parse(object.class::Entity.represent(object).to_json)
parsed_body[key]
parsed_body
key
object.class
object.class.underscore
object.class.underscorize
object.class.underscoreize
object.class.to_s.underscoreize
object.class.to_s
object.class.to_s.underscore
exit
next
safe_params.permit(:title, :default)
exit
safe_params
safe_params.permit(:title, :default)
exit
next
Flow.find_by(id: safe_params[:id]).resolution_states
parameters
Flow.find_by(id: safe_params[:id]).resolution_states.find_by(default: true)
Flow.find_by(id: safe_params[:id]).resolution_states.find_by(default: true).id
exit
next
safe_params
exit
next
exit
nex
next
Flow.find_by(id: safe_params[:flow_id])
Flow.find_by(id: safe_params[:flow_id]).resolution_states
ResolutionState.first
ResolutionState.first.flow
ResolutionState.first.flow.resolution_states
exit
self.resolution_states
self.resolution_states.find_by(default: true)
exit
self.resolution_states.find_by(default: true)
self.resolution_states
exit
flow.resolution_states
exit
whereami
flow.resolution_states.first
flow.resolution_states.first.update!(default: true)
flow.resolution_states.first.reload
exit
self.relosution_states
self.resolution_states
exit
self.resolution_states
self.resolution_states.reload
self.resolution_states
exit
self.resolution_states
exit
self.resolution_states
exit
self.resolution_states
exit
self.resolution_states
exit
self.resolution_states
exit
self.resolution_states
exit
self.resolution_states
exit
next
Flow.find_by(id: safe_params[:flow_id]).build_step!(parameters)
Flow.find_by(id: safe_params[:flow_id]).create_step
Flow.find_by(id: safe_params[:flow_id]).create_step!(parameters)
Flow.find_by(id: safe_params[:flow_id]).create_step!(parameters)e
exit
self.child_flow.steps
self.child_flow
self.flow
slef
sel
self
Flow.first
exit
ids
exit
safe_params.permit('ids')
safe_params.permits('ids')
params.permit('ids')
params
exit
ids
exit
ids
exit
Flow.first
Flow.first.steps
ids
self.flow
self.find(ids.first)
exit
index
self.all
exit
index
id
exit
Flow.all
exit
Flow.all
exit
flow.steps
flow.reload.steps
valid_params
exit
flow.steps
flow.reload.steps
valid_params
flow.steps.first
flow.steps.first.reload
exit
self.flow
self.flow.steps
self.flow.steps.max(:order_number)
self.flow.steps.max
exit
self.flow.steps
self.flow
exit
Flow.first
Flow.first.steps
Flow.first.steps.max
Flow.first.steps.max(:order_number)
Flow.first.steps.max_by(:order_number)
Flow.first.steps.max_by(&:order_number)
Flow.first.steps.min_by(&:order_number)
Flow.first.steps.max(&:order_number)
exit
self.flow
self.flow.steps
exit
next
steps.present?
exit
next
steps.present?
steps.max_by(&:order_number) + 1
steps.max_by(&:order_number)
steps.maximun(&:order_number)
steps.maximum(:order_number)
steps.maximum(:order_number) + 1
steps.maximum(:order_numberx) + 1
exit
next
steps.maximum(:order_number)
steps.maximum(:order_number) + 1
exit
URI
url=URI('https://my.interserver.net/login.php')
url=URI('https://my.interserver.net:443/ajax_nosession.php?choice=jformer_submit&gz=0&cmd=loginForm')
f=Faraday.new(url:url)
f=Faraday.new(url:url.to_s)
f.post(url.path, {login_id:'euricovidal@gmail.com',passwd:'mec133'})
r=f.post(url.path, {login_id:'euricovidal@gmail.com',passwd:'mec133'})
r.body
r=f.post(url.path, {login_id:'euricovidal@gmail.com',passwd:'mec133'}, )
f=Faraday.new(url:url.to_s, ssl:{verify:false})
r=f.post(url.path, {login_id:'euricovidal@gmail.com',passwd:'mec133'})
r.body
r.response
r=f.post(url.path, {login_id:'euricovidal@gmail.com',passwd:'mec133'})
require 'net/https'
require 'uri'
Net::HTTP.new
http=Net::HTTP.new url.host, url.post
http=Net::HTTP.new url.host, url.port
http.use_ssl=true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
r=Net::HTTP::Get.new(url.request_uri)
r=http.request(r)
r.body
r.status
r.text
r=f.post(url.path, {login_id:'euricovidal@gmail.com',passwd:'mec133'})
r.response
r.body
r.text
r.methods.sort
r.to_json
r.to_s
r.status
r=f.get('index.php?choice=none.view_vps3&id=10226')
r.body
r.status
uri  = URI('https://my.interserver.net/index.php?choice=none.search&search=ividal.org')
conn = Faraday.new url:uri.to_s
res =conn.get(uri.path)
res.body
res.status
uri  = URI('https://my.interserver.net/ajax_nosession.php?choice=jformer_submit&gz=0&cmd=loginForm')
conn = Faraday.new url:uri.to_s
res = conn.post(uri.path, {login_id:'euricovidal@gmail.com',passwd:'mec133'})
res.body
uri  = URI('https://my.interserver.net')
conn = Faraday.new url:uri.to_s
res = conn.post('/ajax_nosession.php?choice=jformer_submit&gz=0&cmd=loginForm', {login_id:'euricovidal@gmail.com',passwd:'mec133'})
res.body
puts res.body
res.body
uri  = URI('http://localhost/jformer-master/examples/login.php')
conn = Faraday.new url:uri.to_s
res = conn.post(uri.path, {username:'admin',password:'12345'})
res.body
uri  = URI('https://my.interserver.net/ajax_nosession.php')
conn = Faraday.new url:uri.to_s
res = conn.post(uri.path, {jFormerId:'loginForm',jFormer:'%7B%22loginFormPage%22:%7B%22loginFormSection%22:%7B%22login_id%22:%22euricovidal@gmail.com%22,%22passwd%22:%22mec133%22%7D%7D%7D'})
res.body
uri.to_s
uri  = URI('https://my.interserver.net/index.php?choice=none.search&search=ividal.org')
conn = Faraday.new url:uri.to_s
res =conn.get(uri.path)
res.body
conn = Faraday.new 'https://my.interserver.net'
res = conn.post('ajax_nosession.php', {jFormerId:'loginForm',jFormer:'%7B%22loginFormPage%22:%7B%22loginFormSection%22:%7B%22login_id%22:%22euricovidal@gmail.com%22,%22passwd%22:%22mec133%22%7D%7D%7D'})
res.body
res = conn.get('/index.php')
res.body
res = conn.get('/index.php')
res = conn.post('ajax_nosession.php', {jFormerId:'loginForm',jFormer:'%7B%22loginFormPage%22:%7B%22loginFormSection%22:%7B%22login_id%22:%22euricovidal@gmail.com%22,%22passwd%22:%22mec133%22%7D%7D%7D'})
res.headers
res.headers['set-cookie']
res = conn.get('/index.php') {|req| req.headers['set-cookie'] = res.headers['set-cookie'] }
res = conn.post('ajax_nosession.php', {jFormerId:'loginForm',jFormer:'%7B%22loginFormPage%22:%7B%22loginFormSection%22:%7B%22login_id%22:%22euricovidal@gmail.com%22,%22passwd%22:%22mec133%22%7D%7D%7D'})
res = conn.get('/index.php') {|req| req.headers['Set-Cookie'] = "sessionid=b933cbf92562c93136af4741d6ecc59e"; req.headers['Cookie'] = "sessionid=b933cbf92562c93136af4741d6ecc59e" }
res.body
res = conn.get('/index.php') {|req| req.headers['Set-Cookie'] = "sessionid=b933cbf92562c93136af4741d6ecc59e" }
res = conn.get('/index.php') {|req| req.headers['Cookie'] = "sessionid=b933cbf92562c93136af4741d6ecc59e" }
res = conn.get('/index.php') {|req| req.headers['Cookie'] = "sessionid=b07f0ad7519325a80d533590066329e5" }
res.body
exit
next
exit
next
ress.body
ress.status
ress.ok?
ress.success?
xml=Nokogiri.xml(ress.body)
xml=Nokogiri::XML(ress.body)
path=xml.xpath('/html/body/center/form[2]/table/tbody')
path=xml.xpath('//html/body/center/form[2]/table/tbody')
xml.first
xml
path=xml.xpath('/document/html/body/center/form[2]/table/tbody')
path=xml.xpath('/html/body/center/form[2]/table/tbody').children
path=xml.children
path=xml.children.first
path=xml
xml.css('.ui-widget-content')
xml.css('tbody.ui-widget-content')
res = conn.get('/index.php?choice=none.view_vps3&id=5236') {|req| req.headers['Cookie'] = "sessionid=b07f0ad7519325a80d533590066329e5" }
xml=Nokogiri::XML(res.body)
xml.css('#ServerTable')
res = conn.get('/iframe.php?choice=none.view_vps3&id=5236&link=info') {|req| req.headers['Cookie'] = "sessionid=b07f0ad7519325a80d533590066329e5" }
xml=Nokogiri::XML(res.body)
xml.css('#ServerTable')
xml.css('#ServerTable').children
xml.css('#ServerTable').children.first
xml.css('#ServerTable').children.to_hash
xml.css('#ServerTable').to_hash
xml.css('#ServerTable td')
xml.css('#ServerTable td')[1]
exit
Step.find_by(id: safe_params[:step_id], type: 'form')
Step.find_by(id: safe_params[:step_id], step_type: 'form')
Step.find_by(id: safe_params[:step_id])
exit
safe_params
safe_params[:step_id]
Step.find_by(id: safe_params[:step_id])
exit
Step.find_by(id: safe_params[:step_id], type: 'form')
Step.find_by(id: safe_params[:step_id], step_type: 'form')
exit
Step.find_by(id: safe_params[:step_id], step_type: 'form')
Step.find_by(id: safe_params[:step_id], step_type: 'form').field
exit
Step.find_by(id: safe_params[:step_id], step_type: 'form').field
Step.find_by(id: safe_params[:step_id], step_type: 'form').build_field
Step.find_by(id: safe_params[:step_id], step_type: 'form').create_field
exit
Field.new parameters
exit
parameters
safe_params
exit
fields
Field::Entity.represent(fields)
exit
Step.find_by(id: safe_params[:step_id]).triggers.new(parameters)
parameters
exit
Step.find_by(id: safe_params[:step_id]).triggers.new(parameters)
exit
x=Step.find_by(id: safe_params[:step_id]).triggers.new(parameters)
x.valid?
next
e
exit
next
triggers
exit
parameters
x=Step.find_by(id: safe_params[:step_id]).triggers.new(parameters)
x.acion
exit
x=Step.find_by(id: safe_params[:step_id]).triggers.new(parameters)
exit
x=Step.find_by(id: safe_params[:step_id]).triggers.new(parameters)
exit
next
e
exit
parametersa
parameters
Step.find_by(id: safe_params[:step_id]).triggers.new parameters
exit
trigger = Step.find_by(id: safe_params[:step_id]).triggers.create!(trigger_params.merge(trigger_conditions: conditions_params))
exit
trigger = Step.find_by(id: safe_params[:step_id]).triggers.create!(trigger_params.merge(trigger_conditions: conditions_params))
conditions_params
exit
parameters
exit
parameters
Step.find_by(id: safe_params[:step_id]).triggers.new parameters
x=_
x.conditions
x.trigger_conditions
exit
Step.find_by(id: safe_params[:step_id]).triggers.new(parameters)
x=_
x.action_values
next
exit
step
next
exit
safe_params.slice(:fields).merge(created_by: current_user)
exit
next
step.cases.new safe_params.slice(:fields).merge(created_by: current_user)
step.cases.new safe_params.slice(:fields)
safe_params.slice(:fields)
step.cases.new safe_params.slice(:fields)
step.cases.new 'fields' => []
step.cases.new 'fields' => [{}]
step.cases.new 'fields' => [{'id'=>'3'}]
step.cases.new 'fields' => [{"id"=>"3", "value"=>"xxx"}, {"id"=>"2", "value"=>"xxx"}, {"id"=>"1", "value"=>"xxx"}]
step.cases.new {'fields' => [{"id"=>"3", "value"=>"xxx"}, {"id"=>"2", "value"=>"xxx"}, {"id"=>"1", "value"=>"xxx"}]}
step.cases.new({'fields' => [{"id"=>"3", "value"=>"xxx"}, {"id"=>"2", "value"=>"xxx"}, {"id"=>"1", "value"=>"xxx"}]})
step.cases.new(safe_params.slice(:fields))
step.cases.new(safe_params.slice('fields'))
step.cases.new('fields' => safe_params['fields'])
x=_
x.valid?
self.step.fields
self.step.fields.map(&:requirements?)
self.step.fields.each(&:requirements?)
step.cases.new('fields' => safe_params['fields'])
exit
next
self.step.fields
exit
self.step.fields.with_requirements
exit
next
convert_data(field.field_type, data_field['value'])
convert_data(field.field_type, field.requirements['minimum'])
convert_data(field.field_type, field.requirements['maximum'])
field.requirements['presence'] == 'true'
next
custom_validations(field.title, field.field_type, value, minimum, maximum, presence)
field.title
errors.add('xxx', :blank)
errors.add('data', 'xxxx')
exit
next
{data: safe_params.permit(fields: [:id, :value])}
next
parameters.merge(created_by: current_user)
exit
self.step.fields.need_requirements
exit
self.data['fields']
field.id
exit
self.data['fields'].select{|f| f['id'] == field.id.to_s}
self.data['fields'].select{|f| f['id'] == field.id.to_s}.try(:first)
convert_data(field.field_type, data_field['value'])
data_field
next
data_field
field.field_type
next
step
next
step
next
e
exit
next
e
exit
next
exit
next
custom_validations(field.title, field.field_type, value, minimum, maximum, presence)
next
step
?
help
exit
next
cd
whereami
help
whereami
cd custom_validations
c
exit
value =~ EMAIL_FORMAT
exit
data_field
exit
data_field
exit
parameters
exit
kase
Case.last
exit
field
next
field
next
custom_validations(field.title, field.field_type, value, minimum, maximum, presence)
self.errors
errors
errors.messages
step
next
exit
value
name
exit
name
value
exit
self.errors
name
value
next
exit
next
step
extra_args
action
subject
relevant_rules_for_match(action, subject)
relevant_rules_for_match(action, subject).detect{|r| r.matches_conditions?(action, subject, extra_args)}
whereami
next
match
match.base_behavior
bczzaa
exit
action
model
permissions.can? :create, Step
permissions
exit
type
exit
type
exit
field
next
data_field
next
exit
type
exit
type
exit
data_value
value
name
exit
name
exit
params[:images]
next
step
next
self.update_case_images value
exit
name
exit
name
exit
name
exit
self.update_case_images value
self.case_images
self.case_images.first
self.update_case_images! value
name
exit
name
exit
name
exit
name
exit
name
self.update_case_images value
self.case_images
self.case_images.first
self.case_images.first.image
exit
name
exit
name
exit
name
self.update_case_images value
self.case_images.first.image
exit
self.data['fields'].select{|f| f['id'] == field.id.to_s}.try(:first)
exit
kase
exit
field
field.class
exit
field
exit
field
exit
@kase.valid?
@kase.errors?
@kase.errors
exit
Hash(self.data)['fields']
exit
self.dat
self.data
exit
self.data
next
nex
next
exit
next
data_field
next
presence
custom_validations(field.title, field.field_type, value, minimum, maximum, presence)
self.errors
exit
next
custom_validations(field.title, field.field_type, value, minimum, maximum, presence)
exit
next
kase
exit
parent.parent_step
parent.step
parent.steps
exit
kase
kase.versions
kase.version
kase.initial_flow
kase.initial_flow.versions
kase.initial_flow.title
kase.initial_flow.title = 'xuxa'
kase.initial_flow.save
kase.initial_flow.errors?
kase.initial_flow.errors
kase.initial_flow.updated_by = User.last
kase.initial_flow.save
kase.initial_flow.reload
kase.initial_flow.reload.versions
kase.initial_flow.reload.cases
kase.initial_flow.reload
Flow.first
x=Flow.first.update_attributes title: 'teta'
x.reload
x
Flow.first.versions
x=Flow.first.update_attributes title: 'teta'
exit
s.initial_flow
s.initial_flow.present?
initial_flow
self.initial_flow
s.cases
s.cases.present?
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
Flow.first
Flow.first.steps.first
Flow.first.steps.first.inactive!
self.flow
self.flow.get_initial_flow
self.flow.get_initial_flow.cases
self.flow.get_initial_flow.cases.any?
exit
Flow.first.steps.first.inactive!
exit
Flow.first.versions
Flow.first.steps
Flow.first.steps.first
Flow.first.steps.unscoped.first
Flow.first.steps.unscoped.first.versions
Flow.first.steps.unscoped.first.update! active: true
Step.first
Step.first.versions
PaperTrail.enabled=true
Step.first.versions
Step.first.inactive!
exit
PaperTrail.enabled
PaperTrail.enabled=true
Step.first.inactive!
exit
Flow.first.steps.first
Flow.first.steps.first.versions
Flow.first.steps.first.inactive!
exit
PaperTrail.enabled = true
Flow.first
Field.all
Step.last.fields
Step.first.fields
Step.all
Step.first
Field.first
Field.first.step
Field.first.
exit
PaperTrail.enabled = true
Flow.first
f=Flow.first
f.title='xuxa'
f.save
f.updated_by=User.last
f.save
Flow.first
exit
PaperTrail.enabled = true
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
self.last_version.present?
exit
PaperTrail.enabled = true
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
self.last_version.present? 
self.verions.present?
exit
PaperTrail.enabled = true
f.title='xuxa'
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
self.last_version.present? 
self.versions.present?
exit
PaperTrail.enabled = true
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
exit
PaperTrail.enabled = true
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
self.versions.present?
last_version_id
self.versions.last.id
self.versions.present? and last_version_id != self.versions.last.id
exit
self.last_version == self.versions.size
self.last_
self.last_version
self.versions.size
next
exit
PaperTrail.enabled = true
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
self.last_version_changed? or self.last_version_id_changed?
next
self.last_version
exit
self.versions
return
Flow.first.versions
f=Flow.first
f.update! title:'teta'
next
self.last_version
self.last_version_changed?
next
self.last_version_changed?
next
parent.steps
PaperTrail.enabled = true
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
exit
self.versions
return
PaperTrail.enabled = true
f=Flow.first
f.title='xuxa'
f.updated_by=User.last
f.save
exit
self.versions
exit
Flow.first.versions
f=Flow.first
f.title='teta'
f.save!
exit
self.versions
return
next
exit
self.versions
self.versions.blank?
exit
next
exit
self.versions
exit
self.last_version
self.last_version_id
self.last_version_changed?
self.last_version_id_changed?
self
self.changed?
exit
return
exit
self.versions
exit
self.last_version_changed?
exit
self.last_version_id
self.versions.last.id
exit
self.last_version_changed?
self.last_version
exit
return
self.last_version_changed?
exit
self.last_version_changed?
self.last_version
self.last_version_id_changed?
self.versions.last.id
self.last_version_id
self.verions
self.versions
exit
self.last_version_changed? or self.last_version_id_changed?
self.versions
exit
self.last_version_id == self.versions.last.id
self.last_version_id
self.versions
exit
return
self.last_version_changed? 
exit
self
self.versions.last.id
next
exit
self.last_version_changed? 
self.last_version_id_changed? 
self.last_version_change
return
self.last_version_changed? 
next
exit
next
exit
return
self.last_version_changed? 
self.last_version_id_changed?
next
self.last_version
self.last_version + 1
exit
self
self.last_version_changed?
self.reload.last_version_changed?
reload!
return
exit
self.last_version_changed?
self.last_version_id_changed?
exit
self.last_version_id == self.versions.last.id
exit
kase
kase.errors
exit
step.cases
step
step.cases
exit
self.changes
self.action
self.action_name
self.persisted?
self.new_record?
reload!
exit
@get_initial_flow
next
∫]
@get_initial_flow.try(:verify_if_need_create_version?)
exit
get_initial_flow
@get_initial_flow
get_initial_flow.try(:verify_if_need_create_version?)
Field::Entity Field.last
Field::Entity.represent Field.last
(Field::Entity.represent Field.last).to_json
Field.last.versions
reload!
exit
get_initial_flow.try(:verify_if_need_create_version?)
Case.all
exit
self.versions.blank?
exit
get_initial_flow.try(:bump_version_cascade!)
exit
get_initial_flow.try(:verify_if_need_create_version?)
exit
get_initial_flow.try(:verify_if_need_create_version?)
self.persisted?
self.changes.keys.select{|key| KEYS_TO_CREATE_VERSION.include? key }
exit
self.last_version_changed?
self.last_version_id_changed?
self.last_version
exit
get_initial_flow.try(:verify_if_need_create_version?)
exit
self.last_version_changed? or self.last_version_id_changed?
exit
self.reload.versions.blank?
self.reload.last_version_id
self.reload.versions.last.id
self.versions.last.id
exit
get_initial_flow.try(:verify_if_need_create_version?)
self.changes.keys.select{|key| KEYS_TO_CREATE_VERSION.include? key }
exit
self.reload.versions.blank? 
self.reload.last_version_id == self.reload.versions.last.id
exit
verify_if_need_create_version?
get_initial_item
self.get_initial_item
get_initial_flow
get_initial_flow.verify_if_need_create_version?
get_initial>flow
get_initial_flow
get_initial_flow.versions
get_initial_flow.cases
get_initial_flow.reload.cases
Case.all
exit
verify_if_need_create_version?
exit
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
verify_if_need_create_version?
elem
next
elem != self
next
verify_if_need_create_version?
next
elem != self
next
exit
next
self.changes ? 1 : 2
self.changes
self.changes.present?
exit
self.changes.present?
exit
self.changes
exit
elem != self
exit
self.changes
exit
self.changes
exit
elem
next
self.resolution_states
next
elem
next
elem
next
exit
self.changes
self.reload.changes
self.reload.versions
exit
self.reload.versions
exit
self.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
next
exit
next
exit
self.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
elem
elem.versions
next
exit
self.changes
self.reload.versions
self.reload.last_version_id
exit
self.changes
exit
self.changes.present? and not self.last_version_id_changed?
exit
sel.changs
self.changs
self.changes
exit
self.changes
exit
self.changes
self.changes.present? and not self.last_version_id_changed?
exit
next
exit
self.reload.versions.blank? or self.reload.last_version_id == self.reload.versions.last.id
exit
self.changes.present? and not self.last_version_id_changed?
exit
self.changes
self.versions
exit
self.resolution_states
self.steps
next
exit
elem
exit
elem
exit
elem
next
self.resolution_states
next
exit
next
e
exit
elem.user
next
user
exit
Case.all
exit
Case.all
exit
Case.all
exit
return
self.step_type
next
Case.all
exit
Case.all
exit
next
self.changes.present? and not self.last_version_id_changed?
return
next
self.child_flow
elem
retun
return
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
next
exit
next
self.changes.present? and not self.last_version_id_changed? and not self.last_version_changed?
exit
self.changes.present? and not self.last_version_id_changed? and not self.last_version_changed?
exit
self.changes.present? and not self.last_version_id_changed? and not self.last_version_changed?
exit
Case.all
self.changes
self.changes.keys == ['last_version', 'updated_at'] 
self.changes.keys == ['last_version', 'updated_at', 'active'] 
self.changes.keys == ['active', 'last_version', 'updated_at'] 
self.changes.present? and not self.changes.keys == ['last_version', 'updated_at'] and not self.changes.keys == ['last_version_id', 'updated_at']
exit
next
self.changes.present? and not self.changes.keys == ['last_version', 'updated_at'] and not self.changes.keys == ['last_version_id', 'updated_at']
self.changes
exit
self.changes
self.changes.present? and not self.changes.keys == ['last_version', 'updated_at'] and not self.changes.keys == ['last_version_id', 'updated_at']
exit
self.changes
exit
self.step_type
next
self.child_flow
next
exit
next
exit
self.changes
exit
self.changes
exit
self.changes
elem
exit
elem
exit
elem
exit
elem
exit
elem
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
elem
need_create_version_by_keys?
get_initial_flow
get_initial_flow.verify_if_need_create_version?
self.persisted?
self.changes
exit
Case.all
get_initial_flow
get_initial_flow.versions.present?
get_initial_flow.cases
exit
get_initial_flow.versions.present? or get_initial_flow.cases.present?
exit
elelm
elem
need_create_version_by_keys?
next
get_initial_flow.try(:verify_if_need_create_version?)
exit
get_initial_flow.versions.present? or get_initial_flow.cases.present?
exit
need_create_version_by_keys?
self.persisted? and self.changes.present?
get_initial_flow.try(:verify_if_need_create_version?)
exit
whereami
next
exit
need_create_version_by_keys?
exit
self.changes
exit
whereami
exit
elem
exit
self.changes
exit
elem
exit
elelm
elem
self.changes
self.reload.versions
exit
self.reload.versions
exit
continue
continue!
help
exit-all
get_initial_flow.versions.present? or get_initial_flow.cases.present?
exit
next
get_initial_flow.try(:verify_if_need_create_version?)
exit
self.persisted? and self.changes.present?
exit
self.changes
exit
next
eit
exit
elem
elem.changes
next
exit
self.changes
exit
next
exit
elem.changes
next
exit
self.changes
exit
elem.changes
next
self.changes
exit
Flow.first.versions
Flow.first.steps.triggers.first.versions
Flow.first.steps.first.triggers.first.versions
Flow.first.steps.first.triggers
exit
Flow.first.steps.first.versions
Flow.first.steps.first.fields
Flow.first.steps.first.child_flow
Flow.first.steps.first.child_flow.versions
Flow.first.steps.first.child_flow.steps.first
Flow.first.steps.first.child_flow.steps.first.versions
exit
Flow.first.versions
Flow.first.resolution_states.first.versions
Flow.first.steps.first.versions
Flow.first.steps.first.child_flow.versions
Flow.first.steps.first.child_flow.steps.first.versions
Flow.first.steps.first.child_flow.steps.first.fields.first.versions
Flow.first.steps.first.child_flow.steps.first.fields.last.versions
Flow.first.steps.first.child_flow.steps.first.fields.sum{|f| f.versions.count }
exit
get_initial_flow.try(:verify_if_need_create_version?)
Case.all
exit
Case.all
exit
Case.all
exit
Case.all
exit
get_initial_flow.try(:verify_if_need_create_version?)
Case.all
exit
Case.all
exit
Case.all
get_initial_flow.try(:verify_if_need_create_version?)
exit
self
self.change
self.changes
self.persisted?
get_initial_flow.try(:verify_if_need_create_version?)
exit
get_initial_flow.try(:verify_if_need_create_version?)
exit
Case.all
self.new_record?
need_create_version_by_keys?
get_initial_flow.try(:last_version)
next
status
next
Case.all
exit
Case.all
exit
elem
Flow.first.versions
exit
Flow.first.versions
elem
exit
elem
exit
elem
exit
self
exit
self.
end
self
exit
self
exit
self
exit
sef
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
exit
self
self.new_record?
self.status
exit
self
self.status
exit
self
self.status
self.resolution_states.find_by(default: true).blank?
next
status
status!=self.status
next
self
exit
self.user
exit
Case.first
Case.first.date
Case.first.data
Flow.first
Flow.first.steps.first
Flow.first.steps.first.chld_flow
Flow.first.steps.first.child_flow
Flow.first.steps.first.flow
Flow.first.steps.first.child_flow
Flow.first.steps.first.child_flow.steps.first
Flow.first.steps.first.child_flow.steps.first.fields
exit
Field.all
Field.all.last.versions
Field.last.versions
Field.first.versions
Field.first.step
Field.first.step.versions
Field.first.step.flow
Field.first.step.flow.versions
Field.first.step.flow.resolution_states
Field.first.step.flow.resolution_states.first
Field.first.step.flow.resolution_states.first.versions
Flow.first
Flow.first.versions
Flow.last.versions
Flow.first.steps.first
Flow.first.steps.first.versions
Flow.first.steps.first.child_flow
Flow.first.steps.first.child_flow_id
Flow.first.steps.first.child_flow_version
Flow.first.steps.first.child_flow_id.present?
exit
step.cases.create!(parameters)
exit
step.cases.create!(parameters)
exit
step.triggers
next
compare?
exit
next
exit
condition
fields
whereami
next
exit
next
value
next
exit
next
exit
xit
exit
next
exit
next
exit
compare?(condition, kase.data['fields'])
exit
cond_values.first == value
cond_values
condition.values
condition.values.map { |v| convert_data(field.field_type, v) }
field
next
condition.values.map { |v| convert_data(field.field_type, v) }
next
exit
xit
exit
kase.data
kase.data.merge('xxx' => 'yyy') 
Case.all
Case.where('data IS NOT NULL')
Case.where('data IS NOT NULL').to_sql
Case.where('data -> fields IS NOT NULL').to_sql
Case.where('data -> fields IS NOT NULL')
Case.where('data -> fields IS NOT NULL').first
Case.where('data IS NOT NULL').to_sql
Case.where('data IS NOT NULL')
Case.where('data IS NOT NULL').first
Case.all
exit
Case.where('data -> fields != NULL')
Case.where('data -> fields != NULL').first
Case.where('data  NULL').first
Case.where('data != NULL').first
Case.where('data IS NOT NULL').first
Case.all
exit
@kase.valid?
@kase.errors
exit
trigger.valid?
step
Step.find(safe_params[:step_id]).triggers.create!(parameters.merge(user: current_user))
exit
Step.find(safe_params[:step_id]).triggers.create!(parameters.merge(user: current_user))
exit
Step.find(safe_params[:step_id]).triggers.create!(parameters.merge(user: current_user))
exit
flow.cases.create!(parameters)
next
safe_params.permit(fields: [:id, :value]).merge(step: step, step_version: step.last_version)
next
flow.cases.create!(parameters)
exit
next
kase.log!('create_case')
next
Case::Entity.represent(kase.reload)
exit
next
self.data
self
self.data = {'fields'=>[]}
exit
next
case_step_params
case_steps_params
safe_params.permit(fields: [:id, :value])
exit
self.data
self.step
self.step.fields
next
f=flow.cases.new(parameters)
f.valid?
f=flow.cases.new(parameters)
f.valid?
exit
params
next
exit
next
f=flow.cases.new({created_by: current_user}.merge(case_steps_attributes: [case_step_params]))
f.valid?
field_data
next
exit
case_step_params
exit
safe_params.slice(:data).merge(step: step, step_version: step.last_version)
{1=>2}.to_json
exit
next
net
next
flow.cases.create!({created_by: current_user}.merge(case_steps_attributes: [case_step_params]))
'case_step_data'.pluralize'
'
'case_step'.pluralize
'case_step_data'.pluralize
exit
next
case_step_params
f=flow.cases.create!({created_by: current_user})
f.case_steps
s=f.case_steps.create case_step_params
case_step_params.delete(:case_step_data_attributes)
case_step_params.reject(:case_step_data_attributes)
case_step_params.except(:case_step_data_attributes)
s=f.case_steps.create case_step_params.except(:case_step_data_attributes)
s.case_step_datas
s.case_step_data
s
name
exit
f=flow.cases.create!({created_by: current_user})
next
s=f.case_steps.create case_step_params.except(:case_step_data_attributes)
s=Case.first.case_steps.create case_step_params.except(:case_step_data_attributes)
s
next
e
exit
next
f=flow.cases.create!({created_by: current_user})
f
kase=f
case_step=kase.case_steps.create case_step_params.except(:case_step_data_attributes)
case_step.case_step_data
case_step.association
case_step.case_step_data
case_step.case_step_datas
exit
net
next
kase=flow.cases.create!({created_by: current_user})
case_step=kase.case_steps.create case_step_params.except(:case_step_data_attributes)
return
case_step
case_step.case_step_data
case_step.case_step_datas
case_step.case_step_data
exit
next
kase=flow.cases.create!({created_by: current_user})
case_step=kase.case_steps.create case_step_params
exit
next
kase=flow.cases.create!({created_by: current_user})
case_step=kase.case_steps.create case_step_params
safe_params[:fields]
safe_params[:fields].map {|x| x}
safe_params[:fields].map {|x| puts x }
safe_params[:fields].map {|x,y| puts x }
safe_params[:fields].map {|x,y| puts y }
safe_params[:fields].first
safe_params[:fields].map {|k,v| puts k }
safe_params[:fields].map {|k,v| puts v }
safe_params[:fields].map {|field| puts e }
exit
next
fields
exit
next
kase=flow.cases.create!({created_by: current_user})
case_step=kase.case_steps.create case_step_params
return
exit
next
field_data
exit
field_data
field_data.first
field_data.first.field
field_data.find_by(field_id: 1
)
field_data.find_by(field_id: 1)
field_data.select(field_id: 1)
field_data.select{|f| f.field_id== 1}
field_data.select{|f| f.field_id== 1}e
exit
next
exit
value
exit
value
exit
value
eit
exit
value
exit
value
exit
next
exit
value
exit
value
exit
value
next
elem.update_case_step_data_images eval(data_value)
exit
elem.update_case_step_data_attachments eval(data_value)
eval(data_value)
eval(data_value).first
exit
next
convert_field_data(data_value).map{|d| d['content']}
exit
value
whereami
next
convert_field_data(data_value).map{|d| d['content']}
exit
names
valid_extension_by_filter?(names, field.filter)
field.filter
exit
field.filter
exit
field.filter
exit
field.filter
names
valid_extension_by_filter?(names, field.filter)
exit
kase
kase.case_steps
kase.case_steps.first
kase.case_steps.first.case_step_data_fields
kase.case_steps.first.case_step_data_fields.last
kase.case_steps.first.case_step_data_fields.last.case_step_data_images
kase.case_steps.first.case_step_data_fields.last.case_step_data_attachments
kase.case_steps.first.case_step_data_fields.last.case_step_data_attachments.file_name
kase.case_steps.first.case_step_data_fields.forth
kase.case_steps.first.case_step_data_fields.fourth
kase.case_steps.first.case_step_data_fields.fourth.case_step_data_images
kase.case_steps.first.case_step_data_fields.fourth.case_step_data_images.mpa(&:file_name)
kase.case_steps.first.case_step_data_fields.fourth.case_step_data_images.map(&:file_name)
kase.case_steps.first.case_step_data_fields.fourth.case_step_data_images.map(&:url)
kase.case_steps.first.case_step_data_fields.fourth.case_step_data_images.map(&:images)
kase.case_steps.first.case_step_data_fields.fourth.case_step_data_images.map(&:image)
exit
flow
flow.steps
flow.steps.first
flow.steps.first.child_flow
flow.steps.first.child_flow.steps
flow.steps.first.child_flow.steps.first
flow.steps.first.child_flow.steps.first.fields
flow.reload
flow.steps.first.child_flow.steps.first.fields.first
exit
Flow.find_by(id: safe_params[:initial_flow_id], initial: true)
next
exit
next
value
field
cond_values
condition.values
next
cond_values.first == value
exit
kase.case_steps.first
kase.case_steps.first.trigger_ids
whereami
next
Step.last.versions
Step.all
Step.first
Step.first.versions
Step.all
Step.first
Step.last
Step.all
Step.all[1]
Step.all[1].versions
s=Step.all[1]
s.versions.first.reify
s=s.versions.first.reify
s.save
Step.all[1]
Step.all[1].versions
Step.all[1].versions[1]
Step.all[1].versions[1].reify
Step.all[1].versions[0].reify
Step.all[1].versions[1].reify
s=Step.all[1]
s=s.versions[1].reify
s.save
Step.all[1]
Step.all[1].versions
Step.all
Step.first
Step.last
Step.all
Step.all[1].versions
Step.all[1].versions.uniq
Step.all[1].versions.map(&:reify)
Step.all[1].versions.map(&:reify).uniq
Step.all[1].versions.map(&:reify)
Step.all[1].versions.map(&:reify).uniq
Step.all[1].versions.map(&:reify)
Step.all[1].versions.map{|v| v.reify(has_many: true) }
Step.all[1].versions.map{|v| v.reify(has_many: true) }.first
Step.all[1].versions.map{|v| v.reify(has_many: true) }.first.fields
exit
next
exit
other_flow
flow.reload
flow.reload.steps.first.triggers
exit
step
step.triggers
next
step.triggers.active
step
next
Flow.first.total_cases
self.cases.count
self.steps.find_by(step_type: 'form').sum{|s| s.case_steps.count }
self.steps.find_by(step_type: 'form').count{|s| s.case_steps.count }
self.steps.find_by(step_type: 'form').map{|s| s.case_steps.count }
self.steps.find_by(step_type: 'form')
exit
Flow.last.total_cases
self.steps.find_by(step_type: 'form')
self.steps.find_by(step_type: 'form').sum{|s| s.case_steps.count}
self.steps.find_by(step_type: 'form').map{|s| s.case_steps.count}
self.steps.where(step_type: 'form').map{|s| s.case_steps.count}
self.steps.where(step_type: 'form').sum{|s| s.case_steps.count }
self.steps.where(step_type: 'form')
self.steps.where(step_type: 'form').select(:case)
self.steps.where(step_type: 'form').select(:case).distinct(:case)
self.steps.where(step_type: 'form').select(:case).distinct(:case).case
self.steps.where(step_type: 'form').select(:case_id).distinct
self.steps.where(step_type: 'form').select(:case_id).distinct.case_id
self.steps.where(step_type: 'form').select(:step_type).distinct
self.steps.where(step_type: 'form').select(:step_type).distinct.first
self.steps.where(step_type: 'form').select(:step_type).distinct.to_sql
self.steps.where(step_type: 'form')
exit
Flow.first.total_cases
next
cases_count
steps_form
exit
Flow.second.total_cases
Flow.all.second.total_cases
next
cases_count
next
Flow.first.total_cases
next
cases_count
next
steps_form
next
cases_count + steps_count
exit
whereami
Flow.all.second.total_cases
next
cases_count
steps_form
steps_form.map {|s| s.cases_steps.to_a.map {|c| c.case.id } }
steps_form.map {|s| s.case_steps.to_a.map {|c| c.case.id } }
steps_form.map {|s| s.case_steps.to_a.map {|c| c.case.id } }.flatten
steps_form.map {|s| s.case_steps.to_a.map {|c| c.case.id } }.flatten.uniq
steps_form.map {|s| s.case_steps.to_a.map {|c| c.case.id } }.flatten.uniq.count
next
cases_count
steps_count
exit
Flow.first.total_cases
next
Flow.first.total_cases
next
self.cases.map(&:id)
self.cases.select(:id)
x=self.cases.select(:id)
next
Flow.first.total_cases
next
cases_id
step_cases_id
x
x<<[2]
x<<[1]
x.flatten
x.flatten.uniq
exit
Flow.all.first.total_cases
Flow.all.second.total_cases
Flow.all.map(&:total_cases)
exit
Flow.first.total_cases
self.cases.where()
exit
Flow.first.total_cases
next
Flow.first.total_cases
next
Flow.first.total_cases
steps.first.versions
steps.first.versions[1]
steps.first.versions[1].reify
steps.first.versions
next
Flow.first.total_cases
exit
Flow.last.total_cases
last_version
next
Flow.last.versions
Flow.first.versions
exit
PaperTrail::Version
PaperTrail::Version.all
exit
Case::Entity.represent(kase)
{ message: I18n.t(:case_created), case: Case::Entity.represent(kase), trigger_type: trigger_result[:type], trigger_values: trigger_result[:value] }
trigger_result
step_triggers
step.triggers
[][]
next
{ message: I18n.t(:case_created), case: Case::Entity.represent(kase), trigger_type: trigger_result[:type], trigger_values: trigger_result[:value] }
exit
{ message: I18n.t(:case_created), case: Case::Entity.represent(kase), trigger_type: trigger_result[:type], trigger_values: trigger_result[:value] }
exit
be_an_entity_of(kase)
kase
expect(response.body).to be_an_entity_of(kase) 
exit
object
object.case_steps.first
object.case_steps.first.case_step_data_fields
whereami
parsed_body[key]
exit
kase.initial_flow.next_step
kase.initial_flow.steps
kase.initial_flow.next_step(kase.case_steps.first.step)
exit
options
last_version
versions
versions.count
exit
versions.count
last_version
exit
kase.initial_flow.all_steps_of_case
step
step.step_type
exit
kase.initial_flowcase
kase.initial_flow.all_steps_of_case
step.step_type
exit
step.step_type
exit
kase.initial_flow.all_steps_of_case
step.step_type
exit
body
key
next
exit
Flow.last.steps.first
exit
next
kase.disabled_steps
exit
next
trigger_values
exit
parsed_body['case']['disabled_steps']
kase.reload.disabled_steps
exit
EXIT
next
exit
parsed_body['case']['disabled_steps']
exit
parsed_body['case']['disabled_steps']
exit
next
kase.save!
next
step.triggers
exit
kase.disabled_steps.include? safe_params[:step_id]
exit
next
case_step
next
fields
case_step.update!({updated_by: current_user}.merge(case_step_data_fields_attributes: fields))
next
e
exit
next
f
next
f
next
;w
kase
next
kase
kase.case_steps
kase.case_steps.case_steps_data_fields
kase.case_steps.first.case_steps_data_fields
kase.case_steps.first.case_step_data_fields
next
kase.case_steps.first.case_step_data_fields
xit
exit
kase.disabled_steps.include? safe_params[:step_id]
error!(I18n.t(:step_is_disabled), 400)
exit
kase.status
exit
safe_params
safe_params.slice(:display_type)
Case::Entity.represent(kase, safe_params.slice(:display_type)).to_json
exit
safe_params.slice(:display_type)
kase.disabled_steps
Flow.last.steps.first.id
exit
Case::Entity.represent(kase, safe_params.slice(:display_type))
Case::Entity.represent(kase, safe_params.slice(:display_type)).to_json
Flow.last.steps.first.id
exit
parsed_body['case']['disabled_steps']
[Flow.last.steps.first.id]
exit
body
exit
current_user.id
current_user.groups
current_user.groups.map(&:id)
current_step.responsible_user_ids.include?(current_user.id)
current_step.responsible_user_group_ids.include?(current_user.groups.map(&:id))
next
exit
run_triggers(step.triggers, kase) 
next
trigger_description: trigger_result[:description] 
{trigger_description: trigger_result[:description] }
exit
kase.next_step
exit
next
case_params
next
exit
Step.active.find(safe_params[:step_id])
next
Flow.find_by(id: safe_params[:initial_flow_id], initial: true)
next
exit
next
before_update
next
case_step
next
log_params
safe_params[:responsible_user_id]
safe_params.has_key?(:responsible_user_id)
exit
next
log_params
next
case_step.case.cases_log_entries
exit
kase
exit
next
kase
kase.to_h
kase.to_hash
kase.to_enum
kase
kase.case_steps
kase.case_steps = []
kase.case_steps
exit
case_steps
exit
next
exit
next
exit
kases.map(&:case_steps)
kases = kases.select { |c| c.case_steps = c.case_steps.where(step_id: [1], created_by_id: 2); c.case_steps.any? }
kases.first.case_steps
exit
case_steps
exit
nexy
next
exit
next
kase.case_steps.where(step_id: all_steps[step_index+1..-1])
exit
kase.case_steps.where(step_id: all_steps[step_index+1..-1])
exit
kase.case_steps.where(step_id: all_steps[step_index+1..-1])
exit
case_step.new_record?
next
run_triggers(step, kase) 
next
{ message: message, case: Case::Entity.represent(kase, display_type: 'full'), trigger_type: trigger_result[:type], trigger_values: trigger_result[:value], trigger_description: trigger_result[:description] }
exit
next
exit
kase.case_steps
next
kase.case_steps
kase.reload.case_steps
exit
step.triggers
exit
exi
exit
compare_trigger_condition?(condition, case_step.case_step_data_fields)
next
exit
flow.steps.first.fields.first
flow.steps.first.fields
exit
compare_trigger_condition?(condition, case_step.case_step_data_fields)
step.triggers
step.triggers.last.trigger_conditions
step.fields
b]
compare_trigger_condition?(condition, case_step.case_step_data_fields)
condition
case_step.case_step_data_fields)
case_step.case_step_data_fields
exit
fields.first.step.id
exit
step.fields
fields
exit
compare_trigger_condition?(condition, case_step.case_step_data_fields)
exit
compare_trigger_condition?(condition, case_step.case_step_data_fields)
exit
kase.case_steps
step
kase.case_steps.where(step_id: all_steps[step_index+1..-1])
next
kase.disabled_steps
Trigger.all
safe_params[:step_id]
safe_params[:fields]
exit
fields
step.triggers.last.trigger_conditions
exit
next
exit
next
kase.old_status
next
self.steps.map(&:id)
exit
current_user
parameters
exit
resolution.flow.resolution_states.create(title: 'teste', default: true)
exit
resolution.flow.resolution_states.create(title: 'teste', default: true)
exit
whereami
resolution.update!(parameters)
nex
next
resolution_default
resolution_default.present?
self.flow.resolution_states.where(default: true)
exit
Step.active.find(safe_params[:step_id])
next
Flow.find_by(id: safe_params[:initial_flow_id], initial: true)
exit
next
message: I18n.t(:case_updated)
I18n.t(:case_updated)
Case::Entity.represent(new_kase, display_type: safe_params[:display_type])
Case::Entity.represent(new_kase, display_type: safe_params[:display_type]).to_json
Case::Entity.represent(new_kase).to_json
exit
exitCase::Entity.represent(new_kase, display_type: safe_params[:display_type]).to_json
Case::Entity.represent(new_kase, display_type: safe_params[:display_type]).to_json
exit
Case::Entity.represent(new_kase, display_type: safe_params[:display_type]).to_json
exit
Case::Entity.represent(new_kase, display_type: safe_params[:display_type]).to_json
exit\
end
exit
Case::Entity.represent(new_kase, display_type: safe_params[:display_type]).to_json
exit
Case::Entity.represent(new_kase, display_type: safe_params[:display_type]).to_json
exit
exiut
exit
Category
Intentory
Intantory
Inventaroy
Inventary
Inventory
Inventory::Category
Inventory::Category.all
x=create(:inventory_category)
x.flatten.uniq
x=create(:inventory_item)
x.inventory_cateogry
x.inventory_category
x
exit
self.flow.reload
user.id
exit
self.flow.reload
exit
self.flow.reload
user
exit
user
exit
next
exit
self.errors.add(:field_type, I18n.t(:need_set_category_inventory_before))
exit
next
cateogry
category
exit
flow.steps.first.fields.create title: 'inventory_items', field_type: 'category_inventory', category_inventory_id: inventory_item.category.id, multiple: true
flow.steps.first.fields.create title: 'size_of_tree',    field_type: 'category_inventory_field', origin_field_id: inventory_item.category.fields.first.id
next
exit
data_value
elem.field.category_inventory
elem.field.category_inventory.items
elem.field.category_inventory.items.find(data_value)
elem.field.category_inventory.items.find(data_value).id
data_value=elem.field.category_inventory.items.find(data_value).id
exi
exit
self.case_steps
self
self.case_step_data_fields
self.case_step_data_fields.where(field_id: 1)
self.case_step_data_fields.select{|f| f.field_type == 'category_inventory_field' }
self.case_step_data_fields.map{|f| f.field_type == 'category_inventory_field' }
self.case_step_data_fields.select{|f| f.field.field_type == 'category_inventory_field' }
self.case_step_data_fields.select{|f| f.field.field_type == 'category_inventory' }
self.case_step_data_fields.select{|f| f.field.field_type == 'category_inventory' }exit
exit
next
item
inventory_field
item.data
item.data.find_by(inventory_field)
item.data.find(inventory_field)
item.data.find(inventory_field.id)
inventory_field
item.data
inventory_field.id
item.data.find
item.data.find 15
item.data.find_by id: 15
item.data.select { |d| d.id == 15 }
item.data.select { |d| d.id == 15 }.first
item.data.select { |d| d.id == 15 }.first.content = value
item.data
exit
self.errors.blank? and @items_with_update.present?
@items_with_update
@items_with_update.firs
@items_with_update.first
@items_with_update.first.save
@items_with_update.first.reload
@items_with_update.first.reload.data
exit
invenory.content
invetory.content
inventory
inventory.content
inventory.reload.content
exit
inventory.content
inventory.reload.content
exit
Case.all
Case.first
Case.first.case_steps
Case.first.case_steps.first
Case.first.case_steps.first.case_step_data_fields
exit
next
kase
Case::Entity.represent(kase, display_type: 'full')
Case::Entity.represent(kase, display_type: 'full').to_json
exit
next
Case::Entity.represent(kase, display_type: 'full').to_json
exit
Inventory::Category
value
field
field.category_inventory
field.category_inventory.items
field.category_inventory.items.select(:id)
field.category_inventory.items.select(:id).include? 1
field.category_inventory.items.select(:id).map(&:id)
field.category_inventory.items.select(:id).map(&:id).include? value
value
field.category_inventory.items.select(:id).map(&:id) <=> value
value - field.category_inventory.items.select(:id).map(&:id)
[1] - [2]
[3] - [2]
[3] - [2, 3]
[3] - [1, 2, 3]
[3,1,4] - [1, 2, 3]
([3,1,4] - [1, 2, 3]).blank?
([3,1,4] - [1, 2, 3]).present?
([3,1] - [1, 2, 3]).present?
Report
Reposts
Reports
Reports::Category
Reports::Category.first
Reports::Category.first.items
Reports::Category.first
Reports::Category.first.icon
exit
inventory_item
inventory_item.data.find_by(inventory_field_id: inventory_field_id)
exit
item
value
exit
item
item.data.first
next
field
field_type
field_type.present?
next
item
next
item_field
item_field.content
value
exit
field_type
exit
next
item_field
exit
field_type
exit
next
item_field
exit
field_type
exit
next
item_field
value
exit
field_type
exit
next
value
item_field
exit
params[:attachment].permit(:nome, :data, :attachment_type_id, :descricao, palavras_chave: [])
params
exit
'xsxsx sx sx s'.split
exit
item_field
next
item_field
exit
next
item_field
valuye
value
exit
next
params[:attachment]
keys = ''
params[:attachment]
exit
@attachment.persisted?
@attachment.palavras_chave
exit
@attachment.palavras_chave
@attachment.palavras_chave.join
@attachment.palavras_chave.join(' ')
@attachment.palavras_chave.try(:join, ' ')
exit
params
exit
params
params[:attachment]
params[:attachment].permit(:document)
exit
next
exit
@attachment.valid?
@attachment.errors
exit
Attachment.all
exit
@attachment.document.url
exit
next
safe_params[:options]
next
parameters
exit
next
field
Field::Entity.represent(field)
Field::Entity
Field
Field::Entity
Field::EntityVersion
exit
Field::Entity.represent(field)
Field::EntityVersion
git st
exit
Field::Entity.represent(Step.find(safe_params[:step_id]).fields) 
Field::Entity.represent(Step.find(safe_params[:step_id]).fields).to_json
exit
with_subdomain(false)
agreement_user_plans_url(host: with_subdomain(false))
agreement_user_plans_url(host: 'xxx')
exit
agreement_user_plans_url(host: 'xxx')
agreement_user_plans_url(host: with_subdomain(false))
exit
parsed_body
exit
whereami
params
params[:action]
params[:action] == :edit
exit
f
f.options
f.options[:defaults]
f.options[:defaults][:error_html]
f.options[:defaults][:error_html][:class]
exit
error_class
exit
next
valid_attributes
att.data
att.data.to_s
att.document
att.document.file_name
att.document.filename
att.document
att.document.name
att.document.file_name
att.document
att.document.url
att.document.filename
att.document_file_name
valid_attributes[:document]
valid_attributes[:document].file_name
valid_attributes[:document].filename
valid_attributes[:document]
valid_attributes[:document].original_filename
exit
next
conditions
trigger.trigger_conditions.active
case_step.case_step_data_fields
exit
value
original_value
cond_values
field.field_type
exit
next
inventory_field.kind
exit
value
cond_values
exit
@items_with_update.first
@items_with_update
exit
@items_with_update
exit
@items_with_update
exit
@items_with_update
@items_with_update.first
@items_with_update.first.valid?
exit
@items_with_update.first.valid?
exit
kase.valid?
next
step.triggers
exit
kase.valid?
next
step.triggers
exit
kase.valid?
exit
kase.valid?
exit
@items_with_update.first.valid?
exit
kase.valid?
exit
@items_with_update.first.valid?
exit
kase.valid?
exit
@items_with_update.first.valid?
kase.valid?
exit
kase.valid?
exit
@items_with_update.first.valid?
exit
kase.valid?
exit
kase.valid?
exit
@items_with_update.first.valid?
exit
kase.valid?
exit
parsed_body
exit
Venture.all
LicenseType
LicenseType.create name: 'Tipo 1'
LicenseType.create name: 'Tipo 2'
exit
params
exit
params
exit
params
params[:id]
params[:id].constantize
"xxxx".constantize
"attachment".constantize
"attachments".constantize
"attachments".classify
"attachments".classify.constantize
exit
next
@license
exit
@origin
@origin.class
@origin.class.to_s
@origin.id
exit
f.origin
f.input :origin
exit
params
exit
next
type
id
exit
link_to
link_to {controller: 'attachments'}
link_to "xxx", controller: 'attachments'
exit
venture_license_attachments_url
root_url
exit
to_url
@attchment
@attachment
@attachments
@origin
@origin.to_path
@origin.to_url
path
request
request.env
request.env['PATH_INFO']
exit
request.path
request.fullpath
exit
link_to controller: :attachments
link_to '#', controller: :attachments
link_to '#', controller: :attachments, html_options: {}
link_to '#', controller: :attachments, html_options: {x: ''}
link_to '#', {controller: :attachments}, html_options: {x: ''}
link_to '#', {controller: :attachments}, class: ''
link_to {controller: :attachments}, {class: ''}, { 'x' }
link_to @attachments
link_to @attachment
link_to @attachmentexit
exit
@attachments
@attachment
params
exit
params
exit
license.id
exit
license.id
exit
next
@attachments
exit
attachments_path
new_attachments_path
AttachmentHelper
AttachmentsHelper
AttachmentsHelper.attachments_path
exit
Attachment.all
Attachment.all.map(&:origin_id)
Attachment.first
Attachment.first.delete
Attachment.all.map(&:origin_id)
exit
AttachmentType.last.delete
AttachmentSubType
AttachmentSubType.first
AttachmentSubType.first.update(attachment_type_id: 1)
AttachmentSubType.second.update(attachment_type_id: 1)
AttachmentSubType.all.second.update(attachment_type_id: 1)
AttachmentSubType.all.third.update(attachment_type_id: 2)
AttachmentSubType.all.last.update(attachment_type_id: 2)
exit
AttachmentType.all.to_json
AttachmentType.all.join(:attachment_sub_types).to_json
AttachmentType.all.join(:attachment_sub_types).to_sql
AttachmentType.where().join(:attachment_sub_types).to_sql
AttachmentType.where(id: 1).join(:attachment_sub_types).to_sql
AttachmentType.where(id: 1).join('attachment_sub_types').to_sql
AttachmentType.where(id: 1).join_dependency
AttachmentType.where(id: 1).join_associations
AttachmentType.where(include: :attachment_sub_types)
AttachmentType.all(include: :attachment_sub_types)
AttachmentType.all(include: :attachment_sub_types).to_json
AttachmentType.joins(:attachment_sub_types)
AttachmentType.joins(:attachment_sub_types).to_json
JSON.parse(AttachmentType.joins(:attachment_sub_types).to_json)
JSON.parse(AttachmentType.include(:attachment_sub_types).to_json)
JSON.parse(AttachmentType.include([:attachment_sub_types]).to_json)
AttachmentType.include([:attachment_sub_types])
exit
valid_params
next
item.data.first.contente
item.data.first.content
item.data.size
category.fields.size
next
e
next
e
exit
next
validate_permission!(:create, Field)
AttachmentType.all
AttachmentType.all(include: :attachment_sub_types)
AttachmentType.all(include: :attachment_sub_types).to_sql
AttachmentType.all(include: :attachment_sub_types).to_h
AttachmentType.all(include: :attachment_sub_types).to_yaml
AttachmentType.all(include: :attachment_sub_types).to_json
AttachmentType.all(include: :attachment_sub_types).select(:name).to_json
AttachmentType.select(:name).all(include: :attachment_sub_types).to_json
AttachmentType.select(:nome).all(include: :attachment_sub_types).to_json
AttachmentType.select(:id, :nome).all(include: :attachment_sub_types).to_json
AttachmentType.all.map{|a| {group: a, options: a.attachment_sub_types} }
AttachmentType.first.attachment_sub_types
AttachmentType.last.attachment_sub_types
AttachmentType.first.attachment_sub_types
x=AttachmentType.last.dub
x=AttachmentType.last
AttachmentType.create(nome: 'Sem Sub Tipo')
AttachmentType.all.map{|a| {group: a, options: a.attachment_sub_types} }
AttachmentType.all.map{|a| {group: a, options: (a.attachment_sub_types || a)} }
AttachmentType.all.map{|a| {group: a, options: (a.attachment_sub_types.all || a)} }
AttachmentType.all.map{|a| {group: a, options: (a.attachment_sub_types.any? ? a.attachment_sub_types : a)} }
AttachmentType.all.map{|a| {group: a, options: (a.attachment_sub_types.any? ? a.attachment_sub_types : [a])} }
AttachmentType.all.map{|a| {group: a, options: (a.attachment_sub_types.any? ? a.attachment_sub_types : a.to_a)} }
AttachmentType.all.map{|a| {group: a, options: (a.attachment_sub_types.any? ? a.attachment_sub_types : [a])} }
exit
validate_permission!(:create, Field)
exit
user_groups.with_permission(:manage_flows)
next
action
model
model.respond_to?(:table_name)
exit
response
response.body
response.status
response
exit
last_response
response
page
page.body
exit
page.body
next
exit
page
page.body
click_button 'Entrar'
page.body
email
password
fill_in 'user_email', with: email
fill_in 'user_password', with: 'changeme'
click_button 'Entrar'
page.body
visit '/'
page.body
exit
page.body
click_button 'Entrar'
page.body
exit
find('#attachment_types')
page.find('#attachment_types')
find("#attachment_types"_
find("#attachment_types")
page.body
exit
page.body
login_as user
page.body
exit
page.body
find("#attachment_types")
find("#attachment_types").text
find("#attachment_types tbody").
end
find("#attachment_types tbody")
find("#attachment_types tbody").text
find("#attachment_types tbody").exi
exit
expect(find('#attachment_types tbody')).to have_content 'X'
expect(find('#attachment_types tbody').text).to have_content 'X'
expect(find('#attachment_types tbody')).to have_content 'X'
expect(find('#attachment_types tbody').text).to eql 'x'
exit
page
page.body
find("#attachment_types tbody")
find("#attachment_types tbody").text
find("#attachment_types")
find("#attachment_types").text
exit
find("#attachment_types").text
exit
find("#attachment_types").text
exit
find("#attachment_types").text
exit
AttachmentType.all
next
visit attachment_types_path
page.body
exit
AttachmentType.all
exit
AttachmentType.all
page.body
exit
AttachmentType.all
page.body
find("#attachment_types").text
find("#attachment_types")
xit
exit
page.body
exit
visit attachment_types_path, format: :html
visit attachment_types_path(format: :html)
page.body
visit attachment_types_path
page.body
exit
page.body
exit
page.body
exit
page.body
exit
page.body
puts page.body
exit
page.body
puts page.body
exit
AttachmentType.all
exi
exit
AttachmentType.all
exit
@ttachment_types
@attachment_types
AttachmentType.all
exit
AttachmentType.all
exit
AttachmentType.all
create(0
)
create()
FactoryGirl.create(:attachment_type)
@attachment_types = AttachmentType.all
exit
@attachment_types
exit
@attachment_types
AttachmentType.all
exit
AttachmentType.all
type1
AttachmentType.all
exit
AttachmentType.all
type1
exit
AttachmentType.all
exit
AttachmentType.all
exit
AttachmentType.all
type1
puts page.body
exit
AttachmentType.all
exit
AttachmentType.all
puts page.body
exit
AttachmentType.all
exit
AttachmentType.all
exit
AttachmentType.all
AttachmentType.reload.all
AttachmentType.all.reload
exit
@attachment_types
exit
@attachment_types
exit
@attachment_types
exit
AttachmentType.all.reload
AttachmentType.create! nome: 'yyy'
AttachmentType.all.reload
exit
create(:company)
Company.all
create(:company)
Company.all
exit
AttachmentType.all
AttachmentType.last
AttachmentType.last.update(nome: 'bbbb')
AttachmentType.all
AttachmentType.all.reload
AttachmentType.all
AttachmentType.all.reload
exit
AttachmentType.all.reload
exit
Case.not_inactive.find(safe_params[:id])
next
kase
validate_permission!(:show, kase)
kase
Group.included_in_permission?(user_groups, :flow_can_view_all_steps, kase.id)
Group.included_in_permission?(user_groups, :flow_can_view_all_steps, kase.initial_flow.id)
kase.initial_flow.id
exit
next
e
exit
User.all
exit
User.all
AttachmentType.all
exit
AttachmentType.all
User.all
exit
User.all
AttachmentType.all
exit
AttachmentType.all
User.all
exit
find('#attachment_types')
find('#attachment_types tbody').text
exit
find('#attachment_types tbody').text
find('#attachment_types tbody tr[0]').text
find('#attachment_types tbody tr')
find('#attachment_types tbody tr').first
find('#attachment_types tbody tr')
find('#attachment_types tbody tr').text
find('#attachment_types tbody tr td')
find('#attachment_types tbody tr').text
find('#attachment_types tbody tr').text.include?
find('#attachment_types tbody tr').text.include? type1.nome
find('#attachment_types tbody tr td')
find('//*[@id="venture_types"]/tbody/tr[1]/td[1]')
find('//*[@id="venture_types"]/tbody/tr[0]/td[0]')
find('//*[@id="attachment_types"]/tbody/tr[1]/td[1]')
find('//*[@id="attachmenttypes"]/tbody/tr[1]/td[1]')
puts page.body
exit
puts page.bodu
puts page.body
erxit
exit
puts page.body
exit
find('#attachment_types tbody tr')
exit
find('#attachment_type_nome')'
find('#attachment_type_nome')
find('#attachment_type_nome').text
find('#attachment_type_nome').val
find('#attachment_type_nome').value
expect(page).to have_selector '#attachment_type_nome', value: 'xx'
find_field('Nome')
find_field('#attachment_type_nome')
puts page.body
find_field('attachment_type_nome')
find('#attachment_type_nome')
find('#attachment_type_nome').disabled
find('#attachment_type_nome')['disabled']
find('#attachment_type_nome').value
find('#attachment_type_nome')
find('#attachment_type_nome').include? {'disabled' => 'true'}
find('#attachment_type_nome').include?({'disabled' => 'true'})
exit
Case.first
Flow.first.list_tree_steps
exit
Flow.first.list_tree_steps
exit
user_groups
exit
user_groups
exit
user_groups
Group.included_in_permission?(user_groups, :flow_can_view_all_steps, kase.initial_flow.id)
Group.first
Group.first.permissions
Group.first.permissions['flow_can_view_all_steps']
Group.first.permissions['flow_can_view_all_steps']e
exit
group
permission_name
id
exit
permission_name
id
group
group.send("#{permission_name.to_s}")
next
permission_array
id.to_s
exit
Group.included_in_permission?(user_groups, :flow_can_view_all_steps, kase.initial_flow.id)
user_groups
exit
next
permission_array
permission_nome
permission_name
id
groups.first.send("#{permission_name.to_s}")
exit
groups.first.send("#{permission_name.to_s}")
exit
groups.first.send("#{permission_name.to_s}")
id
next
permission_array
id.to_s
exit
next
permission_array
exit
permission_array
exit
permission_array
next
exit
next
exit
next
kase.disabled_steps.include? safe_params[:step_id]
exit
next
attachment_sub_types
attachment_sub_types.page(page)
attachment_sub_types.page(page).per_page(per_page)
next
exit
next
attachment_sub_types
attachment_sub_types.page(page).per_page(per_page)
next
exit
next
attachment_sub_types.page(page).per_page(per_page)
exit
next
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
next
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
exit
attachment_sub_types.page(page).per_page(per_page)
exit
set_attachment_type
attachment_sub_types = @attachment_type.sub_types.order("#{sort_column} #{sort_direction}")
attachment_sub_types = attachment_sub_types.page(page).per_page(per_page)
params[:sSearch].present?
attachment_sub_types
exit
validate_permission!(:create, step)
next
exit
next
permission_array
group.send("#{permission_name.to_s}")
groups.first.send("#{permission_name.to_s}")
exit
next
exit
next
exit
next
exit
params
next
exit
@environment_program
@environment_program.data_especifica
exit
@environment_program.data_especifica
@environment_program.data_especifica.nil?
@environment_program.data_especifica
exit
post :create, {:city => valid_attributes}, valid_session
response
response.body
exit
valid_attributes
City.new valid_attributes
exit
city_params
params
exit
next
actions[params[:action]] 
exit
params
model
controller
current_user
controller
controller_name
exit
group.send("#{permission_name.to_s}")
exit
next
group.send(permission_name.to_s)
exit
can_execute_step
exit
whereami
guide_esteps
guide_steps
step
next
guides_steps
guide_steps
x=step
guide_steps << nil
Guide::Step.all
exit
resource.valid?
resource.errors
exit
next
action
table
model
exit
next
exit
next
valid_params
valid_params[:step_id]
user.groups.first.permissions.merge(can_execute_step: [valid_params[:step_id]])
user.groups.first.update permissions: user.groups.first.permissions.merge(can_execute_step: [valid_params[:step_id]])
user.groups.first
user.groups.first.reload
exit
user.groups
exit
Case.all
safe_params[:id]
exit
kase
next
response.body
exit
Case.all
exit
@environment_program_type
params
environment_program_type_params
next
@environment_program_type
exit
taxon
taxon.ancestors
taxon.first
taxon
exit
Attachment.last
Attachment.first
Attachment.new.ancestors
Venture.all
Venture.first
Venture.first.ancestors
current_path
current_page
exit
request.full_path
request.fullpath
request.fullpath.split
request.fullpath.split('/')
request.fullpath.split('/').trim
request.fullpath.split('/')
"xxxx123".to_i
"123xxxx".to_i
controller_name
controller
request.fullpath.split('/')
request.fullpath.split('/')[0..-1]
request.fullpath.split('/')[0..-2]
request.fullpath.split('/')[0...-2]
request.fullpath.split('/')[0...-1]
request.fullpath.split('/').each_slice(2) { |x| puts x }
request.fullpath.split('/').each_slice(2) { |x| puts "#{x}----" }
request.fullpath.split('/')[1..-1].each_slice(2) { |x| puts "#{x}----" }
request.fullpath.split('/')[1..-1].each_slice(2) { |x,y| puts "#{x}----" }
request.fullpath.split('/')[1..-1].each_slice(2) { |x,y| puts "#{y}----" }
controller_name
exit
next
requesr.fullpath
exit
next
crumb
exit
control
controllers
resource_name
controllers[resource_name]
controllers[resource_name.to_sim]
resource_name.to_sym
controllers[resource_name.to_sym]
exit
next
exit
resource_name
resource_name.contantize
resource_name.camelize
resource_name.camelize.contantize
resource_name.singularize.constantize
resource_name.singularize.camelize.constantize
resource
Attachment
Attachment.find(1)
Attachment.find('1')
exit
name
object
object.nome
object.name
exit
name
exit
name
object
exit
t(:controller)
t(:controllers)
t(:controllers)['licenses']
t(:controllers.licenses)
t('controllers.licenses')
t('controllers.licensesx')
exit
controller_name
exit
params
next
exit
resource_name
resource_id
exit
resource_id
resource_name
exit
resource_name
resource_id
controller_name
next
exit
resource_name
resource_name == controller_name
exit
controller_name
controller_path
params
request.fullpath.split('/')[1...-1].join('/')
exit
ApplicationController.descendants
ApplicationController.descendants.first
ApplicationController.descendants.first.action_methods
Rails.application.eager_load!
Rails.application.routes
Rails.application.routes.map {|r| puts r}
Rails.application.routes.routes.map {|r| puts r}
Rails.application.routes.routes.map {|r| puts r.path}
Rails.application.routes.routes
Rails.application.routes.routes.first
Rails.application.routes.routes.first.name
Rails.application.routes.routes.first.path
Rails.application.routes.routes.first.path.spec.to_s
ApplicationController.subclasses
ApplicationController.subclasses.map{|c| puts c}
ApplicationController.subclasses.map{|c| puts "#{c}"}
ApplicationController.subclasses.map{|c| puts "#{c}"}; nil
ApplicationController.subclasses.map{|c| puts "#{c}"};
ApplicationController.subclasses.map{|c| puts "#{c.gsub('Controller', '')}"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.gsub('Controller', '')}"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.gsub('Controller', '').downcase}"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.gsub('Controller', '').downcase}: "};
exit
ApplicationController.subclasses.map{|c| puts "#{c.to_s.gsub('Controller', '').downcase}: "};
ApplicationController.subclasses
ApplicationController.subclasses.map{|c| puts "#{c.to_s.camelize.gsub('Controller', '').downcase}:"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscorize.gsub('Controller', '').downcase}:"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}:"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}: xxxx"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}: #{c}"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}: #{c.to_s.gsub('Controller', '')}"};
next
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}: #{c.to_s.gsub('Controller', '')}"};
exit
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}: #{c.to_s.gsub('Controller', '')}"};
exit
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}: #{c.to_s.gsub('Controller', '')}"};
Rails.application.routes.routes.first.path.spec.to_s
Rails.application.routes.routes
Rails.application.eager_load!
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('Controller', '').downcase}: #{c.to_s.gsub('Controller', '')}"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.gsub('Controller', '').undescore.downcase}: #{c.to_s.gsub('Controller', '')}"};
ApplicationController.subclasses.map{|c| puts "#{c.to_s.underscore.gsub('_controller', '').downcase}: #{c.to_s.gsub('Controller', '')}"};
exit
root_url
routing_type
routing_type :root
routing_type 1
routing_type 'x'
routing_type :root
routing_type :root1
ventures_path
exit
fullpath
fullpath.flatten
fullpath.compact
fullpath.compact('')
fullpath.except{|f| f.blank? }
fullpath.reject{|f| f.blank? }
fullpath.reject
controller_name
exit
fullpath
exit
fullpath
fullpath[-1]
exit
display_type
@display_type
@@display_type
$display_type
params
next
step
options
up
l+
end
next
exit
options
exit
options
exit
{ cases: Case::Entity.represent(kases, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user) }
cases: Case::Entity.represent(kases, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user)
Case::Entity.represent(kases, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user)
Case::Entity.represent(kase, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user)
Case::Entity.represent(kase, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user).to_json
exit
options
@options
exit
instance.next_step
options
exit
safe_params
safe_params[:display_type]
exit
{ cases: Case::Entity.represent(kase, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user) }.to_json
exit
{ cases: Case::Entity.represent(kase, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user) }.to_json
exit
{ cases: Case::Entity.represent(kase, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user) }.to_json
exit
{ cases: Case::Entity.represent(kase, display_type: safe_params[:display_type], just_user_can_view: (safe_params[:just_user_can_view] || true), current_user: current_user) }.to_json
exit
kase
exit
kase
exit
kase
exit
options[:current_user]
options
exit
next
options
exit
options
next
exit
next
parsed_body
exit
instance.case_steps
next
exit
next
case_steps.present?
exit
step
x=step
x[:step]
x[:step].id
exit
step[:step].id
exit
next
exit
@permissions
whereami
step
step[:step]
@permissions.can?(:show, step[:step].id)
exit
parsed_body
user.groups
parsed_body['case']['all_steps']
exit
can_execute_step
step.id
exit
step.id
can_execute_step
can_view_step
can_execute_all_steps
can_view_all_steps
step.flow.id
user.groups
exit
can_execute_step
can_view_step
can_view_all_steps
can_execute_all_steps
step.id
step
exit
can_execute_all_steps
can_view_all_steps
step.id
step.flow.id
exit
can_execute_step or can_view_step or can_execute_all_steps or can_view_all_steps
step.id
user.groups
exit
can_execute_step or can_view_step or can_execute_all_steps or can_view_all_steps
step.id
step.flow.id
exit
can_execute_step or can_view_step or can_execute_all_steps or can_view_all_steps
step.id
exit
can_execute_step or can_view_step or can_execute_all_steps or can_view_all_steps
step.id
exit
can_execute_step or can_view_step or can_execute_all_steps or can_view_all_steps
step.id
exit
step
x=step
@permissions.can?(:show, step[:step])
exit
Rails.assets
Rails.application.assets
Rails.application.assets.find_asset 'activies.js'
Rails.application.assets.find_asset 'attachments.js'
Rails.application.assets.find_asset 'attachments'
Rails.application.assets.find_asset('activies.js') ? 1 : 2
exit
parsed_body
whereami
Flow.last.steps.first
Step::Entity.represent(Flow.last.steps.first)
JSON.parse(Step::Entity.represent(Flow.last.steps.first).to_json)
JSON.parse(Step::Entity.represent(Flow.last.steps.first, display_type: 'full').to_json)
parsed_body['case']['next_step'] == JSON.parse(Step::Entity.represent(Flow.last.steps.first, display_type: 'full').to_json)
exit
next
ancestors
JSON.parse(Flow::Entity.represent(ancestors).to_json)
ancestors
Flow.all.map(&:id)
exit
Flow.all.map(&:id)
next
Flow.all.map(&:id)
ancestors
exit
next
ancestors
exit
parsed_body
parsed_body['flows']
parsed_body['flows'].include? JSON.parse(Flow::Entity.represent(parent_flow).to_json)
JSON.parse(Flow::Entity.represent(parent_flow).to_json)
parsed_body['flows'].last
JSON.parse(Flow::Entity.represent(parent_flow).to_json) == parsed_body['flows'].last
exit
whereami
next
exception
exit
condition_params
exit
condition_params
condition_params[:file]
condition_params[:file][:name]
condition_params[:file].name
condition_params[:file].file_name
condition_params[:file][:file_name]
condition_params[:file].original_filename
exit
next
exit
file
File.read(file.tempfile)
exit
'25/04/2014'.to_date
exit
f=File.read(file.temp_filename)
file
f=File.read(file.tempfile)
exit
file
next
exit
require 'iconv'
require 'csv'
require 'iconv'
exit
header
spreadsheet.row(3)
spreadsheet.row(1..3)
spreadsheet.row(1)
spreadsheet.row(2)
spreadsheet.row(3)
spreadsheet.row(4)
spreadsheet.row(6)
spreadsheet.row(7)
exit
i
spreadsheet.row(i)
exit
condition_list
condition_list.first
condition_list.first.valid?
condition_list.first.errors
exit
condition_list
condition_list.last
condition_list.last.errors
condition_list.last.valid?
exit
condition_list
exit
condition_list
exit
condition_list
exit
condition_list
condition_list.map(&:valid?)
condition_list.map(&:errors)
condition_list.map{|i| e.errors.messages }
condition_list.map{|i| i.errors.messages }
exit
condition_list
condition_list.map{|i| i.errors.messages }
exit
condition_list.map(&:valid?)
condition_list.map{|i| i.errors.messages }
exit
condition_list.map(&:errors)
condition_list.map{|i| i.errors.messages }
exit
errors
exit
has_errros
has_errors
condition_list.map { |c| c.errors.present? }.uniq
condition_list.map { |c| c.errors.present? }.uniq.include? false
condition_list.map { |c| c.errors.present? }.uniq.include? true
exitr
exit
@import_data.map {|c| c.errors.message }
@import_data.map {|c| c.errors.messages }
self.license
exit
@import_data.map{|c| c.errors.messages }
exit
@import_data.map{|c| c.errors.messages }
exit
cond
cond.errors
exit
cond.errors
exit
cond.errors
cond.errors.messages
cond.errors.messages.full_messages
cond.errors.full_messages
cond.errors.full_messages.first
exit
cond
index+10
exit
index+10
exit
@import_data
errors
exit
Condition.last
Condition.delete_all
Condition.last
Condition.count
exit
conditions
@license
@license.conditions
page
exit
import_data
@import_data
params
exit
next
response.body
exit
next
kases
exit
Activitie.all
Activit.all
Activity.all
EnvironmentProgram.all
exit
Activity.all
Activity.delete_all
exit
kases
exit
current_user.groups
exit
parsed_body['cases']
exit
Case.not_inactive.find(safe_params[:id])
next
validate_permission!(:show, kase)
exit
Case.not_inactive.find(safe_params[:id])
exit
user_groups
next
exit
parsed_body
whereami
Case::Entity.represent(kase1, just_user_can_view: true, current_user: user)
JSON.parse(Case::Entity.represent(kase1, just_user_can_view: true, current_user: user).to_json)
parsed_body['cases'].first
exit
instance.case_steps
exit
instance.case_steps
exit
instance.case_steps
exit
instance.case_steps
next
case_step_ids
exit
next
exit
Case::Entity.represent(kase1, just_user_can_view: true, current_user: user)
JSON.parse(Case::Entity.represent(kase1, just_user_can_view: true, current_user: user).to_json)
instance.case_steps
next
exit
parsed_body
user.groups
kase1.case_steps
exit
expect(parsed_body['cases']).to include_an_entity_of(kase1, just_user_can_view: true, current_user: user)
exit
can_execute_step
exit
can_execute_step
exit
next
exit
@activies_events
@activities_events
exit
Activity
Activity.last(2)
Activity.last(2).first
Activity.last(2).first.delete
exit
flash
flash[:recent_activities_event]
exit
@recenv_activities_event
@recent_activities_event
$('body');
exit
self.periodo_de >= self.license.created_at
self.license
exit
method_name
exit
row[2]
exit
row[2]
exit
row[2]
row[2].is_a
exit
"4/5/14".to_date
"4/5/14".strftime
Date.strptime("4/5/14", '')
DateTime.strptime("4/5/14", '')
DateTime.strptime("4/5/14", 'd/m/y')
DateTime.strftime("4/5/14", 'd/m/y')
require 'date'
Date.strpitme
require 'datetime'
string_to_date
string_to_datetime
DateTime
Time.strptime
Date.strptime
Date.strptime('4/5/14', '%d')
Date.strptime('4/5/14', '%d/%m/%y')
Date.strptime('4/5/2114', '%d/%m/%y')
Date.strptime('4/15/2114', '%d/%m/%y')
Date.strptime('4/05/2114', '%d/%m/%y')
Date.strptime('4/05/2014', '%d/%m/%y')
Date.strptime('4/05/2014', '%d/%m/%Y')
Date.strptime('4/05/14', '%d/%m/%Y')
"".to_date
"xxx".to_date
exit
row[2]
exit
Condition.all
Condition.delete_all
exit
[].shuffle
[1,2,3].shuffle
[1,2,3].shuffle.first
['sair', 'continua', 'vai dar $$', 'ele vai mancar de novo', 'espera ele vai te chamar', 'o pedro vai te convencer', 'sai', 'fica', 'sai1', 'fica1'].shuffle.first
exit
safe_params
next
parameters
next
parameters
next
Step.find(safe_params[:step_id]).fields.find(safe_params[:id])
exit
@licensing_step.valid?
@licensing_step.errors
exit
@licensing_step.valid?
@licensing_step.errors
licensing_step_params
params
exit
ext
exit
Venture.last
Venture.last.licensing_schedule
Venture.last.licensing_schedules
Venture.last.licensing_schedules.create licensing_step:LicensingStep.last, finished_at:Date.today+1.week
exit
next
data
next
exit
datas
exit
step.previous
exit
step.previous
self.find
self.class
self.class.find
self.class.find_by
self.class.find_by ordem: self.ordem
self.class.find_by 'ordem > ?', self.ordem
self.class.find_by 'ordem < ?', self.ordem
exit
step.previous
exit
step.next
step.previous
step
x=step
step.previous
exit
self
self.licensing_step
exit
self.licensing_step
exit
whereami
licensing_schedule_params
@licensing_schedule
next
exit
format
next
request
exit
schedule
x.step
x=step
licensing_schedules.find_by(licensing_step_id: x)
licensing_schedules.find_by(licensing_step_id: x.id)
exit
params[:licensing_schedules]
params[:licensing_schedule]
licensing_schedule_params
exit
licensing_schedules_params
params
exit
licensing_schedules_params
params.require(licensing_schedules).permit(:finished_at)
params.require(:licensing_schedules).permit(:finished_at)
params.require(:licensing_schedules).permit([]: [:finished_at])
params.require(:licensing_schedules).permit([]: :finished_at)
params.require(:licensing_schedules).permit(:[] => :finished_at)
params.require(:licensing_schedules).permit(:[] => [:finished_at])
exit
licensing_schedules_params
licensing_schedules_params.eacho {|a,b| puts a};
licensing_schedules_params.each {|a,b| puts a};
licensing_schedules_params.each {|a,b| puts b};
exit
schedules
schedules.map(&:valid)
schedules.map(&:valid?)
exit
saves
saves.values
saves.keys
savesexit
exit
schedules
exit
notice
schedules.map(&:save).include? false 
exit
notice
saves.include? false
saves.include? true
saves.include? false ? 'Erro ao atualizar algun(s) do(s) cronograma(s) .' : 'Cronograma atualizado com sucesso.'
saves.include?(false) ? 'Erro ao atualizar algun(s) do(s) cronograma(s) .' : 'Cronograma atualizado com sucesso.'
exit
params.require(:licensing_step)
exit
Group.find(group_id)
g=Group.find(group_id)
g.manage_flows
g.can_view_all_steps
g.permissions
exit
user.groups
user.groups.first.reload
exit
permissions
next
group
group.save!
exit
user.reload.groups
exit
next
group.save!
group
group.reload
group.permissions[permission_type] = permissions.push(safe_params[:id])
group.permissions[permission_type] = [1]
group.save
group.reload
permission_type
group.can_view_all_steps
group.permissions['can_view_all_steps']
group.permissions['can_view_all_steps'] = [1]
group.save
group.reload
group.permissions['can_view_all_steps'] = [1]
group.permissions_will_change!
group.save
group.reload
exit
@environment_program_theme.destroy
exit
@origin.class
@origin.class == LicensingSchedule
next
exit
activity.events
activity.events.any?
exit
activity.events.any?
exit
l event.inicio_planejado, format: :month_year
exit
next
exit
params
exit
Activity
Activity.last
Activity.first
exit
descricao
@activity.parent_id?
@activity.parent
@activity.parent.descricao
exit
paginate []
paginate kases
exit
RegionalSuperintendency
RegionalSuperintendency.all
RegionalSuperintendency.delete_all
RegionalSuperintendency.create name: 'xxxx'
RegionalSuperintendency.create id: 1, name: 'xxxx'
exit
State.all
State.first.cities
exit
type
exit
params.require(:institution)
exit
parsed_body['case']['case_steps']
parsed_body['case']
exit
gparsed_body['case']['next_steps']
parsed_body['case']['next_steps']
parsed_body['case']
exit
kase3
parsed_body['cases']
expect(parsed_body['cases']).to_not include_an_entity_of(kase3, just_user_can_view: true, current_user: user) 
exit
expect(parsed_body['cases']).to_not include_an_entity_of(kase3, just_user_can_view: true, current_user: user) 
exit
institutions.includes(:institution_types)
institutions.includes(:institution_type)
institutions.includes(:institution_type).where()
institutions.includes(:institution_type).where('institution_type.recebe_documento = true')
institutions.includes(:institution_type).where('institution_types.recebe_documento = true')
institutions.includes(:institution_type).where('recebe_documento = true')
institutions.join(:institution_type).where('recebe_documento = true')
institutions.joins(:institution_type).where('recebe_documento = true')
institutions.joins(:institution_type).where('recebe_documento = false')
institutions.joins(:institution_type).where('institution_type.recebe_documento = false')
institutions.includes(:institution_type).where('recebe_documento = true')
exit
params
exit
params
exit
@attachment.institution
exit
self
self.venture_type?
self.venture_type_present?
self.venture_type.present?
self.venture_type.venture_sub_types.present?
self.venture_type.venture_sub_types
exit
next
exit
self.venture_sub_type.blank? and self.venture_type.present? and self.venture_type.venture_sub_types.present?
self.venture_sub_type.blank? 
venture_type
venture_type.venture_sub_types
exit
self.venture_sub_type.blank? and self.venture_type.present? and self.venture_type.venture_sub_types.present?
venture_type.venture_sub_types
self.venture_sub_type.blank? 
self.venture_sub_type_id
exit
venture_params
exit
venture_params
exit
params.require(:venture).permit(:apelido, :nome, :place, :federal_program_id, :free_type, :regional_superintendency_id,:venture_type_id, :venture_sub_type_id, :licenciamento_codevasf, :orgao_conveniado,:orgao_licenciador, :numero_do_processo, :venture_execution_type_id, :board_of_director_id)
params.require(:venture)
params
exit
x
exit
x
x.keys
x.keys.sort
exit
x.keys.sort
params[:venture]
params[:venture].keys
params[:venture].keys.sort
exit
x.keys.sort
params[:venture].keys.sort
exit
x
params[:venture].keys.sort
x.keys.sort
exit
x
x.keys.sort
params[:venture].keys.sort
exit
x.keys.sort
params[:venture].keys.sort
exit
x.keys.sort
exit
City.find(23)
City.all
exit
City.find(23)
City.first
exit
City.first
exit
City.find(23)
City.find(1)
City.last
include 'xxx'
import 'xxx'
require 'xxx'
require Rails.root.joint 'xxx'
require Rails.root.join 'xxx'
City.codevasf
City.codevasf.count
City.count
City.first(10)
City.first(10).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };
City.sort(:id).first(10).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };
City.order(:id).first(10).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };
City.order(:id).first(10).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };nil
City.order(:id).limit(10).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };nil
City.order(:id).limit(5).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };nil
City.order(:id).includes(:state).limit(5).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };nil
City.order(:id).includes(:state).limit(5).each {|c| puts "state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')" };
f=File.new(Rails.root.join('xxx.rb'), 'w')
f.write('xxx')
f.close
f=File.new(Rails.root.join('xxx.rb'), 'w')
City.order(:id).includes(:state).limit(5).each {|c| f.write("state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')"); }
City.order(:id).includes(:state).limit(5).each {|c| f.write("state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')"); };nil
f.close
f=File.new(Rails.root.join('xxx.rb'), 'w')
City.order(:id).includes(:state).limit(5).each {|c| f.write("state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')\n"); };
f.close
f=File.new(Rails.root.join('xxx.rb'), 'w')
City.order(:id).includes(:state).each {|c| f.write("state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}')\n"); puts "#{c.id} - #{c.name}\n" };
City.count
f.close
f=File.new(Rails.root.join('xxx.rb'), 'w')
City.order(:id).includes(:state).each {|c| f.write("state_#{c.state.symbol.downcase}.cities.create(name: '#{c.name}', codevasf_actuation: #{c.codevasf_actuation})\n"); puts "#{c.id} - #{c.name}\n" };
f.close
git st
exit
venture
exit
venture
next
exit
venture
exit
venture
exit
venture.licensing_schedules
venture.licensing_schedules.map(&:finished_at)
venture.licensing_schedules.first.finished_at
venture.licensing_schedules.first.finished_at.mounth
venture.licensing_schedules.first.finished_at.month
exit
Venture.first.licensing_schedules
Venture.first.licensing_schedules.last.update finished_at: nil
Venture.first.licensing_schedules.map(&:finished_at)
Venture.first.licensing_schedules.map(&:finished_at).include? nil
exit
step
x=step
x.licensing_schedules
exit
method
method.gsub
method.to_s.gsub /^is_/, ''
method =~ /^is_/ 
method =~ /^is_*/ 
method.to_s.gsub(/^is_/, '')
method.to_s.gsub(/^is_/, '').gsub('?', '')
method.to_s.gsub(/^is_/, '').gsub(/\?$/, '')
exit
method =~ /^venture_/
method =~ /^venture_[a-z]/
method =~ /^venture_[a-z_]/
method =~ /^venture_x/
method =~ /^venture_/
next
attribute
exit
next
attribute
exit
next
attribute
args
self.licensing_schedule.venture.update(attribute.gsub('=', ''), args)
self.licensing_schedule.venture.update(attribute.gsub('=', ''), args.first)
self.licensing_schedule
self.licensing_schedule_id
exit
self.licensing_schedule.venture.update(attribute, args)
self.licensing_schedule
self.licensing_schedule_id
self
exit
self
exit
@licensing_schedule.new_ste_data
@licensing_schedule.new_step_data
@licensing_schedule.step_data
@licensing_schedule.step_data.new
@licensing_schedule.step_data.build
@licensing_schedule.build_step_data
@licensing_schedule.build_step_data {}
exit
self
LicensingSchedule
LicensingSchedule.last
LicensingSchedule.last.step_data
LicensingSchedule.last.build_step_data
LicensingSchedule.last.build_step_data.save
exit
self
licensing_schedule
exit
return
method
self
return
method
return
exit
next
attribute
exit
$1
exit
$1
self
args
exit
self
$1
self.licensing_schedule.venture
whereami
self.licensing_schedule.venture.update($1, args)
self.licensing_schedule.venture.update($1, *args)
self.licensing_schedule.venture.update($1 => args.first)
$1
x = {$1 => 1}
exit
StepData.delete_all
LicensingSchedule.step_data
LicensingSchedule.first.step_data
LicensingSchedule.first.step_data.find_or_create
StepData.delete_all
exit
step_data_params
exit
@origin
@origin.attachments
exit
@origin
@origin.attachments
exit
next
format
exit
next
exit
@attachment
params
format
exit
@attachment
exit
@attachment
exit
@attachment
exit
@attachment
exit
@attachment
exit
@attachment.save
@attachment.errors
exit
@licensing_schedule.step_data
exit
@venture.actual_step
@venture.actual_step.licensing_schedule
@venture.actual_step.licensing_schedules
exit
@venture.actual_step.type_of_final_action
exit
@venture.actual_step.type_of_final_action
@venture.actual_step.type_of_final_action.is_open_process?
exit
whereami
exit
step_data_params
next
step_data_params
next
step_data_params
step_data_paramseixt
exit
venture.licensing_model.licensing_phases.first.licensing_steps
venture.licensing_model.licensing_phases.first.licensing_steps.count
venture.licensing_model.licensing_phases.first.licensing_steps.second
venture.actual_step
exit
@licensing_schedule
@licensing_schedule.create_step_data(step_data_params)
@licensing_schedule.create_step_data
x=@licensing_schedule.create_step_data
x.valid?
exit
@licensing_schedule.step_data = StepData.new(step_data_params)
exit
@licensing_schedule.step_data = StepData.new(step_data_params)
@licensing_schedule.step_data = StepData.new(step_data_params, validate: false)
exit
@licensing_schedule.step_data = StepData.new(step_data_params, validate: false)
@licensing_schedule.step_data = StepData.new(step_data_params)
@licensing_schedule.create_step_data
x=@licensing_schedule.create_step_data
x.valid?
x=@licensing_schedule.create_step_data step_data_params
exit
x=@licensing_schedule.create_step_data step_data_params
method
$1
self
self.licensing_schedule
self.licensing_schedule.venture
exit
self.licensing_schedule.venture.send($1) 
exit
$1
self.licensing_schedule.venture.send($1) 
exit
$1
exit
$1
exit
method
exit
whereami
x
x.valid?
method
exit
args
exit
@licensing_schedule.step_data
@licensing_schedule.create_step_data
x=@licensing_schedule.create_step_data
x.errors
exit
@licensing_schedule.create_step_data(step_data_params)
exit
Venture.first
Venture.first.licensing_schedules
Venture.first.licensing_schedules.map(&:finalizada_em)
Venture.first.licensing_schedules.first.delete
exit
LicensingSchedule.find(20)
exit
LicensingSchedule.find(12)
exit
LicensingSchedule.find(2)
LicensingSchedule.find(22)
xit
exit
kase.id
kase.reload.case_steps
parsed_body['case']['previous_steps']
exit
parsed_body['case']['previous_steps']
exit
self
exit
next
exit
self
self.id
exit
self
next
exit
@origin
exit
params
params[:action]
exit
other_flow
exit
License.delete_all
exit
@venture.actual_step
@venture.next_step
next
@old_actual_step
@venture.actual_step
exit
@old_actual_step
@venture.actual_step
exit
@old_actual_step
@venture.actual_step
exit
@old_actual_step
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
@old_actual_step
exit
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
next
exit
next
exception
next
e
next
exit
@old_actual_step.licensing_schedules.find_by_venture_id(@venture).update!(finalizada_em: nil)
exit
params
request.format
exit
params
request.format
exit
next
licensing_process_venture_path
next
digest
@no_cache_control
next
status
body
next
exit
next
exit
exitexit
exit
LicensingSchedule.update(finalizada_em: nil)
LicensingSchedule.all.each {|l| l.update(finalizada_em: nil)}
LicensingSchedule.all.each {|l| l.update(finalizada_em: nil)};
exit
parameters
next
licensing_model.present? and licensing_model.licensing_phases.present? 
licensing_model.licensing_phases.map(&:licensing_steps).include? nil
licensing_model.licensing_phases.map(&:licensing_steps)
licensing_model.licensing_phases.map(&:licensing_steps).include? []
licensing_schedules.present? 
licensing_schedules.map(&:vencimento_planejado).include? nil
licensing_schedules.map(&:vencimento_planejado)
exit
@notices
exit
venture
@notices
schedule
process
venture.actual_step
venture.actual_phase
venture.licensing_schedules
venture.licensing_schedules.map(&:finalizada_em)
venture.licensing_schedules.find_by(finalizada_em: nil)
venture.licensing_schedules.where(finalizada_em: nil).last
venture.licensing_model.licensing_phases.blank?
venture.licensing_schedules
venture.licensing_schedules.map(&:step_data)
venture.licensing_model.licensing_phases.first.licensing_steps.first
venture.licensing_model.licensing_phases.first.licensing_steps.first.licensing_schedules
venture.licensing_model.licensing_phases.first.licensing_steps.first.licensing_schedules.count
venture.licensing_model.licensing_phases.first.licensing_steps.first.licensing_schedules
venture
venture.licensing_model.licensing_phases.first.licensing_steps.first.licensing_schedules
venture.licensing_model.licensing_phases.first.licensing_steps.first.licensing_schedules.find_by_venture_id(venture.id)
venture.licensing_schedules
venture.licensing_schedules.map(&:id)
venture.licensing_schedules.map(&:licensing_step_id)
venture.licensing_model.licensing_phases.first.licensing_steps.first.licensing_schedules.find_by_venture_id(venture.id)
venture.licensing_schedules
venture.licensing_model.licensing_phases.first.licensing_steps.second.licensing_schedules.find_by_venture_id(venture.id)
venture.licensing_model.licensing_phases.second.licensing_steps.first.licensing_schedules.find_by_venture_id(venture.id)
venture.licensing_model.name
venture.update(licensing_model_id: 1)
exit
@notices
exit
@notices
venture.actual_phase
exit
@notices
exit
venture
exit
venture
venture.licensing_schedules
venture.licensing_schedules.map(&:finalizada_em)
venture
exit
TypeOfFinalAction
TypeOfFinalAction.all
x=TypeOfFinalAction.all
x.reject{|t| t.code == :emission}
x.reject{|t| t.code == 'emission'}
x
x.reject!{|t| t.code == 'emission'}
x
TypeOfFinalAction.all.reject{|t| t.code == 'emission' }
exit
new_licensing_model
@licensing_model.clone
exit
next
exit
new_licensing_model
new_licensing_model.licensing_phases
new_licensing_model.licensing_phases.first
new_licensing_model.licensing_phases.first.licensing_steps
new_licensing_model.save
new_licensing_model
new_licensing_model.licensing_phases
exit
self.licensing_model
self.licensing_model.licensing_phases
exit
self.licensing_model.licensing_phases
exit
new_licensing_model.valid?
new_licensing_model.errors
new_licensing_model.licensing_phases
new_licensing_model.licensing_phases.map(&:valid?)
new_licensing_model.licensing_phases.last.errors
new_licensing_model.licensing_phases.last.licensing_steps
new_licensing_model.licensing_phases.last.licensing_steps.map(&:valid?)
new_licensing_model.licensing_phases.last.licensing_steps.first.errors
exit
new_licensing_model.errors
exit
get :copy, {id: licensing_model.id}, valid_session
whereami
response.body
exit
LicensingModel.first.is_locked?
self.ventures
self.ventures.map(&:licensing_schedules)
self.ventures.map{|v| v.licensing_schedules.present? }
self.ventures.map{|v| v.licensing_schedules.present? }.include? true
exit
licensing_model.venture
licensing_model.ventures
licensing_model.reload.ventures
exit
licensing_phase
licensing_phase.licensing_steps
licensing_model
licensing_model.licensing_phases
exit
LicensingSchedule.find(24).licensing_steps
LicensingSchedule.find(24).licensing_step
LicensingSchedule.find(24).licensing_step.attachment_types
LicensingSchedule.find(24).licensing_step.attachment_types << AttachmentType.first(2)
exit
pluralize(count, sing, plura)
pluralize(count, sing, plura).gsub(/\d+s/, '')
pluralize(count, sing, plura).gsub(/^\d+s/, '')
pluralize(count, sing, plura).gsub(/^\d+/, '')
pluralize(count, sing, plura).gsub(/^\d+\s/, '')
exit
@orign
@origin
@origin.attachments
exit
@origin.attachments
exit
@origin
@origin.attachments
exit
@origin
exit
StepData.all
StepData.delete_all
License.find(7).step_data
License.find(7).step_data.licensing_schedule.licensing_step
License.find(7).step_data.licensing_schedule.licensing_step.attachments_type
License.find(7).step_data.licensing_schedule.licensing_step.attachments_types
License.find(7).step_data.licensing_schedule.licensing_step.attachment_types
License.find(7).step_data.licensing_schedule.licensing_step.attachment_types << AttachmentType.first(2)
exit
Step.find(15)
LicensingStep.find(15)
LicensingStep.find(15).update opcional: true, pergunta: 'Etapa sobre a licença de XXX sobre algo XPTO.'
exit
StepData.delete_all
LicensingSchedule.all.update(finalizada_em: nil)
LicensingSchedule.all.update(:finalizada_em, nil)
LicensingSchedule.all.map{|l| l.update(finalizada_em: nil) }
LicensingSchedule.find(23).licensing_step.update(opcional: true, pergunta: 'Etapa opcinal por xxx')
exit
LicensingSchedule.find(25).licensing_step.update(opcional: true, pergunta: 'Etapa opcinal por xxx')
LicensingSchedule.find(24).licensing_step.licensing_phase
LicensingSchedule.find(24).licensing_step.licensing_phase.update license_type: LicenseType.first
exit
licensing_model.present? and licensing_model.licensing_phases.present?
licensing_model.licensing_phases.map(&:licensing_steps).include? [] 
licensing_schedules.present? 
licensing_schedules.not_skipped
licensing_schedules.not_skipped.map(&:vencimento_planejado)
licensing_schedules.not_skipped
exit
licensing_schedules.not_skipped.map(&:vencimento_planejado).
end
licensing_schedules.not_skipped.map(&:vencimento_planejado)
licensing_schedules.not_skipped.map(&:licensing_step)
licensing_schedules.not_skipped
licensing_schedules.not_skipped.count
licensing_schedules.count
licensing_schedules.not_skipped.where(vencimento_planejado: nil)
licensing_schedules.not_skipped.where(vencimento_planejado: nil).delete_all
licensing_schedules.not_skipped.count
exit
licensing_schedules.not_skipped.map(&:vencimento_planejado)
exit
@licensing_schedule.step_data
@licensing_schedule.create_step_data
@licensing_schedule
@licensing_schedule.case_ste
@licensing_schedule.ste_data
@licensing_schedule.step_data
@licensing_schedule.buildstep_data
@licensing_schedule.build_step_data
@licensing_schedule.build_step_data.save
exit
Venture.find(7).licensing_schedules
Venture.find(7).licensing_schedules.count
LicensingSchedule.all.map{|l| l.update(finalizada_em: nil) }
StepData.delete_all
LicensingSchedule.all.map{|l| l.update(finalizada_em: nil, skipped: false) }
exit
LicensingSchedule.find(10).licensing_step.licensing_phase.update license_type: LicenseType.first
LicensingSchedule.find(10).licensing_step.attachment_types << AttachmentType.first
exit
StepData.last
StepData.last.delete
LicensingSchedule.find(10).update finalizada_em: nil
StepData.delete_all
LicensingSchedule.all.map{|l| l.update(finalizada_em: nil, skipped: false) }
LicensingSchedule.all.map{|l| l.update(finalizada_em: nil, status: :skipped) }
LicensingSchedule.all.map{|l| l.update(finalizada_em: nil, status: 'skipped') }
LicensingSchedule.all.map{|l| l.update(finalizada_em: nil, status: 'active') }
LicensingSchedule.all.map(&:step_data)
exit
x=User.create 
x.errors
x=User.create name: 'Eurico Vidal', email: 'email@example.com', password: '123456abc'
User.last.confirm!
exit
next
exit
@licensing_phase.valid?
@licensing_phase.errors
exit
licensing_schedules.active
licensing_schedules.active.find_or_create_by(licensing_step_id: step.id)
licensing_schedules.active.find_or_create_by_licensing_step_id(licensing_step_id: step.id, status: 'active')
exit
LicensingSchedule.count
exit
Institution.first
InstitutionType.where(emite_licenca: true)
InstitutionType.where(emite_licenca: true).selct(:id)
InstitutionType.where(emite_licenca: true).select(:id)
InstitutionType.where(emite_licenca: true).select(:id).to_a
reload!
Venture.new
Venture.new.institution
exit
whereami
Venture.all
Venture.joins(:venture_type, :institution)
Venture.joins(:venture_type)
Venture.joins(:venture_type,[A])
end
Venture.joins([:venture_type, :institution])
exit
user.reload.groups
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exi
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
nil + ''
exit
eventual_requirements
exit
eventual_requirements
exit
buid(:eventual_requirement)
build(:eventual_requirement)
build(:eventual_requirement_type)
create(:eventual_requirement_type)
exit
@venture.actual_step
@licensing_schedule.licensing_step
exit
@licensing_schedule.licensing_step
@licensing_schedule.licensing_step.id
exit
Venture.find(3).actual_step
Venture.find(3).licensing_schedules
Venture.find(3).licensing_schedules.first
Venture.find(3).licensing_schedules.second
Venture.find(3).licensing_schedules.thrid
Venture.find(3).licensing_schedules.all.third
Venture.find(3).actual_step
Venture.find(3).licensing_schedules.all.third
Venture.find(3).actual_step
Venture.find(3).actual_step.licensing_phase
Venture.find(3).licensing_schedules
Venture.find(3).licensing_schedules.map{|l| l.licensing_step.nome }
Venture.find(3).licensing_model
Venture.find(3).licensing_model.licensing_phases.first
Venture.find(3).licensing_model.licensing_phases.first.licensing_step
exit
formats
formats = [:erb]
next
exception
exit
exti
exit
next
step
format
name
parser
exti
exit
next
step
[name, format, parser].compact.join(".")
name
[nil, format, parser].compact.join(".")
exit
next
filename_with_extensions(format, view)
exit
view
exit
User.all
exit
@notices.blank?
exit
@notices.blank?
venture.actual_phase
exit
@notices.blank?
venture.actual_phase
exit
@notices.blank?
venture.actual_phase
venture
venture.licensing_schedules
venture.licensing_schedules.first
venture.actual_phase
exit
venture.actual_step
licensing_step.licensing_schedules.active
licensing_step.licensing_schedules
licensing_step.licensing_schedules.find_by_venture_id(self)
exit
venture.next_step
licensing_step.licensing_schedules.active.find_by_venture_id(self)
licensing_step.licensing_schedules.find_by_venture_id(self)
exit
venture.next_step
exit
venture.completed?
exit
@notices.present?
venture.completed?
exit
venture.licensing_schedules
venture.licensing_schedules.count
venture
exit
venture
venture.licensing_schedules.count
venture.licensing_scheduled
venture.licensing_schedules
venture.licensing_schedules.pending
venture.licensing_schedules.pending.count
exit
venture
venture.completed?
venture.actual_step
exit
LicensingPhase.last.ordem
LicensingPhase.last.ordem.decrement
LicensingPhase.last.decrement :ordem
LicensingPhase.last.ordem
LicensingPhase.last.ordem--
end
x=4
x++
end
++x
--x
x
--x
-x
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
Venture.find(12)
Venture.find(12).licensing_schedules
reload!
Venture.find(12).licensing_schedules
Venture.find(12).licensing_schedules.first
Venture.find(12).licensing_schedules.first.eventual_requirements_to_here
reload!
Venture.find(12).licensing_schedules.first.eventual_requirements_to_here
reload!
Venture.find(12).licensing_schedules.first.eventual_requirements_to_here
reload!
Venture.find(12).licensing_schedules.first.eventual_requirements_to_here
Venture.find(12).licensing_schedules.find(42).eventual_requirements_to_here
Venture.find(11).licensing_schedules.find(39).eventual_requirements_to_here
Venture.find(6).licensing_schedules.find(11).eventual_requirements_to_here
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here
reload!
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here
reload!
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here.map(&:eventual_requirements)
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here.map(&:eventual_requirements).flatten
reload!
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here.map(&:eventual_requirements).flatten
exit
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here.map(&:eventual_requirements).flatten
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here.order
Venture.find(6).licensing_schedules.find(13).eventual_requirements_to_here.sort
Venture.find(6).licensing_schedules.find(14).eventual_requirements_to_here.sort
Venture.find(6).licensing_schedules.find(14).eventual_requirements_to_here.sort{|x,y| x.numero <=> y.numero }
Venture.find(6).licensing_schedules.find(14).eventual_requirements_to_here.sort{|x,y| y.numero <=> x.numero }
reload!
Venture.find(6).licensing_schedules.find(14).eventual_requirements_to_here
exit
venture.id
licensing_schedule.id
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
self.venture.licensing_schedules.find_by_licensing_step_id(step).id
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
exit
self.venture.licensing_schedules.find_by_licensing_step_id(step)
step
elem
elem.reload
need_create_version_by_keys?
skip_flow
next
self.resolution_states.each {|i| i.update!(last_version: i.last_version + 1) if elem != i }
self.steps.each { |s| s.bump_version_cascade! elem }
whereami
self.resolution_statxes.first.update!(last_version: i.last_version + 1)
self.resolution_states
self.resolution_states.first.update!(last_version: self.resolution_states.first.last_version + 1)
self.resolution_states.last.update!(last_version: self.resolution_states.last.last_version + 1)
x=self.resolution_states.last
x.increment :last_version
x.save
x.errors
exit
i.update!(last_version: i.last_version + 1) 
exit
i.update!(last_version: i.last_version + 1) 
eit
exit
i.update!(last_version: i.last_version + 1) 
exit
self.flow.resolution_states.find_by(default: true).blank? 
next
self.flow.update(status: flow_status, updated_by: self.user)
exit
next
self.flow.status
flow_status
exit
next
exit
parameters
next
case_query
exit
next
case_query
exit
self.versions
exit
need
self.changes.keys.select{|key| KEYS_TO_CREATE_VERSION.include? key }.present?
self.persisted?
next
need
exit
exitget_flow.try(:bump_version_cascade!, self)
get_flow.try(:bump_version_cascade!, self)
exit
need_create_version_by_keys?
self.verify_if_need_create_version?
self.total_cases
self.cases
exit
need_create_version_by_keys?
exit
next
elem.user
exit
next
elem.user
exit
self
exit
self.find(ids.first)
next
self.find(ids.first)
self.find(ids.first).reload
self.find(ids.first).touch_with_version
self.find(ids.first).reload
self.find(ids.first).touch
self.find(ids.first).touch_with_version
self.find(ids.first)
self.find(ids.first).save!
self.find(ids.first).touch_with_versionexit
exit
elem
next
elem
exit
elem
next
elem
exit
elem.step
next
elem.step
elem.step.reload
elem
elem.reload
exit
next
Field.find(106)
exit
self
next
self
next
exit
self.cases
self.steps.find_by(step_type: 'form')
self.steps.find_by(step_type: 'form').case_steps
exit
self
next
exit
self
self.versions
Step.all
Step.last
Step.last.versions
Step.first.versions
Flow.all
Flow.last
Flow.last.versions
exit
Flow.last
Flow.last.versions
Flow.last.versions.count
next
Flow.last.versions.count
self.fields.each { |i| i.update!(last_version: i.last_version + 1) if elem != i } if self.step_type == 'form'
Flow.last.versions.count
exit
Flow.last.versions.count
delete "/flows/#{@field.step.flow.id}/steps/#{@field.step.id}/fields/#{@field.id}", {}, auth(user)
exit
Flow.last
Flow.last.versions
delete "/flows/#{@field.step.flow.id}/steps/#{@field.step.id}/fields/#{@field.id}", {}, auth(user)
exit
elem
exit
elem
next
exit
elem
need_create_version_by_keys?
exit
elem
need_create_version_by_keys?
exit
elem
need_create_version_by_keys?
exit
elem
need_create_version_by_keys?
exit
Flow.last
exit
elem
need_create_version_by_keys?
elem.changes
elem.resolution_states
next
exit
elem
next
self
next
exit
need_create_version_by_keys?
exit
need_create_version_by_keys?
exit
need_create_version_by_keys?
exit
need_create_version_by_keys?
exit
need_create_version_by_keys?
exit
need_create_version_by_keys?
elem
self
exit
self.versions
exit
self
elem
exit
self
next
self
self.reload
next
exit
self
self.changes
exit
self.changes
self.last_version_changed?
exit
self.last_version_changed?
self.changes
exit
self.changes
exit
self.last_version
exit
self.last_version
self.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
expect(flow.reload.steps.first.child_flow.versions.count).to eql(1)
exit
self.changes
self.reload.changes
exit
self.changes
exit
self.changes
exit
self.changes
exit
flow.reload.steps.first.child_flow.versions.count
exit
flow.reload.steps.first.child_flow.steps.first.versions
flow.reload.steps.first.child_flow.steps.first.versions.map(&:reify)
flow.reload.steps.first.child_flow.steps.first
exit
self
self.changes
exit
self
exit
self
self.versions
exit
@field
@field.reload
@field.reload.versions
Field.all
Field.all.map(&:last_version)
exit
self
self.changes
exit
Field.all.map(&:last_version)
exit
get_flow.try(:bump_version_cascade!, self.reload)
self
exit
self
self.reload
get_flow.try(:bump_version_cascade!, self.reload)
exit
Field.all.map(&:last_version)
exit
get_flow.try(:bump_version_cascade!, self.reload)
elem
i
exit
elem
i
elem.change
elem.changes
exit
elem
i
exit
elem
i
exit
self
self.reload
exit
elem
next
exit
next
exit
next
elem
next
elem
i
exit
elem
i
exit
next
elem
exit
elem
exit
elem
exit
flow.resolution_states
exit
self.steps
self.my_steps
exit
self.steps
self.my_steps
exit
flow.reload
flow.steps.first
response.body
put "/flows/#{flow.id}/steps", {ids: flow.steps.map(&:id).sort}, auth(user)
flow.steps.first
flow.steps.first.reload
exit
Flow.find(safe_params[:flow_id])
Flow.find(safe_params[:flow_id]).steps
next
Flow.find(safe_params[:flow_id])
Flow.find(safe_params[:flow_id]).reload
Flow.find(safe_params[:flow_id]).steps.update_order!(safe_params[:ids], current_user)
Flow.find(safe_params[:flow_id]).steps.update_order!(safe_params[:ids].reverse, current_user)
Flow.find(safe_params[:flow_id]).steps.update_order!(safe_params[:ids].sort, current_user)
exit
Flow.find(safe_params[:flow_id])
Flow.find(safe_params[:flow_id]).steps
exit
response.body
exit
Flow.find(safe_params[:flow_id])
Flow.find(safe_params[:flow_id]).steps
exit
elem.get_flow.try(:verify_if_need_create_version?)
exit
Case.all
Case.last
exit
elem.get_flow.try(:verify_if_need_create_version?)
next
elem.last_version
user
next
status
exit
next
exit
need_create_version_by_keys?
exit
need_create_version_by_keys?
exit
response.body
exit
eventual_requirement_grant
next
exit
next
elem
elem.user
self
next
elem
self
next
elem
i
exit
response.body
pased_body
pase_body
JSON.parse response.body
exit
elem
i
i.step
exit
elem
exit
elem
exit
elem
exit
elem
exit
elem
exit
elem
exit
elem
exit
elem
exit
elem.reload
elem
Flow.first
Flow.first.reload
exit
Flow.first.steps.first.fields.count
exit
version_n
self
self.versions
self.versions.count
self.versions.first
self.versions[version_n-1]
self.versions[version_n-1].reify
exit
self
self.versions
self.versions[version_n-1].try(:reify)
self.versions[version_n-1].try(:reify).versions
exit
step
x=step
Step.find(safe_params[:id])
Step.find(safe_params[:id]).fields
Step.find(safe_params[:id]).fields.count
Step.find(safe_params[:id]).my_fields
exit
Step.find(safe_params[:id]).my_fields
x=step
x.my_fields
Step.find(safe_params[:id]).my_fields.count
x.my_fields.count
x.my_fields
x.my_fields.map(&:title)
x.my_fields.first
exit
Step::Entity.represent(step)
Step::Entity.represent(step).to_json
Step::Entity.represent(step, display_type: 'full').to_json
exit
self
self.my_fields
self.send('my_fields')
self.send('my_fields').map(&:id)
self.send('my_fields').map{|f| f.id }
x=self.send('my_fields')
x.first
x.first.id
x.class
x.map{|f f.id }
x.map{|f| f.id }
x.map{|f| f['id'] }
x.map{|f| f }
x.map{|f| f.title }
x.first.class
x
x.each {|f| f.id }
xz
x
x.flatten.map(&:id)
x.flatten
x.compact
x.compact.map(&:id)
exit
@licensing_schedule
exit
action
activity
event
@origin
exit
kase.status
next
kase.disabled_steps.include? safe_params[:step_id]
exit
next
kase.case_steps.find_by(step_id: safe_params[:step_id], step_version: safe_params[:step_version])
safe_params[:fields].present? 
next
case_step.present?
next
Step.active.find(safe_params[:step_id])
next
validate_permission!(:create, case_step)
next
validate_permission!(:create, case_step)
next
case_step_is_new
next
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
CasesLogEntry::Entity.represent(kase.cases_log_entries, display_type: safe_params[:display_type]).to_json
exit
CasesLogEntry::Entity.represent(kase.cases_log_entries, display_type: safe_params[:display_type])
CasesLogEntry::Entity.represent(kase.cases_log_entries, display_type: safe_params[:display_type]).to_json
exit
parsed_body['cases_log_entries']
kase
kase.cases_log_entries
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
institution_type_institutios_path
institution_type_institutions_path
url_for
exit
params
next
exit
filters
nstitution.all.includes(:institution_type)
Institution.all.includes(:institution_type)
Institution.all.includes(:institution_type).where(filters)
Institution.all.includes(:institution_type).where('recebe_documento' => true)
Institution.all.includes(:institution_type).where('institutions_type.recebe_documento' => true)
Institution.all.includes(:institution_type).where('institution_types.recebe_documento' => true)
exit
filters
Institution.all.includes(:institution_type).where(filters)
Institution.all.joins(:institution_type).where(filters)
InstitutionType.where(entrega_documento: true).institutions
InstitutionType.where(entrega_documento: true)
InstitutionType.where(entrega_documento: true).first.institutions
exit
Case.not_inactive.find(safe_params[:id])
kase.status
next
case_step
safe_params[:fields].present?
next
fields
next
case_step_is_new
next
e
exit
kase.initial_flow.list_all_steps
next
d
e
exit
step_index
all_steps
kase.initial_flow
kase.initial_flow.list_all_steps
kase.initial_flow.steps
Case.find(15)
Case.find(15).inisital_flow
Case.find(15).inital_flow
Case.find(15).initial_flow
Case.find(15).initial_flow.steps
Case.find(15).initial_flow.versions
Case.find(15).initial_flow.versions.second
Case.find(15).initial_flow.versions.second.changes
Case.find(15).initial_flow.versions.second.changed
Case.find(15).initial_flow.versions.second.changeset
Case.find(15).initial_flow.versions.first
Case.find(15).initial_flow.versions.first.changes
Case.find(15).initial_flow.versions.first.changed
exit
User
User.first
exit
params
exit
params
exit
step_index
kase.initial_flow
kase.initial_flow.list_all_steps
step_index
all_steps[step_index+1..-1]
next
message
next
exit
my_step
my_step.my_fields
exit
field
field_data
next
data_field
next
value
next
minimum
maximum
requirement
next
presence
@items_with_update
next
@items_with_update
self.errors
exit
case_step_is_new
next
nextexit
exit
all_steps
next
other_steps
next
exit
case_step
case_step.case_step_data_fields
exit
my_step
my_step.my_fields
exit
kase.errors
exit
phase
phase.slice(:id)
phase.select(:id)
exit
schedule.status
@venture.licensing_schedules.active.find_by_licensing_step_id(step)
step
x=step
@venture.licensing_schedules.find_by_licensing_step_id(step)
@venture.licensing_schedules.active.find_by_licensing_step_id(step)
step
exit
schedule
exit
Date.today
Date.today.to_i
Date.today.time
Date.today.timestamp
Date.today.timestamps
DateTime.now
DateTime.now.to_i
exit
data
exit
schedule
exit
LicensingModel.find(10).ventures
LicensingModel.find(10).ventures.map(&:id0
  end
LicensingModel.find(10).ventures.map(&:id)
LicensingModel.find(2).ventures.map(&:id)
Date.today
Date.today - 10.day
Date.today
Date.today.strftime
Date.today.strftime('%Q')
exit
venture
venture.cerated_at
venture.created_at
venture.created_at.strftime('%Q')
venture.created_at.to_date
exit
Venture.find(5).licensing_schedules
LicensingStep.active
LicensingStep.all
nil + 1.day
0 + 1.day
exit
schedule
schedule.inicio_planejado
exit
Venture.find(5)
exit
venture
exit
venture
venture.licensing_model
venture.licensing_model.licensing_phase
venture.licensing_model.licensing_phases
exit
index
step
Date.today - index.months
venture.licensing_model.licensing_phases
venture.licensing_model.licensing_phases.reverse
index
index.days
exit
venture.licensing_schedules
venture.licensing_schedules.map(&:vencimento_planejado)
eixt
exit
index_step
index_phase
exit
schedule
step_before
step_before.licensing_schedules.active.find_by_venture_id(venture)
step_before.licensing_schedules.find_by_venture_id(venture)
whereami
get_by_before_step(step_before)
step_before
step
step_befor
step_before
get_by_before_step(step_before)
exit
@activities_event
@activities_event..responsible_for_activity_id
@activities_event.responsible_for_activity_id
next
exit
step_venture_general_schedule_path
xstep_venture_general_schedule_path
step_venture_general_schedule_path
step_venture_general_schedule_path(@venture)
step_venture_general_schedule_path(@venture, @venture.licensing_schedules.last)
exit
@schedule
@schedule.licensing_step
exit
@schedule
exit
@origin
@origin.activies
@origin.activities
exit
origin
exit
@schedule.licensing_step
@schedule.licensing_step.before
@schedule.licensing_step.licensing_phase.before
@schedule.licensing_step.licensing_phase
exit
programs
before_phase
before_phase.license(@schedule.venture)
exit
programs
programs.environment_programs
exit
activity
activity.data_final
activity.data_inicial
exit
activity.data_inicial
activity.data_final
exit
origin
exit
event
activity
exit
LicensingSchedule.find(18)
LicensingSchedule.find(18).licensing_step
LicensingSchedule.find(18).licensing_step.update(programa_ambiental:true)
LicensingSchedule.find(18).licensing_step.type_of_final_action
TypeOfFinalAction.all
LicensingSchedule.find(18).licensing_step.type_of_final_action = TypeOfFinalAction.second
LicensingSchedule.find(18).licensing_step.type_of_final_action = TypeOfFinalAction.all.second
LicensingSchedule.find(18).licensing_step.type_of_final_action
LicensingSchedule.find(18).licensing_step.update type_of_final_action_id: TypeOfFinalAction.all.second.id
LicensingSchedule.find(22).licensing_step.update(programa_ambiental:true)
LicensingSchedule.find(24).licensing_step.update(programa_ambiental:true)
LicensingSchedule.find(22).licensing_step.update type_of_final_action_id: TypeOfFinalAction.all.second.id
exi
exit
self
self.eventual_requirement_auth
return nil
requirement
requirement.name
requirement.eventual_requirement_type
exit
requirement.eventual_requirement_type
exit
requirement.eventual_requirement_type
requirement.eventual_requirement_type.type_of_form_requirement
requirement.eventual_requirement_type.type_of_form_requirement.name
exit
eventual_requirement_auth.present?
eventual_requirement_auth
exit
eventual_requirement_auth.present?
eventual_requirement_auth.authorization_type.name 
exit
LicensingSchedule.find(18)
LicensingSchedule.find(18).vencimento_planejado
LicensingSchedule.find(18).vencimento_planejado.strftime('%Q')
LicensingSchedule.find(18).vencimento_planejado.to_s
LicensingSchedule.find(18).vencimento_planejado.to_s.strftime
LicensingSchedule.find(18).vencimento_planejado.to_s.to_date
LicensingSchedule.find(18).vencimento_planejado.strftime('%Q')
Time.at LicensingSchedule.find(18).vencimento_planejado.strftime('%Q')
Time.at LicensingSchedule.find(18).vencimento_planejado.strftime('%Q').to_i
Time.at LicensingSchedule.find(18).vencimento_planejado.strftime('%Q').to_i / 1000
exit
program.responsible_for_prograqm
program.responsible_for_program
exit
add_foreign_key "cities", "states", name: "cities_state_id_fk"
exit
require '20140425003050_add_keys'
require 'db/migrate/20140425003050_add_keys'
p Rails.root
p Rails.root.join('db', 'migrate')
p Rails.root.join('db', 'migrate', '20140425003050_add_keys')
require Rails.root.join('db', 'migrate', '20140425003050_add_keys')
AddKeys
AddKeys.new.change
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
first_schedule
last_schedule
exit
first_schedule
last_schedule
exit
first_schedule
last_schedule
first_schedule.inicio_planejado
exit
Event.al
Event.last
Event.all
Event.first
exit
exitget_by_after_phase_followed_env_program_step(licensing_step)
get_by_after_phase_followed_env_program_step(licensing_step)
schedule
self
x=get_by_after_phase_followed_env_program_step(licensing_step)
x.licensing_step
exit
x=get_by_after_phase_followed_env_program_step(licensing_step)
x.licensing_step
licensing_step
exit
params[:recent_activity_event_id]
next
@recent_activity_event_id 
@recent_activity_event_id = @recent_activity_event_id.to_i
exit
@environment_program
@environment_program.activities
exit
url
exit
url
exit
url
exit
url
exit
url
exit
url
exit
url
exit
url
exit
url
exit
url
exit
url
send(url, @venture, @license, @origin, activity, event)
exit
@origin
@origin.eventual_requirement_type
@origin.eventual_requirement_type.attachment_types
exit
@origin
exit
xit
exit
phase_schedules
exit
phase_schedules
exit
params[:action]
exit
origin.periodo_de
origin.license.started_at
data_inicial
next
exit
origin.condition
condition
exit
whereami
self.data_inicio
data_inicio
data_fim
exit
whereami
exit
@activities_event.update(activities_event_params)
exit
@activities_event.update(activities_event_params)
exit
url
exit
url
params[:action]
exit
@origin
exit
@origin
exit
params
exit
params
next
exit
params
@activities_events
exit
params
exit
params
@activities_event
@activities_event.persisted?
exit
url
params
@activities_event.persisted?
url_for(action: 'update', controller: 'activities_events', activities_event_id: @activities_event)
exit
action
params
exit
action
params
action
whereami
exit
action
exit
params
activity_url_for(:create) 
exit
params
@activities_event
@activities_event.new_record?
activity_url_for(:create) 
activity_url_for(:create, nil) 
activity_url_for(:index) 
exit
params
exit
exir
exit
@activities_event
exit
@activities_event
exit
@eventual_requirement.data_do_encerramento
@eventual_requirement
params
exit
@eventual_requirement.update(eventual_requirement_params.merge(data_do_encerramento: Date.today))
@eventual_requirement.updated?
@eventual_requirement.updated
@eventual_requirement.changes
@eventual_requirement.valid?
exit
enture_licensing_schedule_eventual_requirements_path
venture_licensing_schedule_eventual_requirements_path
exit
next
case_step
next
fields
next
fields
next
step_index
exit
all_steps
kase.initial_flow
kase.initial_flow.list_all_steps
kase.initial_flow.steps
kase.initial_flow.my_steps
kase.initial_flow.steps
kase.initial_flow.steps.include? step
exit
fields
case_step
next
fields
next
all_steps
all_steps.map(&:id).include? step.id
next
step_index
next
step.my_triggers
run_triggers(step, kase, current_user) 
exit
trigger.id
next
kase.disabled_steps
kase.disabled_steps.push(trigger_values).flatten.uniq
next
e
exit
kase
kase.disabled_steps
kase.disabled_steps.push(trigger_values).flatten.uniq
kase.disabled_steps.push(trigger_values).flatten.uniq.map(&:to_i)
kase.update! disabled_steps: kase.disabled_steps.push(trigger_values).flatten.uniq.map(&:to_i)
[].map(&:to_i)
exit
params.require(:licensing_schedules).each{|param| puts param}
params.require(:licensing_schedules).first(2)each{|param| puts param}
params.require(:licensing_schedules).first(2).each{|param| puts param}
params.require(:licensing_schedules).first(2).each{|id, param| puts param}
params.require(:licensing_schedules).first(2).each{|id, param| puts id}
exit
@errors
exit
data
x=@venture.licensing_schedules.find(schedule_id)
x.update(vencimento_planejado: parameters[:vencimento_planejado])
x.errors
exit
@errors
exit
@errors
exitexit
exit
params.require(:licensing_schedules)[:schedule_of_work]
exit
params.require(:licensing_schedules)[:schedule_of_work]
exit
schedule_of_work_params
schedule_of_work 
exit
@venture.schedule_of_work 
@venture.create_schedule_of_work(schedule_of_work_params)
schedule_of_work_params
exit
schedule_of_work_params
params(:licensing_schedules)
params.require(:licensing_schedules)
params.require(:licensing_schedules).permit(:schedule_of_work)
params.require(:licensing_schedules).permit(schedule_of_work:[])
params.require(:licensing_schedules).[:schedule_of_work]
params.require(:licensing_schedules)[:schedule_of_work]
@venture.build_schedule_of_work params.require(:licensing_schedules)[:schedule_of_work]
exit
schedule_of_work
exit
params.require(:licensing_schedules)
params.require(:licensing_schedules).permit(:schedule_of_work
)
params.require(:licensing_schedules).permit(:schedule_of_work)
params.require(:licensing_schedules).permit(schedule_of_work: {})
params.require(:licensing_schedules).permit(schedule_of_work: [])
params.require(:licensing_schedules).permit(schedule_of_work: [:data_de_inicio])
params.require(:licensing_schedules).permit(schedule_of_work: [:data_de_inicio, :data_de_conclusao])
params.require(:licensing_schedules).permit(schedule_of_work: [:data_de_inicio, :data_de_conclusao])[:schedule_of_work]
exit
schedule_of_work
schedule_of_work.errors
exit
@license
exit
next
exit
@license.renovada
@license.dup
exit
@license.renew_with_associations
@license.renew_with_associations.
end
@license.renew_with_associations
@license.renew_with_associations.conditions
@license.conditions
@license.delete
@origin.licenses
@origin.licenses.last.delete
@origin.licenses.first.update renovada = false
exit
new_license
new_license.conditions
exit
@origin.licenses
@origin.licenses.build @license.renew_with_associations 
@origin.licenses.push @license.renew_with_associations 
exit
@license.renew_with_associations
@license.renew_with_associations.save
@license.renew_with_associations.errors
@license.renew_with_associations
@license.renew_with_associations.conditions.errors
@license.renew_with_associations.conditions.map(&:errors)
[A
  end
@license.renew_with_associations.environment_programs.map(&:errors)
@license.renew_with_associations.attachments.map(&:errors)
x=@license.renew_with_associations.save
x.attachments.map(&:errors)
x=@license.renew_with_associations
x.save
x.attachments.map(&:errors)
x.environment_programs.map(&:errors)
exit
@license.renew_with_associations.save
@license.renew_with_associations.errors
x=@license.renew_with_associations
x.save
x.errors
x.conditions.first
x.conditions.first.errors
exit
@license.renew_with_associations
@license.renew_with_associations.save
@license.renew_with_associations.conditions
@license.renew_with_associations.conditions.map(&:errors)
x=@license.renew_with_associations
x.save
x.errors
x
x.condtiions
x.conditions
exit
new_license
new_license.conditions
new_license.conditions.first
exit
new_license
exit
new_license.attachments 
new_license.save
new_license.errors
new_license.environment_programs
new_license.environment_programs.errors
new_license.environment_programs.first.errors
exit
new_license.save
new_license
xit
exit
env.activities
env.activities.map(&:dup)_
env.activities.map(&:dup)
env.activities.map(&:dup).first
env.activities.map(&:dup).first.events
exit
condition.activities
condition.activities.count
condition
Condition.where(license: new_license)
Condition.where(license_id: new_license)
exit
Condition.where(origin: 'EnvironmentProgram')
Condition.where(origin_type: 'EnvironmentProgram')
Condition
Condition.where(license_id: self)
exit
whereami
new_license
exit
new_license.environment_programs
exit
new_license.environment_programs
new_license.save
new_license.errors
new_license.environment_programs.errors
new_license.environment_programs.first.errors
new_license.environment_programs.first.activities
new_license.environment_programs.first.activities.first.errors
new_license.environment_programs.first.activities[1].errors
exit
ld_activity
old_activity
activity.condition
exit
activity.condition
old_activity
old_activity.condition
old_activity.condition.activities
old_activity.condition.activities.count
exit
continue
exit
continue
exit
new_env
new_license
new_env
new_env.save
new_env.errors
new_env.activities.first.errors
new_env.activities[1].errors
exit
new_license.environment_programs
x=new_license
x.save(validate:false)
x.environment_programs
exit
x=new_license
x.save(validate:false)
x.reload
x.reload.environment_programs
x
x.reload.environment_programs
x.environment_programs
new_license.environment_programs
new_env
x.delete
exit
new_env.save
exit
new_license.environment_programs
new_license.environment_programs.activities
new_license.environment_programs.first.activities
new_license.save
new_license.attachments
new_license.reload.attachments
exit
activity.condition
activity
exit
activity
activity.conditio 
activity.conditio n
activity.condition
whereami
Activity.find_by(old_id: activity, origin_type: 'EnvironmentProgram', origin_id: env)
new_license.conditions.first.activities
new_license.conditions.map(&:activities)
new_license.conditions.map(&:activities).compact
new_license.conditions.map(&:activities).flatten
exit
new_license.conditions.map(&:activities)
exit
new_license.conditions.map(&:activities)
exit
params
exit
params
params[:origin_id].present? 
exit
env.activities.count
env
exit
new_env.activities
env.activities
env.activities.count
env.activities.where(old_id: nil).count
exit
@origin
@origin.attachments
params
exit
@attachments
exit
License.find(2)
License.find(2).update renovada: true
License.find(2)
License.find(2).update renovada: false
Venture.find(2).licenses.last.delete
Venture.find(2).licenses
License.all
License.first.venture
License.all
License.find(10).delete
License.find(11).delete
License.find(3).environemt_progems.first
License.find(3).environemt_programs.first
License.find(3).environment_programs.first
License.find(3).environment_programs.first.cities
License.find(3).environment_programs.first.environment_program_themes
License.find(12).delete
License.find(13).environment_programs
License.find(13).environment_programs.first
License.find(13).environment_programs.first.activities
License.find(13).environment_programs.first.activities.first
License.find(13).environment_programs.first.activities.first.events
License.find(13).environment_programs.first.activities.first
License.find(13).environment_programs.first.activities.first.events
License.find(13).environment_programs.first.activities.first.events.first
License.find(13).environment_programs.first.activities.first.dup
License.find(13).environment_programs.first.activities.first.dup.events
License.find(13).delete
License.find(14).delete
License.find(15).delete
License.find(16).delete
License.find(17).delete
License.find(18).delete
License.find(19).delete
License.find(20).delete
License.find(2).update renovada: false
License.find(3).update renovada: false
License.find(20).delete
License.find(21).delete
License.where('id > 20').delete_all
Activity.where('id BETWEEN 112 AND 1356').count
Activity.where('id BETWEEN 112 AND 1356').delete_all
License.where('id > 20').delete_all
License.find(50).attachments
License.where('id > 20').delete_all
EnvironmentProgram.find(4).activities
EnvironmentProgram.find(4).activities.count
License.where('id > 20').delete_all
Activity.where('id > 1467').delete_all
License.where('id > 20').delete_all
exit
@origin
@step_data
exit
@step_data
@origin
exit
License.to_expire
exit
License.to_expire
exit
AlertParameter.first
AlertParameter.first.delete
exit
10.percent_of
10.0.percent_of
exit
10.percent_of
exit
10.percent_of
10.percent_of(10)
Number
Number.new(10)
10.to_n
10.to_number
Numeric
exit
10.percent_of
10.percent_of(10)
Numeric
Numeric.new(10)
(10).percent_of(10)
Numeric
Numeric.respond_to? percent_of
Numeric.respond_to? :percent_of
Numeric.new.respond_to? :percent_of
Numeric.new.percent_of
exit
10.percent_of
class Fixnum
  def x
    puts 'a'
  end
end
10.x
class Numeric
  def xxx
    puts 'xxxxxx'
  end
end
2.000.xxx
2.xxx
(2).xxx
Numeric.ancestors
Fixnum.ancestors
1.month
1.month.to_i
1.month.xxx
Fixnum.new 1
Fixnum.new
x=Fixnum.new
x=1
x.xxx
x.x
x.percent_of
exit
Teta
x=Teta.new
number_to_percentage(10)
number_to_percentage(10, precision: 0)
number_to_percentage(, precision: 0)
exit
license.days_to_expire
exit
license.days_to_expire
AlertParameter.first.vencimento_de_licenca
license.days_to_expire / AlertParameter.first.vencimento_de_licenca * 100.0
license.days_to_expire / AlertParameter.first.vencimento_de_licenca * 100
5 / AlertParameter.first.vencimento_de_licenca * 100
(5 / AlertParameter.first.vencimento_de_licenca) * 100
(5 / AlertParameter.first.vencimento_de_licenca) * 100.0
(5 / AlertParameter.first.vencimento_de_licenca.to_i) * 100
(10 / AlertParameter.first.vencimento_de_licenca.to_i) * 100
(8 / AlertParameter.first.vencimento_de_licenca.to_i) * 100
(8.0 / AlertParameter.first.vencimento_de_licenca.to_f) * 100
(8.0 / AlertParameter.first.vencimento_de_licenca.to_f) * 100.
(8.0 / AlertParameter.first.vencimento_de_licenca.to_f) * 100
number_to_percentage(8.0 / AlertParameter.first.vencimento_de_licenca.to_f)
number_to_percentage(8 / AlertParameter.first.vencimento_de_licenca)
number_to_percentage(8.to_f / AlertParameter.first.vencimento_de_licenca.to_f)
number_to_percentage(8.to_f / AlertParameter.first.vencimento_de_licenca.to_f, precision: 0)
8.to_f / AlertParameter.first.vencimento_de_licenca.to_f *100.0
end
8.to_f / AlertParameter.first.vencimento_de_licenca.to_f * 100.0
exit
exit(number.to_f / limit.to_f * 100.0)
(number.to_f / limit.to_f * 100.0)
number.to_f / limit.to_f * 100.0
number
limit
eixt
exit
number
number.to_f / limit.to_f * 100.0
number.to_f / limit.to_f * 100.0 - 100.0
abs(number.to_f / limit.to_f * 100.0 - 100.0)
abs number.to_f / limit.to_f * 100.0 - 100.0
(number.to_f / limit.to_f * 100.0 - 100.0).abs
1 - (number.to_f / limit.to_f) * 100.0
(number.to_f / limit.to_f) * -1 * 100.0
(number.to_f / limit.to_f) - 1 * 100.0
number
limit
(number.to_f / limit.to_f) - 1 
1 - (number.to_f / limit.to_f) 
1 - (number.to_f / limit.to_f) * 100.0
(1 - (number.to_f / limit.to_f)) * 100.0
(1 - number.to_f / limit.to_f) * 100.0
exit
Venture
reload!
Venture
Venture.transferido_para
Venture.first.transferido_para
exit
@licensing_model
@licensing_phase.ordem
exit
user_params
x=user_params.delete(:password)
x
x=user_params.reject(:password)
x=user_params.except(:password)
exit
$1
$2
"01/#{$1}/#{$2}"
"01/#{$1}/#{$2}".to_date
x="01/#{$1}/#{$2}".to_date
licenses.where(expiration_date: x)
licenses.where("to_char(expiration_date, 'MM/YYYY') = #{x}")
licenses.where("to_char(expiration_date, 'MM/YYYY') = '#{x}'")
eit
exit
$1
$2
licenses.where("extract(month from expiration_date) = #{$1}")
licenses.where("extract(month from expiration_date) = '#{$1}'")
licenses.where("extract(month from expiration_date) = 9")
licenses.where("extract(month from expiration_date) = Sep")
licenses.where("extract(month from expiration_date) = 'Sep'")
licenses.where("extract(month from expiration_date) = 9")
licenses
License.last
licenses.where("extract(day from expiration_date) = 8")
licenses.where("extract(day from expiration_date) = 08")
licenses.where("extract(day from expiration_date) = '08'")
licenses.where("extract(day from expiration_date) = '8'")
licenses.where("extract(day from expiration_date) = 'Sep'")
licenses.where("extract(day from expiration_date) = 8")
exit
Date.new
Date.today
Date.today.day
Date.today.month
Date.today.month.beginning_of_month
Date.today.beginning_of_month
Date.today.end_of_month
Date.new(2014)
Date.new(2014, 10)
"09".to_I
"09".to_i
exit
number
(number.to_f / limit.to_f).abs * 100.0
exit
number
limit
1 - number.to_f / limit.to_f
(1 - number.to_f / limit.to_f) * 100.0
(1 - number.to_f / limit.to_f)
(number.to_f / limit.to_f)
(number.to_f / limit.to_f).abs
exit
UpdateEffortVentureWorker
reload!
UpdateEffortVentureWorker.perform_async
Sidekiq::Queue.new.size
Sidekiq::Queue
Sidekiq::Queue.new
Sidekiq::ScheduleSet.new
Sidekiq
Sidekiq::ProcessSet
Sidekiq::Workers
Sidekiq::Stats
require 'sidekiq/api'
Sidekiq::Queue
Sidekiq::Queue.new
Sidekiq::Queue.new.size
Sidekiq::ProcessSet.new
Sidekiq::ProcessSet.new.count
Sidekiq::Stats
Sidekiq::Stats::History
Sidekiq::Stats::History.new
Sidekiq::Stats::History.new(2)
Sidekiq::Stats::History.new(2).size
Sidekiq::Stats::History.new(2)
Sidekiq::Stats::History
Sidekiq::Stats::History.all
Sidekiq::Queue.new('infinity').clear
Sidekiq::RetrySet.new.clear
Sidekiq::ScheduledSet.new.clear
Sidekiq::ProcessSet.new.clear
Sidekiq::ProcessSet.new
Sidekiq::ProcessSet.new.clear
exit
x
x/1000
exit
x
exit
x
exit
event_params
exit
UpdateEffortVentureWorker.perform_async
reload!
UpdateEffortVentureWorker.perform_async
reload!
UpdateEffortVentureWorker.perform_async
reload!
UpdateEffortVentureWorker.perform_async
reload!
UpdateEffortVentureWorker.perform_async
reload!
UpdateEffortVentureWorker.perform_async
Venture.last
Venture.all.each {|v| v.update effort: nil, last_update_effort: nil }
Venture.last
reload!
Venture.last
UpdateEffortVentureWorker.perform_async
Venture.last
reload!
Venture.last
reload!
Venture.last
reload!
Venture.last
reload!
Venture.last
reload!
Venture.last
exit
UpdateEffortVentureWorker.perform_async
exit
Venture.last
Venture.last.effort
Venture.new
Venture.new.effort
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
@schedule_of_work
@schedule_of_work.not_need_to_be_update?
exit
@schedule_of_work.not_need_to_be_update?
@schedule_of_work
@schedule_of_work.update updated_at: Date.today-2.day
@schedule_of_work
@schedule_of_work.not_need_to_be_update?
exit
,lexit
exit
updated_at
exit
schedule_of_work_params
@schedule_of_work.update schedule_of_work_params
@schedule_of_work
@schedule_of_work.reload
@schedule_of_work.changes
exit
self
venture.last_schedule
exit
venture.last_schedule
exit
params
params[:licensing_schedules]
params[:licensing_schedules][:schedule_of_work]
params[:licensing_schedules][:schedule_of_work][:data_de_inicio]
params[:licensing_schedules].try(:[], :schedule_of_work).try(:[], :data_de_inicio)
I18n.l(params[:licensing_schedules].try(:[], :schedule_of_work).try(:[], :data_de_inicio))
I18n.l(params[:licensing_schedules].try(:[], :schedule_of_work).try(:[], :data_de_inicio).to_date)
I18n.l(params[:licensing_schedules].try(:[], :schedule_of_work).try(:[], :data_de_inicio).to_date.to_date)
exit
data_de_inicio
exit
data_de_inicio
exit
params[:licensing_schedules].try(:[], :schedule_of_work).try(:[], :data_de_inicio)
params[:licensing_schedules].try(:[], :schedule_of_work).try(:[], :data_de_inicio).present?
schedule_of_work.data_de_inicio
exit
@schedule_of_work
params
whereami
@schedule_of_work.update(schedule_of_work_params)
schedule_of_work_params
exit
eixt
exit
get path
get
visit
visit path
controller
helper
exit
include ApplicationHelper
breadcrumbs
exit
controller.request.fullpath
exit
breadcrumbs
controller
controller.request
controller.request.fullpath
exit
request
request.fullpath
exit
content_tag.class
content_tag.is_a
content_tag
content_tag().class
content_tag(:p).class
exit
content_tag
content_tag(:p)
exit
content_tag
exit
content_tag
exit
controller.request.fullpath
exit
sanitize subject
strip_tags subject
Nokogiri
x=Nokogiri::HTML(subject)
x.first
x
x.find 'ol'
x.find('ol')
x.find('ol').find('li')
x.find('ol').find('li').first
x.find('ol').find('li')
x.find('ol').find('li').document
x.find('ol').find('li').children
x.search 'li'
x.search('li').first
x.search('li').last
x.search('li').last.attribute
x.search('li').last.attribute 'href'
x.search('li a').last.
end
x.search('li a').last
x.search('li a').last.attribute('href')
exit
subject
subject.children
subject.children.blank?
subject.children
subject
subject.find 'li'
subject.search('li')
subject.search('li').blank?
subject.search('li a').blank?
subject.search('li a').last
exit
subject
subject.attribute
subject.attribute('href')
subject.text
exit
subject
subject('href')
subject.attribute('href')
subject.attribute('href').value
exit
venture.nome
exit
fullpath
exit
fullpath
Venture.find(2)
exit
fullpath
Venture.find(3)
exit
fullpath
Venture.find(4)
exit
index
resource
exit
fullpath
exit
fullpath
exit
resource_name
exit
resource_name
control
controller_name
resource_id
l+
end
exit
url_for(controller: :licensing_schedules, action: :show, id: 1)
url_for(controller: :licensing_schedules, action: :show)
url_for(controller: :licensing_schedules, action: :show, licensing_schedule_id: 1)
url_for(controller: :licensing_schedules, action: :show, licensing_schedule_id: LicensingSchedule.first.id)
url_for(controller: :licensing_schedules, action: :show, id: LicensingSchedule.first.id)
url_for(controller: :licensing_schedules, action: :show, venture_id: 1, id: LicensingSchedule.first.id)
request
request.fullpath.path
request.fullpath.url
request.new
request.fullpath
request.path
request.path = request.fullpath
request.path
whereami
url_for(controller: :licensing_schedules, action: :show, id: LicensingSchedule.first.id)
exit
url_for(controller: :licensing_schedules, action: :show, id: LicensingSchedule.first.id)
params
exit
controller.params
exit
self.activities.select(:data_inicial).order(data_inicial: :asc).limit(1)
exit
self.activities.select(:data_inicio).order(data_inicio: :asc).limit(1)
exit
first_activity
exit
first_activity
first_activity.data_inicio
exit
@import_data
errors
exit
row
exit
row
row.blank?
row.compact
row.compact.blank?
exit
request.type
request.format
request
exit
self.to_expire
self.to_expire.first.status_da_licenca
self.to_expire.first.status_da_licenca != :encerrada
self.to_expire.select{|s| s.status_code_da_licenca != :encerrada }
exit
license
license.status_code_da_licenca
whereami
license.status_code_da_licenca =! :encerrada
license.status_code_da_licenca != :encerrada
exit
whereami
exit
due_date
schedule_param
schedule_param.first
schedule_param.last
schedule_param.exit
exit
[Aexit
  due_date
due_date
due_date.first
exit
due_date
exit
venture.id
exit
venture.id
valid_attributes
next
@venture.licensing_mode
@venture.licensing_model
@venture.licensing_model.licensing_phases
@venture.licensing_model
whereami
exit
step.licensing_schedules.find_by_venture_id(@venture)
@venture.licensing_schedules
@venture.licensing_schedules.count
params
step
x=step
exit
schedule
x=step
x.licensing_schedules
x.licensing_model.licensing_phases
@venture.licensing_model.licensing_phases
@venture.licensing_model.licensing_phasesexi
exit
msg
exit
current_user
current_user.manager?
exit
ApplicationController.descendants
Rails.application.eager_load!
GroupsController.action_methods
ApplicationController.subclasses
ApplicationController.subclasses.first
ApplicationController.subclasses.first.class
ApplicationController.subclasses.first.action_methods
exit
ApplicationController.subclasses
Rails.application.eager_load!
ApplicationController.subclasses
Rails.application.eager_load!exit
ApplicationController.subclasses
ApplicationController.subclasses.reject{|c| c == DeviseController }
exit
Group.first
Group.first.permissions
Group.first.permissions << xxx: :aaa
Group.first.permissions << {xxx: :aaa}
Group.first.permissions << {'xxx' => :aaa}
Group.first.permissions = {'xxx' => :aaa}
Group.first.permissions = {xxx: :aaa}
Group.first.permissions = {xxx: :aaa, xxx: :bbb}
exit
GroupController.action_methods
GroupsController.action_methods
exit
group_params
exit
params.require(:group)
params.require(:group).permit(permissions: {})
params.require(:group).permit(permissions: [])
params.require(:group)
whereami
end
exit
group_params
return
group_params
params
return
group_params
params
exit
params.require(:group).permit(:nome, :descricao, user_ids: [], permissions: [])
params
params.require(:group).slice(:nome, :descricao, :user_ids, :permissions)
exit
Group.first
g=Group.first
exit
group_params
@group
@group.update group_params
group_params.except(:descricao)
@group.update group_params.except(:descricao)
@group.update group_params.except(:descricao, :nome)
@group.update group_params.except(:descricao, :nome, :user_ids)
@group.update group_params.except(:descricao, :nome, :user_ids).to_hash
group_params
group_params.to_hash
exit
GroupsController.actions_methods
GroupsController.actions_method
GroupsController.action_methods
ActivitiesEventsController
ActivitiesEventsController.action_methods
exit
controller_name
action
action_name
controller_path
controller
controller_name
controller_name.camelize
whereami
"#{controller_name.camelize}Controller:#{action_name}"
authorize
authorize "#{controller_name.camelize}Controller:#{action_name}"
authorize controller_name.camelize
authorize controller_name.singularize.camelize
authorize controller_name.singularize
authorize controller_name.singularize.camelize
exit
eixt
exit
$1
@record.class
@record.class.name
controller_name
exit
permissions
permissions.flatten
permissions.flatten.compact
permissions.flatten.compact.keys
permissions.flatten.compact.keysexit
exit
permissions
exit
group
group.permissions
permissions.merge group.permissions
permissions
permissions.merge(group.permissions)
permissionsexit
exit
raise
exit
exit 
raise Exception
exit
permissions
exit
permissions
permissions.merge! group.permissions
permissions
permissions.compact
permissions.keys
permissions.keys.include? 'xxx'
permissions.keys.include? 'VenturesController:show'
@user.groups.map{|g| g.permissions.keys }
@user.groups.map{|g| g.permissions.keys }.flatten
exit
@scope
@recourse
@record
@record.class
@record.to_s
@record.name
@record.name.camelize
exit
"#{@record.name}:#{$1}"
exit
Group.first
Group.first.update permissions: Group.first.permissions.merge('VenturesController:index' => "true")
Group.first
exit
authorize controller_name.singularize.camelize.constantize
exit
authorize controller_name.singularize.camelize.constantize
exit
ApplicationPolicy.new current_user, controller_name.singularize.camelize.constantize
x=ApplicationPolicy.new current_user, controller_name.singularize.camelize.constantize
x.send("#{action_name}?")
authorize nil, :index?, policy: ApplicationPolicy
authorize nil, policy: ApplicationPolicy
authorize ApplicationPolicy
authorize Application
exit
Group.first
Group.first.update permissions: Group.first.permissions.merge('GroupsController:index' => "true")
Group.first.update permissions: Group.first.permissions.merge('GroupsController:edit' => "true")
Group.first.update permissions: Group.first.permissions.merge('GroupsController:update' => "true")
Group.first
exit
controller_name
current_user
try(:current_user)
exit
helpers
helpers.available_controllers
helper.available_controllers
helper.available_controllers.map{|c| available_actions_for_controller(c) }
helper.available_controllers.map{|c| helper.available_actions_for_controller(c) }
helper.available_controllers.map{|c| p helper.available_actions_for_controller(c) }; nil
helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| "#{c.name}:#{a}" } }; nil
helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| p "#{c.name}:#{a}" } }; nil
reload!
helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| p "#{c.name}:#{a}" } }; nil
exit
helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| p "#{c.name}:#{a}" } }; nil
reload!
helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| p "#{c.name}:#{a}" } }; nil
exit
helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| p "#{c.name}:#{a}" } }; nil
f=File.new('xxx', 'w'); helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| f.write("#{c.name}:#{a}") } }; f.close; nil
f=File.new('xxx', 'w'); helper.available_controllers.map{|c| helper.available_actions_for_controller(c).map{|a| f.write("#{c.name}:#{a}\n") } }; f.close; nil
exit
get :show
responde.body
response.body
get :show, {}, valid_session
response.body
get :show, {}, valid_session
exit
model = controller_name.singularize.camelize.constantize
model
ApplicationPolicy.new(current_user, model).send("#{action_name}?")
current_user
current_user.groups
current_user.groups.first
whereami
action+_name
action_name
current_user.groups.first.permissions
current_user.groups.first.permissions.keys
exit
model = controller_name.singularize.camelize.constantize
ApplicationPolicy.new(current_user, model).send("#{action_name}?")
exit
Group.first
Group.first.permissions
Group.first.permissions.create controller: "GroupsController", action: :update
exit
user_activities
$1
user_activities.include?({controller: "#{@record.name.pluralize}Controller", action: $1})
"#{@record.name.pluralize}Controller"
.include?({controller: "#{@record.name.pluralize}Controller", action: $1})
user_activities.select {|p| p.controller == "#{@record.name.pluralize}Controller" and p.action == $1}
exit
params.require(:group).slice(:permissions).map{|p| param=p.slip(':') }
params.require(:group).slice(:permissions)
params.require(:group).permissions
params.require(:group)[:permissions]
params.require(:group)[:permissions].map{|p| p.key }
params.require(:group)[:permissions].map{|p| p }
params.require(:group)[:permissions].map{|p, y| p }
params.require(:group)[:permissions].map{|p, y| y }
params.require(:group)[:permissions].map{|p, y| p.split(':') }
exit
params.require(:group)[:permissions].map do |permission, value|
  param = permission.split(':')
  {controller: param.first, action: param.last}
end
x=_
@group.permissions = x
@group.update permissions_attributes: x
@group.update permission_attributes: x
@group.update permissions_attribute: x
@group.update permissions_attributes: [x]
exit
params.require(:group)[:permissions].map do |permission, value|
  param = permission.split(':')
  {controller: param.first, action: param.last}
end
x=_
@group.update permissions_attributes: [x]
@group.update permissions_attributes: x
exit
Group.first.permissions.create controller: "GroupsController", action: :update
Group.where(nome: 'Administradores').delete_all
Group.first.permissions.create controller: "GroupsController", action: :update
{a: 1} + {b: 2}
{a: 1}.merge {b: 2}
{a: 1}.merge({b: 2})
Group.first.permissions.create controller: "GroupsController", action: :update
exit
permissions
permissions.where(new: false).delete_all
permissions.where(new: true).update(new: false)
permissions.where(new: true).update(:new, false)
permissions.where(new: true).update(new: false)
permissions.where(new: true).update(:all, new: false)
permissions.where(new: true).update(new: false)
permissions.where(new: true).update_all(new: false)
exit
Group.first.permissions.create controller: "GroupsController", action: :update
Group.first.permissions
Group.first
Group.first.permissions
Group.first.permissions.create controller: "GroupsController", action: :update
Group.first.permissions
Group.first.permissions.count
Group.first.permissions.where(controller: 'VenturesController')
Group.first.permissions.create controller: "GroupsController", action: :update
Group.first.permissions
Group.first.permissions.first.new
Group.where(nome: 'Administradores').delete_all
"123456".first
Group.first.permissions.delete_all
Group.first.permissions.create controller: "GroupsController", action: :update
Group.first.permissions
exit
@user
@user.groups
@user.groups.permissions
@user.groups.first
@user.groups.first.permissions
@user.groups.first.permissions.county
@user.groups.first.permissions.count
@user.groups.first.permissions.size
@user.groups.map{|g| g.permissions }
x=_
x.select{|a| a.controller == 'VenturesController' and a.action == 'efforts' }
x.first
x.flatten
x.flatten!
x.select{|a| a.controller == 'VenturesController' and a.action == 'efforts' }
x.select{|a| a.controller == 'VenturesController' and a.action == 'efforts' }.present?
exit
x=@user.groups.map{|g| g.permissions }.flatten
x.select{|a| a.controller == 'VenturesController' and a.action == 'efforts' }.present?
exit
x=@user.groups.map{|g| g.permissions }.flatten
x.select{|a| a.controller == 'VenturesController' and a.action == 'efforts' }.present?
exit
@record
@record.to_s
@record.class
exit
@controller
exit
controller_name
controller = "#{controller_name}_controller".camelize.constantize
authorize controller
exit
controller = "#{controller_name}_controller".camelize.constantize
authorize controller
controller.respond_to?(:model_name)
controller.class.respond_to?(:model_name)
controller.is_a? Class
controller.to_s.classify
exit
name
exit
controller = "#{controller_name}_controller".camelize.constantize
authorize controller
name
find_permissions($1)
Pundit::PolicyFinder
Pundit::PolicyFinder.new(@controller)
Pundit::PolicyFinder.new(@controller).policy
x=_
x.new(@user, @controller)
x.new(@user, @controller).public_send(:new?)
exit
@user
@user.groups
@user.groups.first
@user.groups.first.permissions.where(controller: 'StepDataController')
@user.groups.first.permissions.where(controller: 'StepDataController').size
@user.groups.first.permissions.where(controller: 'StepDataController', action: 'new')
@user.groups.first.permissions.where(controller: 'StepDataController', action: 'create')
find_permissions(:new)
@user.groups.first.permissions.where(controller: 'StepDataController')
@user.groups.first.permissions.where(controller: 'StepDataController', action: 'create')
@user.groups.first.permissions.where(controller: 'StepDataController', action: 'new')
@user.groups.first.permissions.where(controller: 'StepDataController')
@user.groups.first.permissions.where(controller: 'StepDataController').pluck(:action)
StepData.exit
exit
name
find_permission($1)
@user.groups.first
@user.groups.first.permissions.where(controller: @controller)
@user.groups.first.permissions.where(controller: @controller).pluck(:action)
exit
params[:group].try(:[], :permission).blank?
params[:group].try(:[], :permissions).blank?
exit
exitexit
exit
exirt
exit
Group.permissions.where(controller: 'StepDataController')
Group.first.permissions.where(controller: 'StepDataController')
Group.first.permissions.where(controller: 'StepDataController').pluck(:action)
Group.first
Group.first.permissions.where(controller: 'StepDataController').pluck(:action)
exit
name
options
url
url.class
ActionController::Routing::Routes.recognize_path url
Rails.application.routes.recognize_path url
exit
controller
action
authorize controller
policy
policy(controller)
policy(controller).send("#{action}?")
exit
url
identified_url
verify_authorization?(identified_url[:controller], identified_url[:action])
policy(identified_url[:controller])
policy(VenturesController)
ApplicationPolicy.new(current_user, VenturesController)
ApplicationPolicy.new(current_user, VenturesController).new?
ApplicationPolicy.new(current_user, VenturesController).send("#{identified_url[:action]}?")
exit
Group
Group.where(nome: 'Administradores').delete_all
Group.first.permissions.where(controller: 'VenturesController')
Group.first.permissions.where(controller: 'VenturesController').pluck(:action)
exit
url
name
block
&block
capture &block
exit
capture &block
exit
capture &block
exit
capture &block
exit
capture &block
exit
capture &block
url
identified_url
exit
identified_url
exit
controller
action
exit
Group.first.permissions.where(controller: 'GeneralSchedulesController')
exit
identified_url
options
exit
identified_url
options
html_options
html_options['data-method']
exit
html_options
verify_authorization?(identified_url[:controller], identified_url[:action])
content_tag(:a, name || url, html_options, &block)
exit
verify_authorization?(identified_url[:controller], identified_url[:action])
content_tag(:a, name || url, html_options, &block)
exit
html_options
verify_authorization?(identified_url[:controller], identified_url[:action])
exit
html_options
verify_authorization?(identified_url[:controller], identified_url[:action])
content_tag(:a, name || url, html_options, &block)
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
html_options[:data]
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
html_options
exit
name
exit
name
exit
name
exit
name
exit
name
capture(&block)
html_options
html_options['data']
html_options['data']['skip_permission']
exit
capture(&block)
link_to_skip_permission?(html_options) 
html_options['data']['skip_permission']
html_options.try(:[], 'data').present?
html_options.['data']['skip_permission'].present?
html_options['data']['skip_permission'].present?
exit
@eventual_requirement
@eventual_requirement.renovada
exit
self.eventual_requirement_grant
self.eventual_requirement_auth
exit
self.eventual_requirement_type
self.eventual_requirement_type.type_of_form_requirement
self.eventual_requirement_type.type_of_form_requirement.code
self.eventual_requirement_type.type_of_form_requirement.code == :authorization
new_eventual_requirement.delete
exit
EventualRequirement.find(7)
EventualRequirement.find(11).delete
EventualRequirement.find(12).delete
EventualRequirement.find(13)
EventualRequirement.find(13).eventual_requirement_grant
EventualRequirement.find(13).eventual_requirement_auth
EventualRequirement.find(13).delete
exit
@condition
@condition.import?
@condition
@condition.import_data
whereami
@condition.import_data.sizr
@condition.import_data.size
exit
cond
date
exit
date
exit
date
exit
date
exit
date
exit
date
exit
LicensingSchedule.find(37)
exit
venture.licensing_schedules.map(&:vencimento_planejado)
venture.licensing_schedules.available.map(&:vencimento_planejado)
venture.licensing_schedules.availables.map(&:vencimento_planejado)
venture.licensing_schedules.available
exit
venture.licensing_schedules.accessible
venture.licensing_schedules.accessible.map(&:vencimento_planejado)
venture.licensing_schedules.accessible
LicensingStep.find(6)
LicensingSchedule.find(24)
exit
venture.licensing_schedules.accessible
venture.licensing_schedules.accessible.map(&:vencimento_planejado)
exit
Venture.find(3).licensing_schedules
Venture.find(3).licensing_schedules.find(21)
Venture.find(3).licensing_schedules.accessible
exit
EventualRequirement.find(5)
EventualRequirement.find(6)
EventualRequirement.find(6).update data_de_vencimento: EventualRequirement.find(6).data_de_emissao
exit
type
params.require(:eventual_requirement)
params.require(:eventual_requirement)exit
exit
params
params.permit(:eventual_requirement_type_code)
params.permit(:eventual_requirement_type_code
  end
exit
data_de_emissao
exit
params.require(:licensing_schedules).first
params.require(:licensing_schedules)
params.require(:licensing_schedules)['0']
params.require(:licensing_schedules).first
exit
licensing_schedule_venture_params
@venture.update(licensing_schedule_venture_params)
@venture.errors
@venture.errors[:data_inicial_da_etapa]
@venture.errors.messages
@venture.errors.messages[:data_inicial_da_etapa]
@venture.errors.messages[:data_inicial_da_etapa].to_s
exit
licensing_schedule_venture_params
@venture.errors
@venture.errors.messages
@venture.data_inicial_da_etapa
exit
@activity_events
@activities_events
@origin
exit
@group
@group.permissions
@group.valid?
@group.errors
exit
@group.valid?
exit
errors
exit
LicensingSchedule.find(14).licensing_step
LicensingSchedule.find(14).licensing_step.attachment_types
LicensingSchedule.find(14).licensing_step
exit
@schedule
@schedule.step_date
@schedule.step_data
@schedule.licenses
@schedule
exit
@schedule.licensing_step
exit
before_phase
programs
before_phase.license(@schedule.venture)
ixt
exit
programs
before_phase
before_phase.licensing_steps
before_phase.licensing_steps.select{|s| s.programa_ambiental }
before_phase.licensing_steps.select{|s| s.programa_ambiental }.first
before_phase.licensing_steps.select{|s| s.programa_ambiental }.first.licensing_schedules.find_by_venture_id(@venture).step_data
before_phase.licensing_steps.select{|s| s.programa_ambiental }.first.licensing_schedules.find_by_venture_id(@venture)
before_phase.licensing_steps.select{|s| s.programa_ambiental }.first.licensing_schedules.find_by_venture_id(venture)
whereami
@venture
before_phase.licensing_steps.select{|s| s.programa_ambiental }.first.licensing_schedules.find_by_venture_id(@schedule.venture)
before_phase.licensing_steps.select{|s| s.programa_ambiental }.first.licensing_schedules.find_by_venture_id(@schedule.venture).step_data
before_phase.licensing_steps.select{|s| s.programa_ambiental }.first.licensing_schedules.find_by_venture_id(@schedule.venture).step_data.licenses
before_phase.licensing_steps.select{|s| s.programa_ambiental }.last.licensing_schedules.find_by_venture_id(@schedule.venture).step_data.licenses
before_phase.licensing_steps.select{|s| s.programa_ambiental }.last.licensing_schedules.find_by_venture_id(@schedule.venture).step_data.licenses.recents.first
before_phase.licensing_steps.select{|s| s.programa_ambiental }.last.licensing_schedules.find_by_venture_id(@schedule.venture).step_data.licenses.recents.first.environment_programs
exit
step_data
step_data.licenses
exit
step_data
step_data.licenses
licensing_step
step_data.licenses.available
step_data.licenses.available.recents
exit
before_phase.license(@schedule.venture)
exit
@eventual_requirement.valid?
@eventual_requirement.errors
exit
renovada
data_de_vencimento
data_de_emissao
exit
EnvironmentProgram.last
EnvironmentProgram.last.activities
EnvironmentProgram.last.activities.pluck(:numero)
EnvironmentProgram.find(5).activities
EnvironmentProgram.find(5).activities.pluck(:numero)
EnvironmentProgram.find(5).activities.pluck(:numero).map { |n| n.split('.') }
EnvironmentProgram.find(5).activities.pluck(:numero).map { |n| n.split('.').map(&:to_i) }
EnvironmentProgram.find(5).activities.pluck(:numero).map { |completo| completo.split('.').map{|numero| numero.gsub(/[^0-9]+/, '').to_i  }
  end
EnvironmentProgram.find(5).activities.pluck(:numero).map { |completo| completo.split('.').map{|numero| numero.gsub(/[^0-9]+/, '').to_i } }
EnvironmentProgram.find(5).activities.pluck(:numero)
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '') }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').to_i }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').to_f }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').to_d }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').to_b }
10.to_bn
10.to_c
10.to_r
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').to_c }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '') }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i).join('.') }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '') }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i).join('.') }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i).join('.') }.sort { |a,b| b <=> a }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i).join('.') }.sort { |a,b| a <=> b }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }
x=0
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort {|a,b| a[x].to_i <=> b[x].to_i }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort {|a,b| a[x].to_i <=> b[x].to_i }.map {|a| a.join('.')
  end
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort {|a,b| a[x].to_i <=> b[x].to_i }.map {|a| a.join('.') }
x=[]
x[1]
x[1].to_i
x=[2]
x[0].to_i
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort {|a,b| b[x].to_i <=> a[x].to_i }.map {|a| a.join('.') }
x=0
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort {|a,b| b[x].to_i <=> a[x].to_i }.map {|a| a.join('.') }
x=-1
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort {|a,b| x+= 1; b[x].to_i <=> a[x].to_i }.map {|a| a.join('.') }
x
result = EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }
result = EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort_by(:size)
result = EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort_by{|x| x.size }
result = EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort_by{|x| x.size }.reverse
cols = result.first
cols = result.first.size
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').map(&:to_i) }.sort {|a,b| x+= 1; b[x].to_i <=> a[x].to_i }.map {|a| a.join('.') }
EnvironmentProgram.find(5).activities.pluck(:numero).map {|completo| completo.gsub(/[^0-9\.]+/, '').split('.').resize(cols).map{|n| n.to_i}.join.to_i }.sort {|a,b| b <=> a }
cols
[].resize(4)
[].fill(0, -1, 4)
[1,2,3].fill(0, -1, 4)
[1,2,3].fill(0, -1, 3)
[1,2,3].fill(0, -1, [1,2,3].size - 4)
[1,2,3].fill(0, -1, ([1,2,3].size - 4).abs)
[1,2,3].fill(0, -1, 1)
[1,2,3].fill(0, -1, 2)
[1,2,3].fill(0, 0,1)
Array.new(3)
Array.new(3, 1)
Array.new([1,2], 3)
Array.new(3, 0, [1,2])
Array.new(3, 0,)
Array.new(3, 0)
Array.new(cols, 0)
Array.new(cols, 0) + [1,2]
x=[1,2]
Array.new(9){|index| x[index].to_i }
Array.new(9){|index| x[index].to_i }.join
Array.new(9){|index| x[index].to_i }.join.to_i
exit
Activity.all
reload!
Activity.all
reload!
Activity.all
reload!
Activity.all
reload!
Activity.all
reload!
Activity.all
reload!
helper
exit
cols
cols.first
cols.last
cols.last.size
exit
cols
exit
@activities_events
exit
@activities_events
exit
record.order_number
number_splited
exit
record.order_number
exit
result
result.first
result.first.order_number
result.sort_by{|line| line.order_number.first }
result.sort_by{|line| line.order_number.first }.map(&:order_number)
result.sort_by{|line| line.order_number[0] }.map(&:order_number)
exit
result
result.sort_by{|line| line.order_number[0] }.map(&:order_number)
result.map(&:order_number)
exit
result.map(&:order_number)
exit
result.map(&:order_number)
exit
result.map(&:order_number)
exit
@origin.activities.order_by_number
@origin.activities.new.order_by_number
exit
Activity.new.order_by_numeric
Activity.new.order_by_number
Activity.new.order_by_number(:x)
exit
Activity.order_by_number(:x)
exit
Activity.order_by_number
Activity.order_by_number(:x)
self
self.pluck(:numero)
exit
Activity.order_by_number(:x)
Activity.order_by_number(:numero)
exit
Activity.order_by_number(:numero)
exit
Activity.order_by_number(:numero)
cols
self._order_number
exit
self._order_number
exit
Activity.order_by_number(:numero)
self.new._order_number
self.new._order_number= 1
exit
whereami
exit
x
x.sort
x.sort { |a, b| a <= b }
x.sort { |a, b| a <=> b }
exit
available_controllers_by_group
exit
available_controllers_by_group
exit
available_controllers_by_group
available_controllers_by_group.first
available_controllers_by_group.each{|x| puts x};nil
available_controllers_by_group.keys.each{|x| puts x};nil
exit
scope
Scope.resolve
exit
controller
controller.to_s
controller.name
controller.name.underscore
exit
controller
@controller
controller = controller.to_s
exit
controller
control_underscore = controller.name.underscore
NEED_REPLACED.keys.include? control_underscore
exit
helper
helper.available_controllers
helper.available_controllers_by_group
c1=helper.available_controllers
c2helper.available_controllers_by_group
c2=helper.available_controllers_by_group
c2.to_a
c2
c3=[]
c2.first
c2.first.last
c3.push c2.first.last
c3.push c2.second.last
c2.second
c2[2]
c2.last
c2
c2[:institutions]
c3.push c2[:institutions]
c3.push c2[:env_licensing_process]
c3
c3.flatten
c3.flatten!
c3
c1
c3
c3 - c1
c1 -c3
'attachments_controller'
'attachments_controller'.camelize
'attachments_controller'.camelize.constantize
'attachments_controller'.constantize
exit
self.all
whereami
value
self.where('unaccent(document_file_name) ilike unaccent(:search)', search: value)
self.where('unaccent(document_file_name) ilike unaccent(:search)', search: 'FileZilla')
self.first
self.where('unaccent(document_file_name) ilike unaccent("FileZilla")')
self.where("unaccent(document_file_name) ilike unaccent('FileZilla')")
self.where("unaccent(document_file_name) like unaccent('FileZilla')")
self.where("unaccent(document_file_name) ilike unaccent('FileZilla')")
exit
Attachment.count
Attachment.first
Attachment.first.documento
Attachment.first.document
Attachment.first.document.nome
Attachment.first.document.name
Attachment.first.document.file
Attachment.first.document.full_name
Attachment.first.document
p Attachment.first.document
puts Attachment.first.document
puts Attachment.first.to_sql
Attachment.first.numero
Attachment.first.update numero: 123
Attachment.second.update numero: 123
Attachment.all.second.update numero: 123
Attachment.all.second.update numero: 234
Attachment.all.second
Attachment.all.last.update numero: 345
exit
filter
filter.class
exit
filter.class
exit
filter.class
filter.name
filter.class.nam
filter.class.name
filter.class.name.camelize
filter.class.to_s
filter.class
filter.class.namespace
filter.class.namespace_name
filter.class.deconstantize
filter.class.name.deconstantize
filter.class.name
filter.class.name.demodulize
filter.class.name.demodulize.underscore
exit
@attachments
@attachments.data
@attachments
exit
@attachments = AttachmentsGrid.new(params[:attachments_grid]) 
@attachments
@attachments.data
@attachments.rows
@attachments.header
@attachments.header + @attachments.rows
[@attachments.header] + @attachments.rows
([@attachments.header] + @attachments.rows).to_csv
[@attachments.header] + @attachments.rows
exit
result
exit
Attachment.where(origin_type: 'EventualRequirement')
Attachment.where(origin_type: 'EventualRequirement').map(&:eventual_requirement)
Attachment.where(origin_type: 'EventualRequirement').map(&:origin)
Attachment.where(origin_type: 'EventualRequirement').map(&:origin).compact
Attachment.where(origin_type: 'EventualRequirement').map(&:origin).compact.map(&:licensing_schedule)
exit
ReportAttachment
ReportAttachment.all
exit
whereami
attachment_params[:sent_received]
exit
attachment_params[:sent_received]
exit
venture.actual_step.licensing_schedules
venture.actual_step.licensing_schedules.first.step_data
exit
schedule
schedule.step_data
schedule
schedule.licensing_step.licensing_phase
self
exit
step_data
exit
venture.actual_phase.license(venture)
venture.licensing_schedules
venture.licensing_schedules.accessible
venture.actual_phase.licensing_steps
venture.actual_phase.licensing_steps.reverse
venture.actual_phase.licensing_steps.reverse.map{|s| s.licensing_schedules.accessible.find_by_venture_id(venture) }
venture.actual_phase.licensing_steps.reverse.map{|s| s.licensing_schedules.accessible.find_by_venture_id(venture).step_data }
venture.actual_phase.licensing_steps.first
exit
helper
helper.available_controllers_by_group
helper.available_controllers_by_group.values
helper.available_controllers_by_group.values.flatten
exit
License.find(1).status_code
License.find(1).status_code_da_licenca
ActiveRecord::Base.log = nil
ActiveRecord::Base.logger = nil
License.find(1).status_code_da_licenca
License.find(2).status_code_da_licenca
License.find(3).status_code_da_licenca
License.find(4).status_code_da_licenca
License.find(5).status_code_da_licenca
exit
ReportLicense
exit
ReportLicense
reload!
ReportLicense
exit
ReportLicense
ReportLicense.first
ReportLicense.first.cities
reload!
ReportLicense.first.cities
exit
City.first
City.includes(:states)
City.includes(:state)
City.includes(:state).pluck(:name)
City.includes(:state).pluck(:name, :symbol)
City.includes(:state).pluck(:name, :symbol).map{|value| value.join(' - ') ]
City.includes(:state).pluck(:name, :symbol).map{|value| value.join(' - ') }
exit
license
exit
ReportLicense.first
ReportLicense.first.status
exit
ReportLicense.first.status
exit
attachments
attachments.first
attachments.last
attachments.to_sql
exit
attachments
attachments.to_sql
exit
attachment_params
exit
attachments.to_sql
exit
%w{daniela nathalia}.shuffle.first
exit
(column_names - ['id'])
emp.attributes.values_at(*(column_names - ['id'])) 
exit
emp.attributes.values_at(*(column_names - ['id'])) 
exit
emp.attributes.values_at(*(column_names - ['id'])) 
exit
License.recents.first
License.recents.second
reload!
License.recents.first
License.all.first
License.all.second
License.all.pluck(:started_at)
License.all.pluck(:id, :started_at)
exit
License.to_expire
License.to_expire.count
License.to_expiring
exit
license_params
license_params[:alerts]
exit
ReportLicense
ReportLicense.where('alerts ilike "Sem Alerta"')
ReportLicense.where('alerts = "Sem Alerta"')
ReportLicense.where(alerts: "Sem Alerta")
ReportLicense.where("alerts = 'Sem Alerta'")
ReportLicense.where("alerts ilike 'Sem Alerta'")
ReportLicense.where("alerts ilike 'Alerta%'")
exit
params
params[:format]
params[:format] =! 'xls'
params[:format] != 'xls'
exit
ReportLicense
ReportLicense.first
ReportLicense.first.watersheds
exit
subject
subject.watersheds
license.venture.watersheds
exit
subject
ReportLicense.first
exit
license.days_to_expire
AlertParameter.first.vencimento_de_licenca_alerta_vermelho
License.to_expiring
license.status_code_da_licenca
license.renovada
license
exit
license
exit
license.days_to_expire <= AlertParameter.first.vencimento_de_licenca_alerta_vermelho 
License.to_expiring.include?(license) 
License.to_expiring
License.to_expire
exit
License.to_expiring
License.to_expire
license
License.all
license
Date.today + AlertParameter.first.vencimento_de_licenca.days
exit
params.require(:eventual_requirement).permit(:data_do_encerramento)
@eventual_requirement.update(params.require(:eventual_requirement).permit(:data_do_encerramento))
@eventual_requirement.errors
exit
new_auth
eventual_requirement_auth
new_auth
new_auth.valid?
new_auth.errors
exit
EventualRequirement.find(33)
EventualRequirement.find(41)
EventualRequirement.find(41).eventual_requirement_auth
EventualRequirement.find(41).eventual_requirement_type.type_of_form_requirement.code
EventualRequirement.find(33).eventual_requirement_auth
EventualRequirement.find(33).eventual_requirement_auth.dup
EventualRequirement.find(41).delete
EventualRequirement.find(33).renovada
exit
Configuration
::Configuration
::Configuration.language
exit
Rails.cache
exit
subject
reponse.body
last_response
response
reponse.body
response.body
exit!
response.body
exit
exit!
EventualRequirement.find(45).updare renovada: false
EventualRequirement.find(45).update renovada: false
EventualRequirement.find(45)
EventualRequirement.find(45).update data_do_encerramento: Date.today
EventualRequirement.find(33)
EventualRequirement.find(33).update renovada: false
exit
Venture.find(2)
Venture.find(2).venture.execution_type
Venture.find(2).venture_execution_type
Venture.last.venture_execution_type
Venture.last
reload!
ReportLicense.all
ReportLicense.pluck(:venture_execution_type)
Venture.last.venture_execution_type
Venture.last
exit
@eventual_requirement
exit
EventualRequirement.find(45)
EventualRequirement.find(45).status_code
EventualRequirement.find(45).status
EventualRequirement.find(45)
exit
user
user.authenticate(params[:password])
user.errors
User.last
User.last.password
User.last.update password: 'xxxxxx', password_confirmation: 'xxxxxx'
User.last.password
exit
exitexit
exit
params
user.authenticate(params[:password])
exit
subject
exit!
self.assigment
assignment
assignment.moderator
exit!
subject
exit!
attrs
name
exit
config
exit
json_response
response.body
reference_time.to_s
Submission.count
Submission.pluck(:created_from)
exit!
exception
exit
config
config.language
exit
confi
config
config.language
config.language?
config.language
config.timezone
exit
json_response
exit
Rails.cache.count
Rails.cache
Rails.cache.size
Submission.all
Assignment.all
Rails.cache.delete_all
Rails.cache
Rails.cache.clear
exit
next
json_response
Log.all
Submission.count
Submission.all
exit!
json_response
User.last
User.first
exit
json_response
submission.first
submissions.first
submissions.first.user
exit
json_response
submissions.first
submissions.first.user
submissions.first.user.id
json_response['successful_imports']['1'][1]
exit
EventualRequirement.all.select{|e| e.eventual_requirement_grant.present? || e.eventual_requirement_auth.present?}
EventualRequirement.all.select{|e| e.eventual_requirement_grant.present? || e.eventual_requirement_auth.present?}.update data_do_encerramento: nil
EventualRequirement.all.select{|e| e.eventual_requirement_grant.present? || e.eventual_requirement_auth.present?}.update_all data_do_encerramento: nil
EventualRequirement.all.select{|e| e.eventual_requirement_grant.present? || e.eventual_requirement_auth.present?}
EventualRequirement.all.select{|e| e.eventual_requirement_grant.present? || e.eventual_requirement_auth.present?}.count
EventualRequirement.all.select{|e| e.eventual_requirement_grant.present? || e.eventual_requirement_auth.present?}.each {|e| e.update data_do_encerramento: nil }
exit
@eventual_requirement.status
@eventual_requirement
whereami
@eventual_requirement.update(data_do_encerramento: Date.today) 
@eventual_requirement.update(data_do_encerramento: Date.
  exit
params
exit
params
exit
params
exit
params
exit
ReportEventualRequirementsDatatable.new(view_context).as_table
ReportEventualRequirement.all.to_csv
ReportEventualRequirement..to_csv
ReportEventualRequirement.to_csv
exit
ReportEventualRequirement
ReportEventualRequirement.to_csv
ReportEventualRequirement.all.to_csv
exit
label
exit
e=EventualRequirement.find(50)
e.data_de_emissao = nil
e.data_de_vencimento = nil
e.save
UpdateEffortVentureWorker
UpdateEffortVentureWorker.perform_async
exit
YoutubeProfile.first
YoutubeProfile.first.refresh_channels
exit
YoutubeProfile
YoutubeProfile.first
YoutubeProfile.first.refresh_channels
exit
YoutubeProfile.first.refresh_channels
exit
YoutubeProfile.first.refresh_channels
YoutubeProfile.count
exit
YoutubeChannel.first.refresh_videos
exit!
YoutubeChannel.first.refresh_videos
exit!
YoutubeChannel.first.refresh_videos
exit!
YoutubeChannel.first.refresh_videos
exit
YoutubeVideo
YoutubeVideo.first
exit!
ENV=['date_from']
ENV
ENV['date_from']
YoutubeVideo.first
'2014-12-28'.to_date
'28/12/2014'.to_date
exit
ENV['date_from'].to_date
ENV['date_from'].try(:to_date)
ENV['date_xfrom'].try(:to_date)
exit
YoutubeVideo.first
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date).to_s, ENV['DATE_TO'].try(:to_date).to_s)
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
puts ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date)
ENV['DATE_FROM'].try(:to_date).strftime('%Y-%m-%d')
ENV['DATE_TO'].try(:to_date).strftime('%Y-%m-%d')
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
exit!
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
date_from
date_to
self.published_at
self.metrics.order('captured_at DESC').first
exit!
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
date_from
self.metrics.order('captured_at DESC').first
last_captured_metric.captured_at
exit!
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
date_from
date_to
date_from.nil?
next
exit!
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
exit!
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
exit!
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
exit!
YoutubeVideo.first.capture_metrics(ENV['DATE_FROM'].try(:to_date), ENV['DATE_TO'].try(:to_date))
exit!
InstagramProfile.first
InstagramMedia.count
exit
DemandOfEventualRequirement.count
DemandOfEventualRequirement.map{|d| d.eventual_requirement }
DemandOfEventualRequirement.all.map{|d| d.eventual_requirement }
DemandOfEventualRequirement.all.select {|d| d.eventual_requirement.nil? }
ds=DemandOfEventualRequirement.all.select {|d| d.eventual_requirement.nil? }
ds.update_all eventual_requirement_id: EventualRequirement.last.id
ds.each {|d| d.update eventual_requirement_id: EventualRequirement.last.id }
DemandOfEventualRequirement.all.select {|d| d.eventual_requirement.nil? }
ds.each {|d| d.update eventual_requirement_id: EventualRequirement.last.id }
ds.each {|d| d.update(eventual_requirement_id: EventualRequirement.last.id) }; nil
ActiveRecord::Base.logger = nil
ds.each {|d| d.update(eventual_requirement_id: EventualRequirement.last.id) }; nil
ds.first
ds.first.eventual_requirement
ds=DemandOfEventualRequirement.all.select {|d| d.eventual_requirement.nil? }
ds.first.eventual_requirement
ds.each {|d| d.update(eventual_requirement_id: EventualRequirement.last.id) }; nil
ds=DemandOfEventualRequirement.all.select {|d| d.eventual_requirement.nil? }
ds.first.eventual_requirement
ds.first.update eventual_requirement_id: EventualRequirement.last.id
ds.first.errors
ds
ds=DemandOfEventualRequirement.all.select {|d| d.eventual_requirement.nil? }
ds.each {|d| d.eventual_requirement_id=EventualRequirement.last.id; d.save(validate:false) }; nil
ds=DemandOfEventualRequirement.all.select {|d| d.eventual_requirement.nil? }
exit
InstagramMetric.metric_join_media_and_profiles
InstagramMetric.metric_join_media_and_profiles.count
InstagramMetric.metric_join_media_and_profiles
exit!
InstagramMetric.metric_join_media_and_profiles
InstagramMetric.metric_join_media_and_profiles.first
exit!
InstagramMetric.metric_join_media_and_profiles.first
InstagramMetric.metric_join_media_and_profiles
InstagramMetric.metric_join_media_and_profiles.first
exit!
InstagramMetric.metric_join_media_and_profiles
InstagramMetric.metric_join_media_and_profiles.first
InstagramMetric.metric_join_media_and_profiles.to_sql
exit!
InstagramMetric.metric_join_media_and_profiles
InstagramMetric.metric_by_comments
InstagramMetric.metric_by_comments.first
InstagramMetric.metric_by_comments.first.total
exit
InstagramMetric.metric_by_comments
InstagramMetric.metric_by_comments.first
exit!
InstagramMetric.metric_by_comments.first
exit
InstagramMetric.metric_by_comments.first
exit
InstagramMetric.metric_by_comments.first
InstagramMetric.metric_by_comments
InstagramMetric.metric_by_comments.to_sql
exit
InstagramMetric.metric_by_comments
exit
exit!
InstagramMetric.metric_by_comments
next
exit
effort_params
effort_params[:licenciamento_codevasf].to_i
nil.to_i
"0".zero?
ext
exit
[nil, 1, 1, 1, 2, 3].compact
[nil, 1, 1, 1, 2, 3].chunk
[nil, 1, 1, 1, 2, 3].
[nil, 1, 1, 1, 2, 3].zip
[nil, 1, 1, 1, 2, 3].shift
[nil, 1, 1, 1, 2, 3].shift(2)
[nil, 1, 1, 1, 2, 3].uniq
[nil, 1, 1, 1, 2, 3].compact.uniq
exit
self.media_id
self
exit
exit!
youtube_campaign
scope
exit!
require 'db/migrate/20141215004755_add_instagram_comments_graphics_to_social_owned'
AddInstagramCommentsGraphicsToSocialOwned.new.change
exit;
AddInstagramCommentsGraphicsToSocialOwned
AddInstagramCommentsGraphicsToSocialOwned.new
AddInstagramCommentsGraphicsToSocialOwned.new.up
exit
AddInstagramCommentsGraphicsToSocialOwned.new
exit
AddInstagramCommentsGraphicsToSocialOwned.new
AddInstagramCommentsGraphicsToSocialOwned.new.change
exit
instagram_campaign
instagram_campaign.present?
exit
instagram_campaign
exit
instagram_campaign
instagram_campaign.present?
scope.joins(:campaigns)
scope.joins(:campaigns).where(campaign: instagram_campaign)
scope.joins(:campaigns).where(campaign: instagram_campaign).first
scope.joins(:campaign).where(campaign: instagram_campaign).first
scope
scope.joins('LEFT JOIN instagram_campaigns as ic ON ic.media_id = instagram_metrics.instagram_media_id').where(campaign: instagram_campaign).first
scope.joins('LEFT JOIN instagram_campaigns as ic ON ic.media_id = instagram_metrics.instagram_media_id').where(campaign: instagram_campaign).to_sql
scope.joins('LEFT JOIN instagram_campaigns as ic ON ic.media_id = instagram_metrics.instagram_media_id').where(instagram_campaign: {campaign: instagram_campaign}).to_sql
scope.joins('LEFT JOIN instagram_campaigns as ic ON ic.media_id = instagram_metrics.instagram_media_id').where(instagram_campaigns: {campaign: instagram_campaign}).to_sql
scope.joins('LEFT JOIN instagram_campaigns as ic ON ic.media_id = instagram_metrics.instagram_media_id').where(instagram_campaigns: {campaign: instagram_campaign}).first
scope.joins('LEFT JOIN instagram_campaigns as ic ON ic.media_id = instagram_metrics.instagram_media_id').where(instagram_campaigns: {campaign: instagram_campaign}).to_sql
exit!
exit
scope.all
scope.order('total DESC')
scope.order('total DESC').all
exit
scope.all
scope.to_sql
exit!
scope.to_sql
TopInstagramHashtagsFilter.new(scope, filter_params).result
exit!
AddTopInstagramHashtagsGraphicsToSocialOwned.new.change
exit
AddCampaignComboForInstagram.new.change
exit
AddCampaignComboForInstagram.new.change
exit
AddCampaignComboForInstagram.new.change
exit
self.profile
self.profile.api_factory
next
client
client.user
self.profile
u=client.user
u.username
u.counts
u.counts.follows
u.follows
exit!
InstagramMetric.find_or_initialize_by_metric_and_captured_at
InstagramMetric.find_or_create_by_metric_and_captured_at
exit
i=InstagramMetric.find_or_initialize_by(metric:'FOLLOWS',captured_at:Date.today)
i.update!(delta: user.counts.follows)
i.update!(delta: InstagramProfile.first.api_factory.user.counts.follows)
exit
AddInstagramProfileIdOnMetrics.new.change
AddInstagramProfileIdOnMetrics.new.down
exit
client.user
client.user.id
exit!
next
metric
exit
DateTime
exit
InstagramMetric.metric_by_follower
InstagramMetric.metric_by_follower.to_sql
exit
InstagramMetric.metric_by_follower.to_sql
InstagramMetric.metric_by_follower
exit
InstagramMetric.metric_by_follower
FanAcquisitionInstagramFilter.new(InstagramMetric.metric_by_follower)
FanAcquisitionInstagramFilter.new(InstagramMetric.metric_by_follower, {})
FanAcquisitionInstagramFilter.new(InstagramMetric.metric_by_follower, {}).result
exit
FanAcquisitionInstagramFilter.new(InstagramMetric.metric_by_follower, filters).result
exit!
FanAcquisitionInstagramFilter.new(InstagramMetric.metric_by_follower, filters).result
FanAcquisitionInstagramFilter.new(InstagramMetric.metric_by_follower, {}).result
exit
InstagramProfile.first
InstagramProfile.first.api_user
InstagramProfile.first.api_profile
InstagramProfile.first.api_factory
InstagramProfile.first.api_factory.user
InstagramProfile.first.api_factory.user.counts
InstagramProfile.first.api_factory.user.counts.followed_by
exit!
false.to_sym
false.to_s
exit
ConditionStatus.all
ConditionStatus.pluck(:status0
)
ConditionStatus.pluck(:status)
exit
InstagramMetric.top_1_by_likes_and_comments
InstagramMetric.top_1_by_likes_and_comments.to_sql
InstagramMetric.top_1_by_likes_and_comments.total
InstagramMetric.top_1_by_likes_and_comments.to_sql
exit
AddInsightsLastUpdateOnFacebookPage.new.change
exit
ReportConditionLicense
exit
ReportCondition
ReportCondition.first
ReportCondition.first.license
ReportConditionLicense
ReportConditionLicense.first
ReportConditionLicense.first.conditions
exit
ReportConditionLicense.first.conditions
ReportConditionLicense.first
ReportConditionLicense.first.conditions
reload!
ReportConditionLicense.first.conditions
ReportConditionLicense.first.conditions.to_hash
ReportConditionLicense.first.conditions.to_json
ReportConditionLicense.first.conditions.first
ReportConditionLicense.first.conditions.first.attributes
ReportConditionLicense.first.conditions.first
ReportConditionLicense.first.conditions.first.attributes
ReportConditionLicense.first.conditions.first.attributes.compact
{}.compact
exit
whereami
submission.log
submission.log.last
exit
exit!
::Configuration.new
config.language?
next
config.language?
next
exception
exit
exit!
next
exit
next
form
form.allow_new_submissions
next
nextnext
next
exception
exit
eixt
exit
Submission.find(params[:id])
StopReason.find(params[:reason_id])
next
reason.reschedule?
next
exit
whereami
field
field_parameters
field_params
field.update! field_params
field
field.save
field
whereami
params[:type]
params[:type].constantize
exit
self
self.section.form.fields.where(:identifier => true)
self.section.form.fields.where(:identifier => true).update_all(:identifier => false)
exit
EventualRequirement.find(50)
EventualRequirement.find(50).status
EventualRequirement.find(50).update data_de_vencimento = Date.today + 1.month
EventualRequirement.find(50).update data_de_vencimento: Date.today + 1.month
EventualRequirement.find(50).status
exi
exit
response.data
response.data.rows
exit
response.data.rows
exit
exit if response.data.rows.blank?
response.data.rows.blank?
response.data.rows
response.data
apis.analytics
apis.analytics.reports
apis.analytics.reports.query
exit!
response.data
response.data.rows.data
response.data.rows
exit
exit!
response.data
response.data.rows
exit
response.data.rows
exit!
response.data.rows
exit
response.data.rows
exit!
response.data.rows
exit
response.data.rows
exit
response.data.rows
exit!
columns
self.metrics.where(metric: 'UNIQUES')
exit
self.metrics.where(metric: 'UNIQUES')
next
day
exit!
filter_result[:result]
filter_result[:result].first
filter_result[:result].first.campaign
filter_result[:result].map(&:campaign)
exit
filter_result[:result].map(&:campaign)
filter_result[:result].first
exit!
exit
filter_result[:result].first
filter_result[:result].first.try(:campaign)
exit
filter_result[:result]
exit!
result
result.campaign
exit
result
result.campaign
exit
result
result.class
exit!
result.campaign
exit
result.campaign
exit
result.campaign
exit
result.campaign
exit
exit!
scope
scope.to_sql
scope.first.campaign
exit
result
result[:result]
result.first
result.first[:result]
result.first[:result].first
result.first[:result].first.last
result.first[:result].first.last[:query_object]
result.first[:result].first.last.first[:query_object]
result.first[:result].first.last.first[:query_object].first
result.first[:result].first.last.first[:query_object].first.campaign
exit
result.campaign
result
filter_result[:result]
filter_result
exit
exit!
exit
filter_result
filter_result[:result]
exit!
query.to_sql
period
opts
date_from
date_to
scopes_for_period(query, period, date_from..date_to)
scopes_for_period(query, period, date_from..date_to).to_sql
exit!
exit
result
exit
result.to_sql
exit!
scope
scope.to_sql
exit!
scope
exit!
scope
p=YoutubeProfile.top_5_hashtags
YoutubeProfile.top_5_hashtags.to_sql
exit
YoutubeProfile.top_5_hashtags.to_sql
exit
YoutubeProfile.top_5_hashtags.to_sql
YoutubeProfile.top_5_hashtags
exit
AddIndexToOptimize.new.change
exit
AddIndexToOptimize.new.change
AddIndexToOptimize.new.down
exit
AddIndexToOptimize.new.change
exit
AddIndexToOptimize.new.change
exit
%w{a b c }
%w{a b c}
%w{a b c}.map.with_index(2)
%w{a b c}.map.with_index(2).to_a
%w{a b c}.map.with_index{|v,i| [v,i]}
exit
response.status
env['PATH_INFO']
env['PATH_INFO'][env['PATH_INFO'].length - 1]
env['PATH_INFO'].last
exit
response.status
response.status.code
response.status_line
response.status_message
response.status_string
response.status_code
response.status
exit
response
exit
next
exit
next
Assignment.find_by(mod_id: user.id).blank?
Assignment.find_by(mod_id: user.id)
Submission.joins(:assignment).where(assignments: {mod_id: user.id})
exit
Configuration.all
x=Configuration
a.all
x.all
x=Configuration.new
x.all
Configuration.any_instance
Configuration.any_instance.stub(:all).and_return({})
x=Configuration.new
x.all
Configuration.any_instance.stub(all: {})
x=Configuration.new
x.all
Configuration.stub(all: {})
x=Configuration.new
x.all
Configuration.stub(new: {})
x.all
Configuration.stub(new: {})
a=Configuration.new
a.all
Configuration.stub(new: {all: 1})
b=Configuration.new
b.all
Configuration.stub(new: {stub(all: 1)})
Configuration.stub(new: stub(all: 1))
c=Configuration.new
c.all
exit!
a=Configuration.new
a.all
exit!
a=Configuration.new
a.all
a.update
exit
exit!
@licenses.to_sql
@licenses.order(:expiration_date).to_sql
@licenses.un
@licenses.order(nil)
@licenses.order(nil).to_sql
exit
@licenses.to_sql
@licenses.except(:order)to_sql
@licenses.except(:order).to_sql
@licenses.unscope.except(:order).to_sql
@licenses.unscoped
@licenses.unscoped.to_sql
@licenses.unscoped.except(:order).to_sql
@licenses
@licenses.to_sql
@licenses.unscoped(:order).to_sql
@licenses.unscope(:order).to_sql
@licenses.only(:where).to_sql
@licenses.reorder(:expiration_date).to_sql
exit
next
exception
exit
next
exception
next
step
logger
next
normalised_class
next
lookup_error_name(exception).to_s
lookup_error_name(exception)
lookup_error_message(exception)
exit
next
exception
exception.to_s
exit
next
error! :invalid_resource, exception.to_s
error! :invalid_resource
exit
next
step
next
error_mapping
klass
next
klass
lookup_error_status(exception)
next
step
exception
exit
exception
exit
exception
exit
exception
exit!
exception
exit
exception
exit
exception
RocketPants::InvalidResource.new('xxx')
RocketPants::InvalidResource
exit
exception
exit!
exception
exit
next
step
next
exception
exit
error! :teta, 'tetinha'
exit
next
exception
next
result
next
payload
next
body
exit
exception
exception.class
exception.to_s
exception.message
exit!
requirement
exit
requirement
exit
current_user
exit
current_user
current_user.regional_superintendency
params[:sSearch]
params
exit
params
exit
exception
exception.message
exit
exception.class
exception.message
exception.errors
exception.message
exit
exception.message
exception
exit
exception
exit
exception.class.to_s.underscorize
exception.class.to_s.underscorise
exception.class.to_s.underscore
exit!
exception
exit
exitnext
next
exception
exception.messag
exception.message
exit!
exit
eventual_requirement_params
params
exit
params[:datatable]
ventures.send("finished")
exit
assigns(:types_of_legal_device))
assigns(:types_of_legal_device)
assigns(:@types_of_legal_device)
assigns(:types_of_legal_device)
assign(:types_of_legal_device)
assigns(:types_of_legal_device)
exit
ApplicationPolicy.stub(find_permission: true)
ApplicationPolicy.any_instance.stub(find_permission: true)
x=ApplicationPolicy.new
x=ApplicationPolicy.new(1, 2)
exit
FacebookPageMetric.metric_sum_day_month_year_by_page_consumptions
FacebookPageMetric.metric_sum_day_month_year_by_page_consumptions.first
FacebookPageMetric.metric_sum_day_month_year_by_page_consumptions.first.daily
facebook_result
exit
InstagramMetric.by_likes_and_comments
InstagramMetric.by_likes_and_comments.to_sql
InstagramMetric.by_likes_and_comments.group(:metric).to_sql
InstagramMetric.by_likes_and_comments.group(:metric)
YoutubeMetric.by_like_and_dislike
YoutubeMetric.by_like_and_dislike.to_sql
FacebookPageMetric.metric_sum_day_month_year_by_page_consumptions
InstagramMetric.by_likes_and_comments.first.daily
FacebookPageMetric.metric_sum_day_month_year_by_page_consumptions.first.daily
next
results
whereami
StandardEngagementChart.format(results)
results
exit!
scope
result
exit
[nil, 1].compact
[[], 1].compact
exit
facebook_result
whereami
result
exit!
exit
exit!
facebook_result
facebook_result.first
facebook_result.first[:result]
facebook_result.first[:result].first
facebook_result.first[:result].first.social_network
facebook_result.first[:result].first.total
exit!
facebook_result
twitter_result
youtube_result
instagram_result
instagram_result.first[:result]
instagram_result.first[:result] + twitter_result.first[:result]
exit!
facebook
facebook.first[:result]
facebook.first[:result] + twitter.first[:result] + youtube.first[:result]  + instagram.first[:result
]
facebook.first[:result] + twitter.first[:result] + youtube.first[:result]  + instagram.first[:result]
exit!
exit
Venture.find(1)
exit
'10-01-2014'.to_date
'10-01-2014'.to_date.to_s
exit
whereami
answer
'xxx'.to_date
DateTime.parse(answer)
DateTime.parse(answer).present?
Time.parse(answer)
exit
params
controller
session
current_user
exit
RocketPants
RocketPants::VERSION
ENV
RAILS_ENV
Rails.env
RocketPants::Client
RocketPants::Client.version
RocketPants::Client.endpoint
RocketPants::Client.endpoint('/')
RocketPants::Client.endpoint(current_path)
request
@version
RocketPants::Client._version
exit!
ReportConditionLicense.first.conditions.first.attributes.compact
RocketPants::Client._version
RocketPants::Client.version
params
exit!
api-version
api_version
exit!
api_version
api_version.zero?
api_version == 1
answer
next
value
exit
@@api_version
exit!
$api_version
nil.zero?
exit!
$api_version
exit
$api_version
exit!
$api_version
exit
subject
field1_1
exit!
exit
I18n.t(:ico_true)
I18n.t(:ico_false)
exit
true.to_i
true.to_int
true.to_bn
true.to_integer
Integer.new(true)
Integer
Integer(true)
Integer.ancestors
1.class
exit
2.times {|i| puts i}
2.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.last, types_of_legal_device: TypesOfLegalDevice.last, nome: "Lorem Ipsum Dolor #{i}", competencia: 'union', ementa: 'Lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet.'}; nil
2.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.last, types_of_legal_device: TypesOfLegalDevice.last, nome: "Lorem Ipsum Dolor #{i}", competencia: 'union', ementa: 'Lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet.') }; nil
ActiveRecord::Log = nil
2.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.last, types_of_legal_device: TypesOfLegalDevice.last, nome: "Lorem Ipsum Dolor #{i}", competencia: 'union', ementa: 'Lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet.') }; nil
200.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.last, types_of_legal_device: TypesOfLegalDevice.last, nome: "Lorem Ipsum Dolor #{i}", competencia: 'union', ementa: 'Lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet.') }; nil
ActiveRecord.logger
ActiveRecord.log
ActiveRecord::Base.loggger = nil
ActiveRecord::Base.logger = nil
200.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.last, types_of_legal_device: TypesOfLegalDevice.last, nome: "Lorem Ipsum Dolor #{i}", competencia: 'union', ementa: 'Lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet.') }; nil
2000.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.last, types_of_legal_device: TypesOfLegalDevice.last, nome: "Lorem Ipsum Dolor #{i}", competencia: 'union', ementa: 'Lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet. lorem ipsum dolor sit amet.') }; nil
exit
params
params[:sSearch]
params
whereami
exit
params[:search]
params[:search][:value]
params.keys.sort
params[:search][:value]
exit
params[:sSearch_5]
l+
end
exit
2000.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.first, nome: "Lorem Ipsum Dolor #{i}", competencia: 'city', city: City.limit(100).order('RANDON()').first, ementa: 'Lorem ipsum dolor sit amet') }; nil
2000.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.first, nome: "Lorem Ipsum Dolor #{i}", competencia: 'city', city: City.limit(100).order('RAND').first, ementa: 'Lorem ipsum dolor sit amet') }; nil
2000.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.first, nome: "Lorem Ipsum Dolor #{i}", competencia: 'city', city: City.limit(1).order('RAND').first, ementa: 'Lorem ipsum dolor sit amet') }; nil
2000.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.first, nome: "Lorem Ipsum Dolor #{i}", competencia: 'city', city: City.limit(1).order('RANDON()').first, ementa: 'Lorem ipsum dolor sit amet') }; nil
City.limit(1).order('RANDON()').to_sql
City.limit(1).order('RANDON()').first.to_sql
City.limit(1).order('RANDON()').first
2000.times {|i| LegalDevice.create(environment_program_theme: EnvironmentProgramTheme.first, nome: "Lorem Ipsum Dolor #{i}", competencia: 'city', city: City.limit(1).order('RANDOM()').first, ementa: 'Lorem ipsum dolor sit amet') }; nil
ActiveRecord::Base.logger = nil
exit
params
exit
params
params[:format]
exit
params
exit
params
exit
params
exit
params
method
SERVER
REQUEST
request
request.method
exit
params
response.body
params
exit
x={a:1,b:2}
x.keys
x.key? :a
x.key? [:a]
exit
params
response.body
ActiveRecord::Errors
ActiveModel::Errors
ActiveModel::Errors.all
ActiveModel::Errors.
whereami
@errors
end
@errors
flash
flash.keys
flash.key? :alert
exit
flash
exit
flash
exit
requet.path
request.path
request.method
parmas
params
exit
Log.last
exit
Log.last
exit
control
control.last
control.last.first
control.last.first.to_s
control.last.first.to_s.undercore
control.last.first.to_s.underscore
control.last.map{|c| c.to_s.underscore}
control.last.map{|c| I18n.t(c.to_s.underscore) }
exit
x
x.flatten
exit
Log.delete_all
exit
Venture.find(8)
Venture.find(8).licensing_schedules
Venture.find(8).licensing_schedules.pluck(:status)
exit
params[:sSearch_1]
exit
range_dates
date
dates
dates.first
dates.first.to_date
exit
dates.first
range_dates
exit
range_dates
dates.first
dates.first =~ format
exit
params
exit
DateTime.parse
DateTime.parse 'x'
Time.parse 'x'
Time.parse('x').nil?
Time.parse('1').nil?
Time.parse('11/11/1111').nil?
Time.parse('11/11/1111')
''.to_date
'x'.to_date
exit
subject
response
response.body
form
form.allow_new_submissions
exit!
Log.last
Log.last.params
reload!
Log.last.params
exit
[1,2,3,4,5].last
[1,2,3,4,5].last(2)
[1,2,3,4,5].last.previous
x=[1,2,3,4,5]
x.last
x.previous
x.previous_element
Log.last.get_controller
reload!
Log.last.get_controller
exit
fullpath
fullpath.compact
fullpath.flatten
fullpath.except(&:blank?)
fullpath.excerpt(&:blank?)
fullpath.reject(&:blank?)
exit
action
control
exit
'ventures'
'ventures'.constantize
'ventures'.camelize
'ventures'.singularize
'ventures'.singularize.constantize
'ventures'.singularize.camelize.constantize
exit
my_action_or_id
index
resource_name
fullpath[index+1]
fullpath[index]
fullpath
fullpath[1...-1]
fullpath[1..-1]
fullpath
path
path.split('/')
path.split('/')[1...-1]
path.split('/')[1..-1]
exit
url_for(controller: resource_name, action: :show, id: resource_id)
exit
url_for(controller: resource_name, action: :show, id: resource_id)
url_for(controller: 'licenses_controller', action: :show, id: resource_id)
exit
resource_name
exit
resource_name
exit
parameters
url_for(parameters.merge(controller: resource_name, action: :show, id: resource_id))
exit
params
params.reject {|x,y| x.include? 'id' }
params.select {|x,y| x.include? 'id' }
exit
request
request.formats
request
request.format
request.keys
request
controller.request
controller.request.format
request.format.html?
exit
parameters
exit
params
params.event
params['event']
Hash.parse params['event']
Hash.new params['event']
params['event'].to_h
params['event']
serializable_hash params['event']
serializable_hash 
serializable_hash params['event']
serializable_hash [params['event']]
params['event']
eval(params['event'])
Hash[params['event']]
Hash.new[params['event']]
Hash.inpect params['event']
params['event'].inspect
params['event'].gsub('=>', ':')
JSON.parse params['event'].gsub('=>', ':')
exit
params
exit
controller_name
controller_name.singularize
controller_name.singularize.camelize
controller_name.singularize.camelize.constantize
exit
current_user and params[:format].blank? 
Permission::REJECTED_ACTIONS.include? params[:action] 
not flash.key? :error and not flash.key? :warning and not flash.key? :alert
controller_name
not Log::SKIP_CONTROLLERS.include? controller_name
next
exit
current_user and params[:format].blank? and not Permission::REJECTED_ACTIONS.include? params[:action] and not flash.key? :error and not flash.key? :warning and not flash.key? :alert and not Log::SKIP_CONTROLLERS.include? controller_name
exit
request.format
request.format.html?
request.format.xxhtml?
request.format.json?
request.format.html?
exit
request.format.html? 
controller_name
params
exit
flash
exit
flahs
flash
flash.keys
exit
flash
exit
flash
flash.keys
exit
flash.keys
exit
flash
flash.keys
flash.keys.include? :alert
flash.keys.include? (:alert || :error)
flash.keys.include? (:error || :alert)
flash.keys
flash.keys.flatten
[:error, :warning, :alert] - flash.keys
flash.keys - [:error, :warning, :alert]
exit
Attachment.last
Log.where("path like '%general_schedule%'")
Log.where("path like '%general_schedule%'").delete_all
exit
request.params
poarams
params
exit
breadcrumbs
exit
breadcrumbs
exit
breadcrumbs
exit
breadcrumbs request.path
request.controller_name
request.params
breadcrumbs request.path, request.params[:controller], request.params[:action]
exit
breadcrumbs request.path, request.params[:controller], request.params[:action]
exit
breadcrumbs request.path, request.params[:controller], request.params[:action]
exit
breadcrumbs request.path, request.params[:controller], request.params[:action]
breadcrumbs request
request
request.path
request.fullpath
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
request.params[:controller]
exit
x=[]
x.push [1]
exit
breadcrumbs request
exit
[1,2,3,4,5]
x=_
x.last
x.last = 3
x[x.last.index]
x[x.size]
x[x.size-1]
x[x.size-1] = 
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
x=_
x.first
x.last
x[0]
x[1]
x[1].last
x[1].last.last
x[1].last.last.last
x[1].last.last.last.last
exit
breadcrumbs request
crumb
skip_control
crumb[-1]
atual
actual
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
request.push
request.path
request.path[1..-1]
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
breadcrumbs request
exit
x=[1,2,3,4,5]
x[-1]
exit
breadcrumbs request
exit
breadcrumbs(request)
x=self.new path: request.path, params: params, breadcrumb: breadcrumbs(request)
params=request.params
x=self.new path: request.path, params: params, breadcrumb: breadcrumbs(request)
exit
Log.last
x=Log.last
x.breadcrumb = [{}]
x.save
x.breadcrumb = [{'a' => 1}]
x.save
x.breadcrumb = [{'a' => '1'}]
x.save
reload!
x=Log.last
x.breadcrumb = [{'a' => '1'}]
x.save
x.breadcrumb = '{{1,2,3}, {1,2,3}}'
x.save
x.breadcrumb = '\'{{1,2,3}, {1,2,3}}\'::json[]'
x.save
Log.last.update breadcrumb: '\'{{1,2,3}, {1,2,3}}\'::json[]'
Log.last.update! breadcrumb: '\'{{1,2,3}, {1,2,3}}\'::json[]'
reload!
Log.last.update! breadcrumb: '\'{{1,2,3}, {1,2,3}}\'::json[]'
Log.last.update! breadcrumb: '{{1,2,3}, {1,2,3}}'
Log.last.update! breadcrumb: '[{{1,2,3}, {1,2,3}}]'
Log.last.update! breadcrumb: '[{1,2,3}, {1,2,3}]'
Log.last.update! breadcrumb: '[{\'a\'=>\'1\'}]'
Log.last.update! breadcrumb: '[{\"a'=>'1\'\}]'
exit
breadcrumbs(request)
exit
breadcrumbs(request)
self.new log_breadcrumbs: [_]
x=breadcrumbs(request)
self.new log_breadcrumbs_attributes = x
self.new log_breadcrumbs_attributes: x
self.new log_breadcrumb_attributes: x
self.new log_breadcrumbs_attribute: x
exit
x=breadcrumbs(request)
self.new log_breadcrumbs_attributes: x
x=_
x.log_breadcrumbs
exit
x=breadcrumbs(request)
exit
x=breadcrumbs(request)
exit
Log.last
Log.last.log_breadcrumbs
exit
Log.last
Log.last.log_breadcrumbs
Log.last.log_breadcrumbs.each {|x| x}
exit
controller
controller.singularize
controller.singularize.camelize
controller.singularize.camelize.contantize
controller.singularize.camelize.constantize
exit
Log.last
[A
Log.last
exit
url
Net::HTTP.get_response(URI(url))
URI(url)
request
request.host
request.env
request.env.http_host
request.env.HTTP_HOST
request.envs.HTTP_HOST
request.env_HTTP_HOST
request.env['HTTP_HOST']
URI(request.env['HTTP_HOST'] + url)
request.env['HTTP_REFER']
request.env['HTTP_REFERED']
request.env['HTTP_REFERER']
URI(request.env['HTTP_REFERER'])
Net::HTTP.get_response(URI(request.env['HTTP_REFERER']))
exit
host
url
host + url
$1
host
host.to_s
host.to_s + url
exit
Time.parse('').nil?
Time.parse('a').nil?
Time.parse('111').nil?
Time.parse('111')
''.to_date
'a'.to_date
''.to_date
Fadaray
Net
Net::HTTP
l=Log.last
Net::HTTP.get(l.path)
Net::HTTP.get('http://localhost:3001', l.path)
Net::HTTP.get('http://0.0.0.0:3001', l.path)
Net::HTTP.get(URI('http://0.0.0.0:3001'), l.path)
Net::HTTP.get(URI("http://0.0.0.0:3001#{l.path}")
)
r=Net::HTTP.get(URI("http://0.0.0.0:3001#{l.path}"))
r.status
r.class
r=Net::HTTP.get_response(URI("http://0.0.0.0:3001#{l.path}"))
r.status
r.code
r
r.code
r.code =~ /\d/
$1
r.code =~ /\d+/
r.code =~ /\d\d\d/
r.code =~ /[\d]+/
'xasdgergw'.match(/(x)/
)
$1
exit
host
Net::HTTP.get_response(URI(host + url))
exit
whereami
host
Net::HTTP.new(URI(host))
next
exit
Log.last.select(:id)
Log.select(:id)
Log.select(:id).last
Log.select(:id).last.id
Log.delete_all
exit
@log
next
exit
string.to_s.to_date
string.to_s
Time.parse(string)
exit
controller_name
controller_name.singularize
controller_name.singularize.camelize
controller_name.singularize.camelize.constantize
controller_name.singularize.camelize.constantize.find(params[:id])
exit
string
{x: Time.now}
x=_
x.to_json
JSON.parse(_)
exit
Log.delete_all
Date
Date.parse
Date.parse 'xx'
Log.last
Date.parse '1'
Date.parse '123'
Log.last
Log.last.log_breadcrumbs
Log.last.log_breadcrumbs.last
Log.last.log_breadcrumbs.last.data
Log.last.log_breadcrumbs.last.data['event']
Log.last.log_breadcrumbs.last.data['event'] = ''
x=Log.last.log_breadcrumbs.last
x.data = x.data.except('event')
x.save
Log.last.log_breadcrumbs.last.data['event']
exit
find_permission
find_permission :index
exit
Channel.new
Channel.all
Channel.create name: 'teste', user_id: User.last.id
Channel.create name: 'teste', user: User.last
exit
params
exit
whereami
params
exit
whereami
uri
message
message.to_json
Net::HTTP.post_form(uri, message: message.to_json)
ri
uri
exit
URI('http://0.0.0.0:3000/remote/faye')
uri=_
x=Net::HTTP.post_form(uri, {channel:'/messages/new', data:'xxxx'}.to_json)
x=Net::HTTP.post_form(uri, {channel:'/messages/new', data:'xxxx'})
x=Net::HTTP.post_form(uri, message: {channel:'/messages/new', data:'xxxx'}.to_json)
exit
params
exit
message
message: message.to_json
{message: message.to_json}
uri
exit
channel
block
capture(&block)
exit
channel
exit
message
current_user
session
exit
capture(&block)
current_user
current_user.id
exit
FAYE_CLIENT
FAYE_CLIENT.publish '/messages/new', {}.to_json
FAYE_CLIENT.publish '/messages/new', 'xxxx'
exit
SecureRandom
SecureRandom.uuid
SecureRandom.
SecureRandom.hex
SecureRandom.uuid
exit
FAYE_CLIENT
reuqire 'config.ru'
require 'config.ru'
uri=URI('http://0.0.0.0:3000/remote/faye')
x=Net::HTTP.post_form(uri, message: {channel:'/messages/new', data:'xxxx'}.to_json)
x.response
x.body
x=Net::HTTP.post_form(uri, message: {channel:'/messages/new', data:{'xxxx'=>'xxx'}}.to_json)
x.body
exit
SecureRandom.base64
SecureRandom.base64('+/=', 'Qrt')
SecureRandom.base64.tr('+/=', 'Qrt')
SecureRandom.urlsafe_base64
SecureRandom.urlsafe_base64(nil, false)
SecureRandom.hex
User.exists?(id: 1)
exit
User.where(auth_token: nil)
User.send('set_auth_token')
User.first.send('set_auth_token')
exit
User.last
User.last.user_active
User.last.user_actives
User.last.active_user
exit
User.first.slice(:name)
User.last
ActiveUser.all
reload!
ActiveUser.online
reload!
ActiveUser.online
ActiveUser.last
ActiveUser.online.each {|u| u }
exit
whereami
date.month
Date.today.month
date
date.to_date
Date.today
date.to_date == Date.today
exit
ChatMessage.all
ChatMessage.last
ActiveUser.online.each {|u| u }
exit
request
request.origin
request
request.env
request.env['ORIGIN']
request.env.keys.sort
exit
request.env.keys.sort
exit
channel
data
exit
User
require 'activerecord'
require 'active-record'
require 'active_record'
whereami
require ::File.expand_path('../app/model/user',  __FILE__)
require ::File.expand_path('../app/model/user.rb',  __FILE__)
require ::File.expand_path('../app/models/user',  __FILE__)
require ::File.expand_path('../app/model/user.rb',  __FILE__)
exit
User
User.count
exit
ChatMessage.last
exit
Configuration.faye_server
@config
name
@config[:faye_server]
@config['faye_server']
exit
ChatMessages.last
ChatMessage.last
ChatMessage.last.update to_user_id: User.last.id
exit
whereami
params
exit
params
exit
params
exit
params
params[:form_chat_file]
exit
(0..1).to_a
(0...1).to_a
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
Attachment
Attachment.last
Attachment.last.document
exit
params
params[:file_0]
params[:file_0].content_type
params[:file_0].name
params[:file_0].file_name
params[:file_0].filename
params[:file_0].original_filename
params[:file_0].size
params[:file_0]
exit
current_user
current_user.chat_messages
current_user.chat_attachments
params
exit
params
params.each {|k,v| k };nil
params.each {|k,v| puts k };nil
params.select {|k,v| k.include? 'file_' }
params.select {|k,v| k.include? 'file_' }.keys
exit
attachments
attachments.to_json
exit
attachments.map{|a| {id: a.id, url: a.document.url} }
exit
attachments.map{|a| {id: a.id, url: a.document.url, type: a.document.content_type} }
attachments.map{|a| {id: a.id, url: a.document.url, type: a.document.content_type} }.to_json
exit
params
exit
params
exit
params
exit
return
params
exit
Attachment.last.document
Attachment.last.document.content_type
x={a:1,b:2,c:3}
x.to_a
a.map
x.map
x.map{|k,v| v}
Attachment
Attachment.all.slice(:id)
Attachment.all.select(:id)
Attachment.all.select(:id).to_json
Attachment.first
Attachment.first.docuemtn
Attachment.first.document
Attachment.first.document.url
Attachment.first.document.public_url
Attachment.first.document.full_url
Attachment.first.document.content_type
Attachment.first.document.name
Attachment.first.document.filename
Attachment.first.document.file_name
Attachment.first.document_file_name
ChatAttachment.last
exit
self.to_sql
to_sql
self
self.where().to_sql
self.where(to_user_id: user.id).to_sql
self.pluck(:id)
exit
self.pluck(:id)
self.rewhere(id: self.pluck(:id), to_user_id: user.id, was_read: false)
self.re_where(id: self.pluck(:id), to_user_id: user.id, was_read: false)
self.rew
exit
messages
exit
messages
messages.class
messages.map(&:id)
exit
ChatAttachment.last
ChatAttachment.last(2)
ChatAttachment.last(2).first
ChatAttachment.last(2).first.document.content_type
ChatAttachment.last(2).first.document
ChatAttachment.last(2).first.document.content_type
ChatMessage.destroy_all
ChatAttachment.destroy_all
reload!
ChatMessage
ChatMessage.last
ChatMessage.last.destroy
reload!
ChatMessage.first.to_sql
ChatMessage.unread.first.to_sql
ChatMessage.unread.first.sql
reload!
ChatMessage.last_new
ChatMessage.last_new.to_sql
ChatMessage.last_new.reorder(:created_at).to_sql
ChatMessage.last_new.to_sql
ChatMessage.last_new.order(:id).to_sql
exit
url = URI(FayeConfiguration.faye_server)
Net::HTTP.get(uri)
Net::HTTP.get(url)
x=Net::HTTP.get(url)
x.body
x=Net::HTTP.post(url)
x=Net::HTTP.post_form(url)
x=Net::HTTP.post_form(url, {})
exit
Activity.last
Activity.last(10)
Activity.last(100)
HTML::Sanitize.sanize('')
HTML::Sanitize.sanitize('')
HTML::Sanitize
HTML::Sanitizer
HTML::Sanitizer.sanitize
HTML::Sanitizer.new.sanitizetize
ActionView::Helpers
ActionView::Helpers::SanitizeHelper
ActionView::Helpers::SanitizeHelper.sanitize
ActionView::Helpers::SanitizeHelper.instance.sanitize
ActionView::Helpers::SanitizeHelper.instance_method :sanitize
ActionView::Helpers::SanitizeHelper.new.sanitize
ActionView::Helpers::SanitizeHelper.new
ActionView::Helpers::SanitizeHelper
include ActionView::Helpers::SanitizeHelper
sanitize
sanitize('')
sanitize('<b>')
html_escape
include ERB::Util
html_escape
extend
extend ERB::Util
exit
class Utils
  include ERB::Util
end
u=Utils.new
u.html_escape
ERB::Util.html_escape
ERB::Util.html_escape('')
exit
group_params
exit
group_params
exit
group_params
exit
x=current_user.own_chat_groups.create(group_params)
x.errors
exit
group
exit
group
exit
group
exit
group
group.destroy
exit
current_user.own_chat_groups
current_user.chat_groups
current_user.own_chat_groups.reload
exit
@group
@group.persisted?
update_group_chat_index_path(@group) 
exit
group_url
exit
User.last
User.first
User.first.own_chat_groups
User.first.chat_groups
ChatGroup.first
ChatGroup.all
ChatGroup.all.each {|g| g}
User.first
User.first.own_chat_groups
User.first.own_chat_groups.each {|u| u}
User.first.chat_groups.each {|u| u}
User.first.own_chat_groups + User.first.chat_groups
exit
@all_groups
@all_groups.class
@all_groups.find
@all_groups.find(8)
@all_groups.select { |group| group.id == 8 }
@all_groups.select { |group| group.id == 8 }.first
exit
ChatGroup.find_by('id = 1')
ChatGroup.find_by('id = 10')
ChatGroup.find_by('id = 10 AND (chat_groups.user_id = 1)')
ChatGroup.find_by('id = 10 AND (chat_groups.user_id = 1 OR chat_groups_users.user_id = 5)')
ChatGroup.find_by('id = 10 AND (chat_groups.user_id = 1 OR chat_groups_users.user_id = 5)').to_sql
ChatGroup.find_by('id = 10 AND (chat_groups.user_id = 1)').to_sql
ChatGroup.where('id = 10 AND (chat_groups.user_id = 1)').to_sql
ChatGroup.joins(:chat_groups_users).where('id = 10 AND (chat_groups.user_id = 1)').to_sql
ChatGroup.where(user_id: 1).to_sql
ChatGroup.where(users: {user_id: 1}).to_sql
ChatGroup.where(users: {user_id: 1})
ChatGroup.joins(:users).where(users: {user_id: 1})
ChatGroup.includes(:users).where(users: {user_id: 1})
ChatGroup.joins(:users).where(users: {user_id: 1})
ChatGroup.joins(:users).where(chat_groups_users: {user_id: 1})
ChatGroup.joins(:users).where(chat_groups_users: {user_id: 6})
ChatGroup.joins(:users).where(chat_groups_users: {user_id: 6}).where(user_id: 1)
ChatGroup.joins(:users).where(chat_groups_users: {user_id: 6}).or.where(user_id: 1)
ChatGroup.joins(:users).where(chat_groups_users: {user_id: 6}).or(user_id: 1)
ChatGroup.arel_table
ChatGroup.joins(:users).where(chat_groups_users: {user_id: 6}) || ChatGroup.joins(:users).where(user_id: 1)
ChatGroup.joins(:users).where(chat_groups_users: {user_id: 1}) || ChatGroup.joins(:users).where(user_id: 1)
ChatGroup.joins(:users).find_by(chat_groups_users: {user_id: 1}) || ChatGroup.joins(:users).where(user_id: 1)
ChatGroup.joins(:users).find_by(chat_groups_users: {user_id: 6}) || ChatGroup.joins(:users).where(user_id: 1)
ChatGroup.joins(:users).find_by(chat_groups_users: {user_id: 6}) || ChatGroup.joins(:users).find_by(user_id: 1)
ChatGroup.joins(:users).find_by(chat_groups_users: {user_id: 1}) || ChatGroup.joins(:users).find_by(user_id: 1)
xxx
xxxxx.try(:d)
exit
whereami
origin.search(search_params[:q]).recents(params[:message_id])
origin.search(search_params[:q]).recents(params[:message_id]).present?
exit
ChatAttachment
reload!
ChatMessage.search
ChatAttachment.last
ChatMessage.search('yn')
reload!
ChatMessage.search('yn')
ChatMessage.search('yn').count
ChatMessage.search('yn').count.map(:id)
ChatMessage.search('yn').count.map(&:id)
ChatMessage.search('yn').map&:id)
ChatMessage.search('yn').map(&:id)
ChatAttachment
ChatAttachment.last.content
ChatMessage.search('yn').to_sql
reload!
ChatMessage.search('yn').to_sql
ChatMessage.search('yn')
reload!
ChatMessage.search('yn')
exit
legal_device_params
@legal_device.update(legal_device_params)
exit
params
params[:controller]
params['controller']
exit
params
VentureGeo.find(params[:id])
VentureGeo.find(1)
exit
VentureGeo.neqw
VentureGeo.new
g=VentureGeo.new
g.identificador = 'xxxx'
g.shape = false
g
g.ponto = 0101000000207C39C5D84F47C00DA04556058C37C0
g.ponto = '0101000000207C39C5D84F47C00DA04556058C37C0'
g.save
VentureGeo.first
VentureGeo.first.ponto
VentureGeo.first.ponto.latitude
VentureGeo.first.ponto.longitude
RGeo::Geos.gactory.parse_wkb(VentureGeo.first.ponto)
RGeo::Geos.factory.parse_wkb(VentureGeo.first.ponto)
RGeo::Geos.factory.parse_wkb([-46.46446464646, -23.2323232323])
f=RGeo::Cartesian.factory
f.point(-23.232323, -46.46464646)
RGeo::Cartesian.factory.point(-23.23232323, -46.46464646)
VentureGeo.find(1)
reload!
VentureGeo.find(1)
exit
geo_params
@geo.update geo_params
@geo.errors
exit
RGeo::Cartesian.factory.point(self.longitude, self.latitude)
RGeo::Cartesian.factory.point(self.longitude.to_f, self.latitude.to_f)
exit
VentureGeo.last
VentureGeo.last.shape ? 1 : 0
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
User.last.groups << Group.first
exit
VentureGeo.last
exit
VentureGeo.last
exit
VentureGeo.destroy_all
exit
FACTORY.point(self.longitude.to_f, self.latitude.to_f)
FACTORY.point(self.longitude.to_f, self.latitude.to_f).projection
self.ponto = FACTORY.point(self.longitude.to_f, self.latitude.to_f).projection
next
exit
nil.to_f
nil.to_f(2)
nil.to_f
VentureGeo.last
VentureGeo.last.ponto
VentureGeo.last.ponto.x
VentureGeo.last.ponto.y
VentureGeo.last.ponto.y.to_f
"%3.6f" % VentureGeo.last.ponto.y
exit
VentureGeo.first
VentureGeo.first.ponto
VentureGeo.first.ponto.x
VentureGeo.first.ponto.x.to_f
VentureGeo.first.ponto.x.to_f(5)
VentureGeo.first.ponto.x.to_s(6)
VentureGeo.first.ponto.x.to_d
VentureGeo.first.ponto.x.to_d(2)
VentureGeo.first.ponto.x.to_d(3)
VentureGeo.first.ponto.x.to_d(3, 6)
VentureGeo.first.ponto.x.to_d(3, precision: 6)
number_with
exit
number_with_precision
number_with_precision(geom.lat, precision: 6)
exit
number_with_precision(geom.lat, precision: 6)
exit
whereami
a
exit
self.shape_file
self.shape_file.path
exit
a
exit
a
exit
x
exit
b
exit
c
a
exit
b
exit
b
exit
self.shape_file
self.shape_file.path
exit
self.errors
self.errors.present?
exit
self.errors
self.errors.present?
exit
self.shape_file.path
File.exists? self.shape_file.path
self.shape_file
self.shape_file.file
self.shape_file.send('file')
self.shape_file
exit
self.
end
self
self.shape_file.url
exit
shape_file
shape_file.path
shape_file.path.split('/')
shape_file.path.split('/').join('/')
shape_file.path.split('/').join('/') + '/tmp/'
shape_file
shape_file.dir
shape_file.dirname
shape_file.path
dirname(shape_file.path)
File.dirname shape_file.path
File.dirname shape_file.path.join '/tmp/'
File.dirname shape_file.path
whereami
path
exit
path
exit
path
exit
File.exists? shape_file.path
exit
path
exit
exception
exception.message
exit
path
Dir.glob path
Dir.glob "#{path}*.shp"
d=Dir.glob("#{path}*.shp")
d.first
File.exists? d.first
File.filename d.first
File.file_name d.first
File.name d.first
File.name 
File.basename d.first
d=Dir.glob("#{path}*.shpx")
d.first
File.basename nil
exit
record.geometry
exit
File.exists? '/Users/euricovidal/Downloads/biomas.zip'
file= '/Users/euricovidal/Downloads/biomas.zip'
z=Zip::File.open file
z.find_entry 'shp'
Zip::File.extract file, '/tmp/xxx/'
Zip::ZipFile.extract file, '/tmp/xxx/'
require 'zip/zip'
unzip
exit
result
exit
VentureGeo.delete_alll
VentureGeo.delete_all
VentureGeo
exit
VentureGeo.all
VentureGeo.count
exit
VentureGeo.last
VentureGeo.last.eventual_requirement
VentureGeo.last.origin
exit
VentureGeo.by_requirements
exit
gon
gon.geo_shapes_data
gon.geo_shapes_data.merge({object: 1})
exit
gon.geo_shapes_data
exit
gon.geo_shapes_data
gon.geo_shapes_data.to_json
exit
@venture.try(:apelido)
@venture
exit
Log.last
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
exit
Venture.find(9).licensing_schedules.find(73).eventual_requirements
x=Venture.find(9)
x.destroy
x=Venture.find(9)
exit
exitfile
file
file.count
file.size
file.first
file[0\]
file[0]
file[1]
file[2]
file[3]
exit
record
record.geometry
whereami
record.attributes
record.attributes['NOME']
exit
sigars_200_casrt
sigars_200_cast
sigars_2000_cast
exit
mercator_cast
whereami
mercator_cast.size
mercator_cast[0]
mercator_cast[1]
mercator_cast[2]
record.geometry.size
record.geometry[2]
exit
file
exit
record.geometry
exit
mercator_cast
mercator_cast[0]
record.attributes
exit
mercator_cast
mercator_cast.size
mercator_cast[0].size
mercator_cast[0]
whereami
record.attributes
exit
eixt
exit
mercator_cast.size
record.attributes
exit
mercator_cast.size
record.attributes
mercator_cast[0]
mercator_cast[1]
exit
mercator_cast.size
record.attributes
exit
mercator_cast.size
attachments.map{|a| {id: a.id, url: a.document.url} }
record.attributes
GeoLayerFeature
exit
false.blank?
exit
mercator_cast
record.attributes
mercator_cast
mercator_cast.class
mercator_cast.size
mercator_cast.to_a
exit
mercator_cat
mercator_cast
mercator_cast.size
exit
mercator_cast.size
exit
mercator_cast.size
exit
mercator_cast.size
mercator_cast.to_a
mercator_cast.to_a.size
exit
mercator_cast.size
exit
mercator_cast.size
exit
mercator_cast.size
exit
GeoLayer.last
GeoLayer.last.geo_layer_features
GeoLayer.last
GeoLayer.last.geo_layer_features
GeoLayer.last.geo_layer_features.count
GeoLayer.last.geo_layer_features.first
GeoLayer.last.geo_layer_features.first.nome
exit
self.camada
self.camada.changed?
self.changes
exit
GeoLayer.destroy_all
GeoLayer.last
GeoLayer.last.geo_layer_features
exit
@venture.licensing_schedules.where.not(vencimento_planejado: nil).blank?
exit
Event.all
Event.all.select {|e| e.attachments.present? }
Event.all.select {|e| e.attachments.present? }.first
Event.find(2)
Event.find(2).attachments
exit
Venture.last(2)
Venture.last(2).first
Venture.find(8).licensing_schedules.select{|s| s.eventual_requirement.present? }
Venture.find(8).licensing_schedules.select{|s| s.eventual_requirements.present? }
Venture.find(8).licensing_schedules.select{|s| s.eventual_requirements.present? }.first.eventual_requirement
Venture.find(8).licensing_schedules.select{|s| s.eventual_requirements.present? }.first.eventual_requirements
Venture.find(8).destroy
exit
g
g.geo_layer_features
g.geo_layer_features.first
whereami
GeoLayerFeature.to_feature_collection g.geo_layer_features
/].
jh            ngfcny
  ..
end
.
/
whereami
exit
feature_collection
feature_collection.first
exit
query.to_sql
exit
query.to_sql
date_from..date_to
period
compare
exit
query.to_sql
exit
query.to_sql
exit
query.to_sql
exit
chart_data[:dimensions].first[:series].first[:values].first
filter_results
reach_results
exit
reach_data
exit
reach_data
exit
reach_data
exit!
reach_results
reach_results.first[:dimensions].first[:series].select{|serie| serie[:name] == 'TOTAL'}
reach_results.first[:dimensions].first[:series].select{|serie| serie[:name] == 'TOTAL'}.first
reach_results.first[:dimensions].first[:series].select{|serie| serie[:name] == 'TOTAL'}.first[:values]
reach_results.first[:dimensions].first[:series].select{|serie| serie[:name] == 'TOTAL'}.first[:values].first
exit!
reach_results
reach_results.first
reach_results.first[:dimensions]
reach_results.first[:dimensions].first
chat_data
chart_data
exit!
reach_results
chart_data
exit!
exit
}j=RGeo::GeoJSON.encode(feature_collection)
j=RGeo::GeoJSON.encode(feature_collection)
exit
feature_collection
feature_collection.to_json
g.geo_layer_features
whereami
GeoLayerFeature.to_feature_collection g.geo_layer_features
GeoLayerFeature.to_feature_collection g
GeoLayerFeature.to_feature_collection g.geo_layer_features.first
GeoLayerFeature.to_feature_collection g.geo_layer_features.first.to_a
exit
feature_collection
g.geo_layer_features
g.geo_layer_features.first
g.geo_layer_features.last
g.geo_layer_features.size
g.geo_layer_features.first
exit
feature_collection
GeoLayerFeature.to_feature_collection g.geo_layer_features.first
GeoLayerFeature.to_feature_collection [g.geo_layer_features.first]
x=GeoLayerFeature.to_feature_collection [g.geo_layer_features.first]
x.to_json
x.all
x.size
exit
GeoLayerFeature.to_feature_collection g.geo_layer_features
VentureGeo.to_feature_collection [VentureGeo.last]
x=VentureGeo.to_feature_collection [VentureGeo.last]
x.size
x.to_json
VentureGeo.to_feature_collection [VentureGeo.last]
GeoLayerFeature.to_feature_collection [GeoLayerFeature.last]
x=_
x.size
exit
feature_collection.size
VentureGeo.to_feature_collection [VentureGeo.last]
_.size
g.geo_layer_features.first
g.geo_layer_features.first.project
g.geo_layer_features.first.projection
VentureGeo.last.projection
VentureGeo.last
GeoLayer.delete_all
exit
feature_collection
feature_collection.size
g.geo_layer_features.first
exit
feature_collection.size
g.geo_layer_features.first.to_feature
g.geo_layer_features.to_feature
g.geo_layer_features.geometria
exit
feature_collection
feature_collection.size
exit
RGeo::GeoJSON.encode(feature_collection).to_json
exit
total_fan_numbers
total_followers
exit
total_followers
total_fan_numbers
exit
total_fan_numbers
total_followers
total_fan_numbers + total_followers
exit
total_fan_numbers + total_followers
new_fans
p
p.query_objects
p[:query_objects]
p[:query_object]
p[:query_object].first
p[:query_object].first.first
p[:query_object].first.first.to_sql
p[:query_object].first.first
exit!
p
exit
p
exit
p
exit!
grant
grant.destroy; next
grant.destroy
exit
grant.destroy
exit
EventualRequirementGrant.find(20)
EventualRequirementGrant.find(20).destroy
EventualRequirementGrant.all.select {|g| g.eventual_requirement.blank? }
EventualRequirementGrant.all.select {|g| g.eventual_requirement.blank? }.map(&:id)
EventualRequirementGrant.all.select {|g| g.eventual_requirement.present? }.map(&:id)
EventualRequirementGrant.all.select {|g| g.eventual_requirement.blank? }.map(&:id)
EventualRequirementGrant.all.select {|g| g.eventual_requirement.blank? }.map(&:destroy)
exit
@type
eventual_requirement_params
@eventual_requirement.update(eventual_requirement_params)
@eventual_requirement.errors
exit
response
response.data
exit!
response.data
-1.abs
1.abs
0.abs
exit!
fresh_channel
fresh_channel.statistics
exit!
last_version
versions.count
child_flow
child_flow.versions
self
child_flow.versionse
exit
child_flow.versions[child_flow_version-1]
child_flow.present?
exit
self.
end
self
self.child_flow_id
self.child_flow
self.child_flow.versions.blank?
exit
retrieve_channels
fresh_channel
exit!
YoutubeMetric.metric_profiles_by_uniques_to_reach
YoutubeMetric.metric_profiles_by_uniques_to_reach.to_sql
next
exit!
ReachChart.format(results)
exit
p
exit
rt
r
r.to_sql
r.daily
exit
reach_data
exit!
filter_results
filter_results.first
filter_results.first[:result]
filter_results.first[:result]['MONTH']
filter_results.first[:result]['MONTH'].first
filter_results.first[:result]['MONTH'].first[:query_object]
filter_results.first[:result]['MONTH'].first[:query_object].first
filter_results.first[:result]['MONTH'].first[:query_object].second
filter_results.first[:result]['MONTH'].first[:query_object].second.first
filter_results.first[:result]['MONTH'].first[:query_object].second.first.daily
filter_results.first[:result]['MONTH'].first[:query_object].second.first
puts filter_results.first[:result]['MONTH'].first[:query_object].second.first
filter_results.first[:result]['MONTH'].first[:query_object].second.first.inspect
filter_results.first[:result]['MONTH'].first[:query_object].second.first.sql
filter_results.first[:result]['MONTH'].first[:query_object].second.first.to_hash
filter_results.first[:result]['MONTH'].first[:query_object].second.first
filter_results.first[:result]['MONTH'].first[:query_object].second.first.metric
filter_results.first[:result]['MONTH'].first[:query_object].second.first
exit!
youtube_result
whereami
YoutubeMetric.metric_profiles_by_uniques_to_reach
TwitterMetric.top_1_daily_by_followers
ReachYoutubeFilter.new(YoutubeMetric.metric_profiles_by_uniques_to_reach, filters)
exit!
youtube_result
exit
results
exit
r.daily
organic
total
exit
organic
total
exit
Geoventure
GeoventureThematic
GeoventureThematic.first
GeoventureThematic.all
GeoventureThematic.all.first
GeoventureThematic.all
GeoventureThematic.all.count
GeoventureThematic.all[0]
GeoventureThematic.first
GeoventureThematic.second
GeoventureThematic.last
GeoventureThematic.find(4)
GeoventureThematic.find(4).ponto
GeoventureThematic.find(4).pontos
GeoventureThematic.all
reload!
GeoventureThematic.all
reload!
GeoventureThematic.all
GeoventureThematic.first
GeoventureThematic.all
reload!
GeoventureThematic.all
GeoventureThematic.first
reload!
GeoventureThematic.first
reload!
GeoventureThematic.first
GeoventureThematic.first.shapes
GeoventureThematic.first
reload!
GeoventureThematic.first
GeoventureThematic.first.shapes
GeoventureThematic.first.shapes.length
GeoventureThematic.first
GeoventureThematic.all
exit
VentureGeo.count
VentureGeo.delete_all
exit
{a:1,b:2}
{a:1,b:2}.except(:b)
exit
@result
exit
@result
exit
@result
eit
exit
to_queyr
to_query
param
param.key
exit
key
value
exit
param.second
exit
{a:1, b:2}.map {k,v| k}
{a:1, b:2}.to_a.map {k,v| k}
{a:1, b:2}.map {|k,v| k}
{a:1, b:2}.map {|k,v| k, v}
{a:1, b:2}.map {|k,v| {k => v}}
{a:1, b:2}.map {|k,v| {k => v}}.flatten
exit
to_query
exit
@result
ventures_filter_query
exit
@result
ventures_filter_query
exit
@result
ventures_filter_query
exit
@result
exit
[1,2,3].reject{|v| v==3}
exit
GeoventureThematic
GeoventureThematic.first
GeoventureThematic.first.shapes
GeoventureThematic.to_feature_collection GeoventureThematic.first
GeoventureThematic.to_feature_collection [GeoventureThematic.first]
_.size
x=GeoventureThematic.to_feature_collection [GeoventureThematic.first]
x.size
z.to_json
x.to_json
exit
x=GeoventureThematic.to_feature_collection [GeoventureThematic.first]
x.to_json
GeoventureThematic.first
RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection([]))
RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection([])).to_json
exit
nil.to_json
exit
whereami
exit
VentureGeo.where(origin_id: 7)
VentureGeo.where(origin_id: 7).first
VentureGeo.where(origin_id: 7).first.attributes
VentureGeo.where(origin_id: 7).first.update shape_data: nil
VentureGeo.new
VentureGeo.where(origin_id: 7).first.update shape_data: nil
x=VentureGeo.where(origin_id: 7).first
x.update shape_data: nil
x.errors
x.shape_data= nil
x
x.save(validate: false)
exit
facebook_result
whereami
FanAcquisitionFacebookFilter.new(FacebookPageMetric.metric_likes_life_time, filters)
FanAcquisitionFacebookFilter.new(FacebookPageMetric.metric_likes_life_time, filters).result
exit
query
opts
period
social_networks
product
campaign
brand
scope
query
whereami
query
exit
query
query.class
query.class.name
query.class
query.class.module
query.class.parent_name
query.class.module
query.class.modules
query.class.hierarchical
query.class.hierarchical?
query
exit!
params
filters
exit
exit!
params
filters
filters[:filter_level_owned]
filters['filter_level_owned']
exit
[].include? nil
exit!
filter_params
filter_params['filter_level_owned']
social.to_s
social.to_s.upcase
exit
filter_params['filter_level_owned']
exit
filter_params['filter_level_owned']
exit
User.first
exit
License.find(17)
l=_
l.update expiration_date: Date.today + 2.days
'asc'.to_r
/#{'asc'}/
exit
GeoventureThematic
GeoventureThematic.all
GeoventureThematic.all.group_by {|a,b| a.status_da_licenca <=> b.status_da_licenca }
GeoventureThematic.all.group {|a,b| a.status_da_licenca <=> b.status_da_licenca }
GeoventureThematic.all.group {|geoventure| geoventure.status_da_licenca }
GeoventureThematic.all.group_by {|geoventure| geoventure.status_da_licenca }
GeoventureThematic.all.group_by {|geoventure| geoventure.status_da_licenca.split(' ')[0..1].join(' ') }
GeoventureThematic.all.group_by {|geoventure| geoventure.status_da_licenca.split(' ')[0..3].join(' ') }
GeoventureThematic.first
GeoventureThematic.all.second
GeoventureThematic.all.third
exit
License.find(17)
l=_
l.update expiration_date: Date.today + 2.days
exit
Rails.cache
Rails.session
Rails::Session
session
session.hierarch
session.ancestors
session.class
session.class.ancestors
cookei
cookie
cookies
cookies.class
cookies.class.ancestors
exit
90.minutes
exit
eventual_requirements_filter
EventualRequirementThematic.where(filter_query)
filter_query
next
exit
EventualRequirementThematic.first
EventualRequirementThematic.last
EventualRequirementThematic.where('pontos_e_shapes IS NOT NULL')
EventualRequirementThematic.where('pontos_e_shapes IS NOT NULL').first
EventualRequirementThematic.where('pontos_e_shapes IS NOT NULL').first.pontos_e_shapes
exit
result
@result
@result.to_a
exit
@result
@result.first
@result.first.to_feature
exit
@result
whereami
result
result.first
exit
result
exit
EventualRequirementThematic
EventualRequirementThematic.size
EventualRequirementThematic.count
EventualRequirementThematic.all
exit
@result
exit
x=ColorMath::HSL.new 350, 1, 1
x.hex
x=ColorMath::HSL.new 300, 1, 1
x.hex
x=ColorMath::HSL.new 100, 1, 1
x.hex
x=ColorMath::HSL.new 350, 1, 0.88
x.to_s
x.hex
x.rgb
x.r
x
ColorMath::HSL.new(100, 1, 0.88).hex
ColorMath::HSL.new(100, 1, 0.5).hex
x=ColorMath::HSL.new(100, 1, 0.88)
x.blue
x.red
exit
facebook_result
facebook_result.first
exit!
facebook_result.first
facebook_result.first[:result]
facebook_result.first[:result].first
facebook_result.first[:result].first.total
facebook_result.first[:result].first.social_network
exit
results
results.flatten
exit!
reach_data
charts
exit
reach_data
chart_data
exit
charts
exit
exi
exit
reach_data
eixt
exit
reach_data
chart_data
exit
exit!
charts
charts.first
charts.first[:dimensions]
charts.first[:dimensions].first
charts.first[:dimensions].last
charts.first[:dimensions].last[:series]
charts.first[:dimensions].last[:series].first
charts.first[:dimensions].last[:series].map{|s| {name: s[:name], values: [s[:values].last]}
}
1233.to_a
Array(123)
Array.new(123)
exit!
charts
exit!
@result
whereami
@theme  = eventual_requirements_filter[:tema]
@theme
@result.group_by(@theme)
@result.group_by{|r| r.send(@theme) }
x=@result.group_by{|r| r.send(@theme) }
x.keys
x=@result.group_by{|r| r.try(@theme) }
x.keys
x=@result.group_by{|r| r.try(@theme) }
exit
@result
EventualRequirementThematic.where(filter_query(eventual_requirements_filter)) 
exit
@result
exit
@result
exit
@result
@theme
exit
@result
@result.keys
@result.group_by{|r| r.try(@theme) }
@result.group_by{|r| r.try(@theme) }.keys
exit
@result
@result.keys
@result.first
@result.first.keys
@result
exit
theme
result
result.class
result.class.first
result.first
result.first.class
result.first
result.first.sizr
result.first.size
exit
,lexit
exit
result
exit
index
theme
result
theme.key
theme.keys
theme.first
theme.last
exit
x=ColorMath::HSL.new(100, 1, 0.88)
x.hex
x.hex[1..2]
x.hex[1..2].hex
ColorMath::HSL.new(300, 1, 0.88)
ColorMath::HSL.new(400, 1, 0.88)
ColorMath::HSL.new(1000, 1, 0.88)
360/10
x
x.hex
x.hex.match /#/
x.hex.match /#{2}/
x.hex.match /#\w{2}/
x.hex.match /#(\w{2})/
x.hex.match /#(\w{2})(\w{2})/
x.hex.match /#(\w{2})(\w{2})(\w{2})/
y=x.hex.match /#(\w{2})(\w{2})(\w{2})/
y.first
y[0]
y[1]
y[2]
"00".hex
exit
@result
@theme
exit
::Configuration.first
::Configuration.all
default_params.merge(use_route: :static)
exit
confi
config
config.header_url
application_params.include? :header
exit
field
field_params
params
field_params
exit
field_params
whereami
field.actions
next
field.actions
exit
whereami
key
value
exit
query
data.where(query, value)
xit
exit
data.where(query, value)
exit
qvalu
value
query
exit
data.where(query, value)
data.to_sql
data.where(query, value)
data.where('1=1')
data.to_sql
exit
data.where('1=1'
)
data.where(query, value)
data.to_sql
data.where(query, value).to_sql
data.where(query, value).where('1=1').to_sql
exit
data
exit
params[:licensing_schedules][:schedule_of_work].slice(:data_de_inicio_da_operacao)
params[:licensing_schedules][:schedule_of_work]
exit
params[:licensing_schedules][:schedule_of_work].slice(:data_de_inicio_da_operacao)
exit
schedule_of_work_params
schedule_of_work_params.merge(updated_at: Time.now)
@schedule_of_work.update(schedule_of_work_params.merge(updated_at: Time.now))
@schedule_of_work.update!(schedule_of_work_params.merge(updated_at: Time.now))
exit
@schedule_of_work.update(schedule_of_work_params.merge(updated_at: Time.now))
exit
venture_params
params.require(:licensing_schedules).permit(schedule_of_work: [:data_de_operacao])
exit
case_step.present?
next
fields
case_step.case_step_data_fields
next
self.case_step_data_fields.blank?
b]
my_step.my_fields.requireds.blank?
my_step.my_fields.requireds
exit
my_step.my_fields.requireds.blank?
exit
my_step.my_fields.requireds.blank?
exit
self.errors
@items_with_update.present?
exit
step_data_params
exit
licensing_schedule_data_da_solicitacao_da_licenca
self
licensing_schedule_data_da_solicitacao_da_licenca
licensing_schedule_data_da_solicitacao_da_licencax
exit
flow.steps
flow.steps.last
flow.steps.last.e
exit
steps_not_fulfilled
steps_not_fulfilled.class
steps_not_fulfilled.map(&:id)
steps_not_fulfilled ||= []
[].map(&:id)
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
user.groups.first.permissions
user.groups.first.permission
exit
response.body
exit
flow.steps.first
flow.steps.first.fields
flow.steps.first.fields.size
flow.reload.steps.first.fields
exit
response.body
exit
step_data_params
exit
step_data_params
exit
step_data_params
params
exit
step_data_params
exit
licensing_schedule
exit
step_data_params
exit
step_data_params
exit
@step_data
@step_data.errors
exit
step_data_params
exit
step_data_params
exit
step_data_params
exit
validate_permission!(:manage, Flow)
next
permission_types
permission_type
permission_types.include? permission_type
next
kase.status
kase.update status: 'active'
kase.status
next
kase.disabled_steps
next
case_step
next
validate_permission!(:update, case_step)
exit
exi
exit
require 'configu.ru'
exit
Flow.first
Step.last
Flow.first.versions
Flow.first.versions.map(&:reify)
exit
response.body
exit
safe_params[:new_version].to_i 
flow.versions.size
exit
parsed_body
exit
flow
flow.reload
exit
flow.versions
Flow.last
Flow.first
exit
flow.versions
exit
flow
flow.versions
exit
flow
flow.versions
exit
Flow.first
Flow.first.versions
Flow.first.versions.size
exit
Flow.last
Flow.first
Flow.first.versions
exit
flow
exit
Case.first
Case.first.initial_flow
Case.first.initial_flow.find_my_step_on_tree(5)
reload!
exit
step
x=step
x.id
step_id.to_i
exit
x=step
reload!
exit
Flow.find(safe_params[:flow_id]).steps
safe_params[:ids]
current_user
exit
next
e
exit
ids
exit
id
index
self
self.find(id)
self.find(id).order_number
index + 1
self.find(id).update!(order_number: index + 1) 
self.find(1)
x=self.find(id) 
x.order_number = index + 1
x.save
x
x.order_number = 1
x
exit
exitself.find(id).update_attribute(:order_number, index + 1) 
self.find(id).update_attribute(:order_number, index + 1) 
exit
id
self.find(id).update_attribute(:order_number, index + 1) 
exit
self.find(ids.first)
next
elem.get_flow
elem.get_flow.verify_if_need_create_version?
next
elem.last_version
elem.last_version.increment
elem.last_version + 1
elem
next
e
exit
elem.update(last_version: elem.last_version + 1, user: user)
elem.update_attributes(last_version: elem.last_version + 1, user: user)
elem.update!(last_version: elem.last_version + 1, user: user)
elem.update_attribute(:last_version, elem.last_version + 1)
Rails
Rails.version
exit
elem
elem.user
elem.get_flow.try(:verify_if_need_create_version?)
elem.update!(last_version: elem.last_version + 1, user: user)
whereami
elem.get_flow.try(:bump_version_cascade!, elem)
exit
elem.update!(last_version: elem.last_version + 1, user: user)
exit
elem.user
need_create_version_by_keys?
skip_flow
next
self.user
self.last_version
next
self.resolution_states.each { |i| i.update!(last_version: i.last_version + 1) if elem != i }
self.steps.first
self.steps.first.bump_version_cascade! elem
self.steps.second.bump_version_cascade! elem
exit
self
exit
self
elem
self
self.last_version
self.update!(last_version: self.last_version + 1) 
whereami
self.triggers.each { |t| t.bump_version_cascade! elem }
self.fields.each { |i| i.update!(last_version: i.last_version + 1) if elem != i } 
self.fields.each { |i| i.update!(last_version: i.last_version + 1, user: elem.user) if elem != i } 
self.fields.each { |i| i.update!(last_version: i.last_version + 1, updated_by: elem.user) if elem != i } 
self.fields.each { |i| i.update!(last_version: i.last_version + 1) if elem != i } 
exit
selgf
self
self.fields.each { |i| i.update!(last_version: i.last_version + 1) if elem != i } 
exit
self.fields.each { |i| i.update_attribute(:last_version, i.last_version + 1) if elem != i } 
self.fields
self.fields.first
self.fields.first.update_attribute(:last_version, 3)
exit
self.fields.first.update_attribute(:last_version, 3)
self.fields.first.update_attribute(:last_version, 3).to_sql
self.fields.first.update_attribute().to_sql
self.fields.first.update_attribute(nil, nil).to_sql
self.fields.first.update_attribute('1', '1').to_sql
exit
get_flow.try(:verify_if_need_create_version?)
get_flow
get_flow.reload
exit
object
self.step
self
self.step_id
Step.find(2)
Step.find(1)
Flow.find(1)
Trigger.find(1)
ActiveRecord::Base.connection.instance_variable_ge
ActiveRecord::Base.connection.instance_variable_get(:@statements).to_a
whereami
exit
ActiveRecord::Base.connection.instance_variable_get(:@statements).to_a
exit
self
self.step.where('1=1')
self.step
self
Flow.last.steps
exit
Flow.last.steps
Flow.first.steps
Flow.first.steps.last
uncached { self.step }
self.uncached { self.step }
Field.uncached { self.step }
exit
Field.uncached do
  Field.find(self.id).step
end
exit
ActiveRecord::Base.connection
ActiveRecord::Base.connection.clear_cache!
ActiveRecord::Base.connection.instance_variable_get(:@statements).to_a
whereami
self.step
ActiveRecord::Base.connection.instance_variable_get(:@statements).to_a
exit
self.step
exit
self.step.flow
exit
ActiveRecord::Base.connection.instance_variable_get(:@statements).to_a
exit
execute
Step.find(self.step_id)
Field.find(self.id)
Step.find(self.step_id).flow
Field.find(self.id).step
exit
Step.find_by_id(self.step_id)
Step.find_by_id(0)
exit
self.step_id
Step.find_by_id(self.step_id)
Step.find_by_id(self.step_id).flow
exit
self.fields.each { |i| i.update!(:last_version, i.last_version + 1) if elem != i } 
exit
self.fields.each { |i| i.update!(:last_version, i.last_version + 1) if elem != i } 
self.fields.each { |i| i.update!(last_version: i.last_version + 1) if elem != i } 
exit
self.step
exit
Flow
Flow::Entity
exit
self.my_steps
self.my_steps.to_json
self.my_steps
self.my_steps[A
  exit
exit
step
x=step
x.my_child_flow
x.user
x.user = x.my_child_flow
x
.to_hash
.to_h
x
x.to_json
x.attributes
x.attributes.merge(my_child_flow: x.my_child_flow)
x.attributes.merge(my_child_flow: x.my_child_flow).to_json
exit
AlertParameter
AlertParameter.first
subject
whereami
AlertParameter
AlertParameter.frist
AlertParameter.first
exit
subject
exit
Date.today
Date.stub(today: Date.today-2.days)
Date.today
exit
--- ividalserver.com ping statistics ---
33 packets transmitted, 0 packets received, 100.0% packet loss]
--- ividalserver.com ping statistics ---
DashboardEventualRequirement.by_status
DashboardEventualRequirement.all
DashboardEventualRequirement.all.group(:status)
DashboardEventualRequirement.all.select(:status).group(:status)
DashboardEventualRequirement.all.select('status, count(stauts)').group(:status)
DashboardEventualRequirement.all.select('status, count(id)').group(:status)
DashboardEventualRequirement.all.select('status, count(id) as total').group(:status).first
DashboardEventualRequirement.all.select('status, count(id) as total').group(:status)
x=DashboardEventualRequirement.all.select('status, count(id) as total').group(:status)
x.first
x.first.total
xit
exit
ActualLicenseStatus
exit
EventualRequirement.find(61)
EventualRequirement.find(61).update data_de_vencimento: Date.today + 1.day
exit
DashboardEventualRequirement.by_status
reload!
DashboardEventualRequirement.by_status
reload!
DashboardEventualRequirement.by_status
DashboardEventualRequirement.by_status.to_json
DashboardEventualRequirement.by_status
exit
subject
License.all
License.all.size
exit
step.my_child_flow.my_steps
step.my_child_flow.attributes
step.my_child_flow.attributes.merge(my_steps: step.my_child_flow.my_steps)
exit
AlertParameter.first
AlertParameter.first.update vencimento_de_licenca: Date.today + 10.days, vencimento_de_licenca_alerta_vermelho: Date.today + 3.days 
AlertParameter.first
Date.today + 10.days
exit
subject
exit
1.day.ahead
1.day.ago
1.day.head
1.day.after
1.day.since
exit
subject
Venture.last
exit
Venture.last
exit
Venture.last
exit
Venture.last
Venture.last.schedule_of_work
exit
Venture.last.schedule_of_work
exit
Venture
Venture.last
exit
Case.first
response.body
exit
response.body
exit
response.body
exit
current_step
kase
kase.case_steps
kase.case_steps.last
step
next
current_step
x=step
next
body
exit
next
e
exit
self.find(id)
index+1
self.find(id).update_attribute(:order_number, index+1)
exit
next
elem
elem.get_flow
next
e
exit
skip_flow
next
self.user
next
e
next
e
exit
next
e
exit
next
e
next
e
exit
next
e
exit
next
nex
next
e
exit
next
e
exit
elem
self
next
exit
self
self.flow
self.child_flow
self.last_version = self.last_version + 1
self.save(validate:false)
exit
self.reload.versions
whereami
sefl.reload.last_verion_id
self.reload.last_verion_id
self.reload.last_version_id
exit
next
e
exit
self.flow
next
self.relad.versions
self.reload.versions
next
e
exit
self.find(id)
next
elem
elem.reload
elem.reload.update!(last_version: elem.last_version + 1, user: user)
exit
elem.reload.update!(last_version: elem.last_version + 1, user: user)
exit
elem.update_columns last_version: elem.last_version+1, user:user
elem
elem.update_columns last_version: elem.last_version+1
elem.update_columns last_version: elem.last_version-1
elem
elem.update!(last_version: elem.last_version + 1)
exit
elem
exit
next
e
exit
Step.find(elem).update!(last_version: elem.last_version + 1, user: user)
exit
next
exit
next
exit
Step.find(1).triggers.first.trigger_conditions
Step.find(1).triggers.first.trigger_conditions.first
Step.find(1).triggers.first.trigger_conditions.first.field
Step.find(1).triggers.to_json
Trigger::Entity.represent(Step.find(1).triggers).to_json
Step.find(1).triggers.first.trigger_conditions.first.field
Trigger::Entity.represent(Step.find(1).triggers.first).to_json
exit
self.my_steps
self.my_steps.select{|s| s.step_type == 'form' }
self.my_steps.select{|s| s.step_type == 'form' }.map{&:my_case_steps)
self.my_steps.select{|s| s.step_type == 'form' }.map(&:my_case_steps)
self.my_steps.select{|s| s.step_type == 'form' }.map(&:my_case_steps).flatten
[5,9,4].sort_by{|n| n }
Step.last
Version.find(1219)
::Version.find(1219)
PaperTrail::Version.find(1219)
PaperTrail::Version.find(1219).reify
reload!
exit
Step.last
Step.first
Step.first.versions
Field.last
Field.first
Field.first.versions
Trigger.last
Step.first.versions
Field.last
Field.last.versions
Field.last
Field.first
Field.first.verions
Field.first.versions
Field.first.versions.map(&:reify)
Field.first.versions
Versio.last
Version.last
Version.last.reify
Version.last.reify.version
Version.last.reify.version.id
ResolutionState.find(5)
ResolutionState.find(5).version
ResolutionState.find(5).version.id
exit
Trigger.last
Trigger.last.trigger_conditions
Trigger.last.trigger_conditions.first
reload!
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.update condition_type: '>'
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.update condition_type: '>'
Trigger.last.trigger_conditions.first
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.update condition_type: '=='
Trigger.last.trigger_conditions.first
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.update condition_type: '>'
get_flow.verify_if_need_create_version? ?
end
get_flow.verify_if_need_create_version?
self.changes.keys.select{|key| KEYS_TO_CREATE_VERSION.include? key }.present?
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.update condition_type: '=='
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.versions.count
Trigger.last.trigger_conditions.first.update condition_type: '>'
exit
Trigger.last.trigger_conditions.first.versions.count
Trigger.last.trigger_conditions.first.update condition_type: '>'
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.versions.count
Trigger.last.trigger_conditions.first.update condition_type: '=='
Trigger.last.trigger_conditions.first.versions.count
exut
exit
Trigger.last.trigger_conditions.first.versions.count
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.update condition_type: '>'
self.changes
exit
Trigger.last.trigger_conditions.first.versions.count
Trigger.last.trigger_conditions.first.update status: :active
Trigger.last.trigger_conditions.first.update status: 'active'
self.changes
self.changes[:status]
self.status_change
self.condition_type_change
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.versions.size
Trigger.last.trigger_conditions.first.update condition_type: '=='
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.versions.size
Trigger.last.trigger_conditions.first.draft
Trigger.last.trigger_conditions.first.send('get_flow')
exit
Trigger.last.trigger_conditions.first
Trigger.last.trigger_conditions.first.versions.size
Trigger.last.trigger_conditions.first.update draft: false
exit
Trigger.last.trigger_conditions.first.versions.size
Trigger.last.trigger_conditions.first.update draft: false
Trigger.last.trigger_conditions.first.send('get_flow')
Trigger.last.trigger_conditions.first.send('get_flow').verify_if_need_create_version?
Trigger.last.trigger_conditions.first.version
Trigger.last.trigger_conditions.first.version.to_i
Trigger.last.trigger_conditions.first.previous_version
Trigger.last.trigger_conditions.first.version.id
Trigger.last.trigger_conditions.first.previous_version
Trigger.last.trigger_conditions.first.previous_version.version
Trigger.last.trigger_conditions.first.previous_version.version.id
Trigger.last.trigger_conditions.first.version.id
Trigger.first
Step.first
Step.first.previous_version
Step.first.versio
exit
User.create(name: 'Eurico', email: 'email@example.com', password: '123456abc').confirm!
User.last.groups << Group.first
exit
Venture.find(1).schedule_of_work
Venture.find(1).schedule_of_work.update updated_at: Time.now - 5.days
exit
Version.last
Version.where(item_type: 'ResolutionState')
PaperTrail::Version.where(item_type: 'ResolutionState')
PaperTrail::Version.where(item_type: 'ResolutionState').where_object(title: 'estado 2')
Version.last
Version.last.changeset
Version.first.changeset
Version.first(10).map(&:changeset)
Version.first(100).map(&:changeset)
exit
Version.first(100).map(&:changeset)
PaperTrail::Version.where(item_type: 'ResolutionState').where_object(title: 'estado 2')
PaperTrail::Version.where(item_type: 'ResolutionState')
PaperTrail::Version.where(item_type: 'ResolutionState').where_object(title: 'estado 2').select(:id)
PaperTrail::Version.where(item_type: 'ResolutionState').select(:id)
PaperTrail::Version.where(item_type: 'ResolutionState')
PaperTrail::Version.where(item_type: 'ResolutionState').order(id: :desc)
PaperTrail::Version.where(item_type: 'ResolutionState').order(id: :desc).group_by(:item_id)
PaperTrail::Version.where(item_type: 'ResolutionState').order(id: :desc).group(:item_id)
x=_
x.id
PaperTrail::Version.where(item_type: 'ResolutionState').order(id: :desc).group(:item_id).pluck(:id)
PaperTrail::Version.where(item_type: 'ResolutionState').order(id: :desc).group(:item_id).pluck(:id).to_sql
PaperTrail::Version.where_object(title: 'estado 2')
PaperTrail::Version.where_object()
exit
{1:111,2:222,3:333}.values
{1=>111,2=>222,3=>333}.values
:step.to_s_camelize
:step.to_s.camelize
:st_ep.to_s.camelize
PaperTrail::Version.where_object(title: 'estado 2')
PaperTrail::Version.where(item_type: 'ResolutionState').order(id: :desc)
PaperTrail::Version.last
PaperTrail::Version.last.reify
PaperTrail::Version.last.reify.where
PaperTrail::Version.last.reify
ResolutionState.last
ResolutionState.last.update! last_version: 3
PaperTrail::Version.last.reify
exit
Version.where('ResolutionState', 361..500, {title: 'estado 2'})
Version.where('ResolutionState', 361..500.to_a, {title: 'estado 2'})
Version.where('ResolutionState', (361..500).to_a, {title: 'estado 2'})
exit
Version.where('ResolutionState', (361..500).to_a, {title: 'estado 2'})
class_name
ids
whereami
where(item_type: class_name, id: ids)
where({item_type: class_name, id: ids})
exit
Version.where('ResolutionState', (361..500).to_a, {title: 'estado 2'})
exit
self.versions
self.previous_versions
self.previous_version
self.previous_version.version
exit
self.previous_version.version
self.previous_version
self.versions
slef.version
self.version
exit
self.version
exit
self.steps_versions
self.steps_versions.values
exit
self.steps_versions
self.steps_versions.values
exit
self.steps_versions.values
exit
self.steps_versions.values
exit
self.steps_versions.values
exit
self.steps_versions.values
self.steps_versions
self.steps_versions.to_hash
self.steps_versions.to_h
Hash(self.steps_versions)
Hash({1=>111})
Hash({1=>111,2=>222,3=>333})
Hash.new({1=>111,2=>222,3=>333})
Hash({1=>111,2=>222,3=>333})
{1=>111,2=>222,3=>333}.to_h
x={1=>111,2=>222,3=>333}
x.object_id
Hash(x).object_id
x.to_h.object_id
exit
Version.where('ResolutionState', (361..500).to_a, {title: 'estado 2'})
{}.values
exit
Version.last
Version.last.reify
Version.last.reify.versions
ResolutionState.find(7).versions
ResolutionState.last
ResolutionState.first
Field.first
Field.first.versions
Field.find(9999)
exit
self
self.user
exit
self
exit
self
exit
self
exit
{1=>111,2=>222,3=>333}
{1=>111,2=>222,3=>333}.map{|k,v k}
{1=>111,2=>222,3=>333}.map{|k,v| k}
{1=>111,2=>222,3=>333}.map{|k,v| {k=>v}}
{1=>111,2=>222,3=>333}.map{|k,v| {k=>v}}.flatten
{1=>111,2=>222,3=>333}.map{|k,v| {k=>v}}.compact
{1=>111,2=>222,3=>333}.inject({}){|n,h| h}
{1=>111,2=>222,3=>333}.inject({}){|n,h| h.key}
{1=>111,2=>222,3=>333}.inject({}){|n,h| {h.first=>h.last}}
{1=>111,2=>222,3=>333}.inject({}){|n,h| n[h.first] = h.last}
{1=>111,2=>222,3=>333}.inject({}){|n,h| n[h.first] = h.last; n}
{1=>111,2=>222,3=>333}
{1=>111,2=>222,3=>333}.first
{1=>111,2=>222,3=>333}.secound
{1=>111,2=>222,3=>333}[0]
{1=>111,2=>222,3=>333}.to_a
Field.first.previous_version
Field.first
Field.last
Field.last.previous_version
Flow.find(2)
Flow.find(2).steps
Flow.find(2).update steps_versions: Flow.find(2).steps.pluck(:id).inject({}){|list, id| list[id] = nil; list}
Flow.find(2).steps.pluck(:id).inject({}){|list, id| list[id] = nil; list}
Flow.find(2).steps.pluck(:id).inject({}){|list, id| list[id] = Step.find(id).versions.last.id; list}
steps_versions = Flow.find(2).steps.pluck(:id).inject({}){|list, id| list[id] = Step.find(id).versions.last.id; list}
Flow.find(2).update steps_versions: steps_versions
exit
steps_versions = Flow.find(2).steps.pluck(:id).inject({}){|list, id| list[id] = Step.find(id).versions.last.id; list}
Flow.find(2).update steps_versions: steps_versions
super(item_type: class_name, id: ids)
super({item_type: class_name, id: ids})
x=super({item_type: class_name, id: ids})
PaperTrail::Version.where({item_type: class_name, id: ids})
PaperTrail::Version.where({item_type: class_name, id: ids}).size
ids
PaperTrail::Version.where({item_type: class_name, id: ids}).size
exit
Flow.find(safe_params[:id]
)
f=_
f
Flow::Entity.represent(f)
Flow::Entity.represent(f).to_json
exit
self.steps_versions
self
exit
steps_versions = Flow.find(2).steps.pluck(:id).inject({}){|list, id| list[id] = Step.find(id).versions.last.id; list}
Flow.find(2).update steps_versions: steps_versions
resolutions_versions = Flow.find(2).resolution_states.pluck(:id).inject({}){|list, id| list[id] = ResolutionState.find(id).versions.last.id; list}
Flow.find(2).update resolution_states_versions: resolutions_versions
x={1=>111,2=>222,3=>333}
x['1']
Field.last.previous_version
Field.first
Field.first.previous_version
exit
x={1=>111,2=>222,3=>333}
x[1] = 121
x
Field.first.previous_version
Field.first
x=Field.first
x.requirements = {1=>111,2=>222}
x.requirements[1] = 121
x
x.save
x
x.previsous_version
x.reload.previsous_version
x.previous_version
exit
Flow.find(safe_params[:flow_id]).resolution_states
Flow.find(safe_params[:flow_id]).resolution_states.find_by_default(true)
next
old_default
next
parameters
next
e
Flow.last
exit
parameters.delete(:user)
parameters
exit
Flow.last
Flow.last.destroy!
Flow.last
Flow.last.destroy!
exit
self.id
exit
Flow.last.destroy!
Flow.last
Flow.last.destroy!
Flow.last
exit
Flow.last.publish!
self.my_resolution_states
exit
next
resolution.versions
exit
self
self.resolution_states.first.previous_version
self.resolution_states.first.previous_version.version
self.resolution_states_versions = {"12"=>962}
next
exit
Flow.last.versions
Flow.last.versions.reify
Flow.last.previous_versions
Flow.last.previous_version
Flow.last
Flow.last.versions
Flow.last.destroy!
Version.find(963)
exit
Flow.last
Flow.last.publish!
exit
return
exit
Flow.last.versions
Flow.last.publish!
exit
resolution.versions
exit
Flow.last.publish!
exit
next
resolution.versions
next
resolution.versions
exit
Flow.last.destroy!
exit
Flow.last.destroy!
exit
Flow.last.destroy!
Flow.last
Flow.last.publish!
exit
next
resolution.versions
next
resolution.versions
resolution.reload.versions
self.class.versions_association_name
return 
exit
Flow.last
Flow.last.versions
Flow.last.resolution_states.versions
Flow.last.resolution_states.first.versions
Flow.last.publish!
exit
Flow.last.publish!
exit
next
resolution.version
resolution.versions
next
error
Flow.last
Flow.last.send('object_attrs = object_attrs_for_paper_trail(self)
  object_value = self.class.paper_trail_version_class.object_col_is_json? ? object_attrs : PaperTrail.serializer.dump(object_attrs)
  data = {
    event: 'associations_change', # or some custom event name?
    object: object_value,
    whodunnit: PaperTrail.whodunnit
  }
  send(self.class.versions_association_name).create! merge_metadata(data)
end
)
}
'
Flow.last.send('object_attrs_for_paper_trail')
Flow.last.object_attrs_for_paper_trail
exit
Flow.last.publish!
exit
next
error
exit
Flow.last.publish!
exit
next
resolution.versions
resolution.versions.reify
resolution.versions.first.reify
exit
Flow.last
Flow.last.versions
exit
Flow.last.destroy!
exit
Flow.last.versions
Flow.last.publish!
exit
Flow.last.publish!
Flow.last
Flow.last.destroy!
Flow.last.publish!
Flow.last
exit
Flow.last.destroy!
Flow.last.publish!
resolution.versions
self.resolution_states_versions
self.resolution_states_versions[resolution.id.to_s]
resolution.id
resolution.id.to_s
self.resolution_states_versions['18']
resolution.previous_version
resolution.previous_version.version
resolution.previous_version.version.id
next
self
next
self
exit
Flow.last
f=Flow.last
f.resolution_states_versions['18'] = '123'
f.save
f.reload
f=Flow.last
f.resolution_states_versions['18'] = '123'
f.resolution_states_versions = f.resolution_states_versions
f.save
f.reload
f=Flow.last
f.resolution_states_versions = {'18'=>'123'}
f.save
f.reload
f=Flow.last
f.resolution_states_versions['18'] = '1234'
f.resolution_states_versions = f.resolution_states_versions.to_hash
f.save
f.reload
f=Flow.last
f.resolution_states_versions = f.resolution_states_versions.dup
f.save
f.reload
f=Flow.last
f.resolution_states_versions['18'] = '1234'
f.resolution_states_versions = f.resolution_states_versions.dup
f.save
f.reload
f=Flow.last
f.resolution_states_versions['18'] = '1234'
f.resolution_states_versions.dup
x=f.resolution_states_versions.dup
f.resolution_states_versions = x
f.save!
f.reload
f=Flow.last
f.resolution_states_versions['18'] = '1234'
f.resolution_states_versions.object_id
f.resolution_states_versions.dup.object_id
x=f.resolution_states_versions.dup
x.object_id
x.class
f.update!(resolution_states_versions: x)
f.reload
{'18'=>'1234'}.class
x={'18'=>'1234'}
f.update!(resolution_states_versions: x)
f.reload
exit
f=Flow.last
f.resolution_states_versions['18'] = '12'
x=f.resolution_states_versions.dup
f.update!(resolution_states_versions: x)
f.reload
f.update!(resolution_states_versions: {'18'=>'124'})
f.reload
exit
ResolutionState.last.update draft: true
Flow.last
Flow.last.publish!
self
exit
Flow.last.destroy!
Flow.last.publish!
resolution.versions
resolutions_versions
next
resolutions_versions
next
self
self.save!
self.
end
self
self.reload
exit
Flow.last.destroy!
Flow.last.publish!
Flow.last
exi
exit
Flow.last.publish!
Flow.last
Flow.last.publish!
exit
Flow.last.destroy!
Flow.last
Version.last
Version.last.reify
Version.last.changes
Version.last.changeset
exit
Flow.last.publish!
Flow.last
Flow.last.previous_version
Flow.last.previous_version.whodunnit
Flow.last.versions.first
Flow.last.versions.first.changeset
Flow.last.versions.first.object_changes
Flow.last.destroy!
Flow.last.publish!
Flow.last.destroy!
Flow.last.publish!
Flow.last.versions.first
Flow.last.versions.first.object_changes
Flow.last.destroy!
exit
Flow.last.publish!
resource.class.paper_trail_version_class.object_changes_col_is_json?
resource.send('changes_for_paper_trail')
exit
Version.last
Version.last.event
Version.last.reify
Version.last.reify.resolution_states
Version.last.reify.my_resolution_states
ResolutionState.last.touch
Version.last.reify.resolution_states
ResolutionState.last.update draft: true
Version.last.reify.resolution_states
Version.last.reify.my_resolution_states
Version.last.reify.resolution_states.class
Version.last.reify.my_resolution_states.class
exit
Flow.last.destroy!
Flow.last.publish!
Flow.last
Flow.last.versions
Flow.last.attributes
Flow.last.previous_version.attributes
a=Flow.last.attributes
b=Flow.last.previous_version.attributes
a - b
a.to_a - b.to_a
Hash(a.to_a - b.to_a)
Hash(*a.to_a - b.to_a)
Hash(*(a.to_a - b.to_a))
Hash(a.to_a - b.to_a)
Hash((a.to_a - b.to_a).flatten)
Hash(*(a.to_a - b.to_a).flatten)
Hash[*(a.to_a - b.to_a).flatten]
exit
key
value
next
query
value
data
data.to_sql
data.where(query, value)
exit
ActualLicenseStatus.first
reload!
ActualLicenseStatus.first
reload!
ActualLicenseStatus.first
reload!
ActualLicenseStatus.first
exit
Version.last
Version.last.reify
Version.last.reify.destroy!
Flow.find(24)
Version.last
Flow.last
Flow.last.versions
Flow.last.versions.first
Flow.last.versions.first.reify
Flow.last.versions.first
Flow.last
Flow.last.destroy!
Flow.last
Flow.last.publish!
exit
Flow.last.publish!
exit
Flow.last.publish!
exit
Flow.last.publish!
next
error
exit
Flow.last.publish!
exit
next
exit
Flow.last.publish!
self.user
self.updated_by
exit
Flow.last.publish!
exit
next
error
exit
Flow.last.publish!
exit
self.draft?
self.draft
self.changes
self.changed_draft
self.draft_changed?
exit
Flow.last.publish!
exit
Flow.last.publish!
Flow.last
exit
flow
other_flow
parent_flow
exit
parent_flow
whereami
flow
parent_flow
parsed_body
exit
parsed_body
flow
parsed_body
Flow::Entity.represent flow
JSON.parse Flow::Entity.represent(flow).to_json
parsed_body
JSON.parse Flow::Entity.represent(flow).to_json
exit
self.id
get_flow
get_flow.update! updated_by: self.user, resolution_states_versions: get_flow.resolution_states_versions.merge(self.id.to_s => nil)
exit
parsed_body
exit
get_flow.update! updated_by: self.user, resolution_states_versions: get_flow.resolution_states_versions.merge(self.id.to_s => nil)
get_flow
exit
parsed_body
exit
parsed_body
exit
get_flow
get_flow.reload
exit
get_flow
get_flow.reload
exit
get_flow
get_flow.reload
exit
get_flow.reload
exit
get_flow.reload
exit
get_flow.reload
exit
parsed_body
exit
step
flow.reload.versions
exit
actual_version
flow.versions.first
exit
flow
exit
next
exit
user
flow
flow.reload
flow.reload.update! draft: true, updated_
exit
Flow.last.publish!
Flow.last.versions
Flow.last.previous_version
Flow.last.previous_version.destroy!
Flow.last
Version.last
{1=>111,2=>222,3=>333}.delete(1)
x={1=>111,2=>222,3=>333}
x.delete(1)
x
x.delete!(1)
exit
exut
exit
exitexit
exit
field_version
field_versions
exit
step.update(triggers_versions: trigger_versions, fields_versions: field_versions, user: self.user, draft: false)
exit
next
self
exit
self
self.flow
self.relation
exit
flow.reload.steps_versions
flow.steps.first.id
flow.steps.last.id
exit
{"#{steps_ids.first}" => nil, "#{steps_ids.last}" => nil}
reload_flow.steps_versions
{"#{steps_ids.first}" => nil, "#{steps_ids.last}" => nil} == reload_flow.steps_versions
exit
next
get_flow
ids
next
order_ids
exit
ids
exit
ids
exit
ids
next
get_flow
next
exit
next
self.user
self.user_id
exit
parameters
exit
step.reload
exit
User.last
user
User.last
exit
self.user
exit
step.reload
exit
License.all
whereami
create(:activity_form_program, recorrencia_periodica: true, duracao_evento_recorrente: 10)
Activity.all
Activity.first.events
Venture.last
Venture.last.licenses
License.last
exit
create(:activity_form_program, recorrencia_periodica: true, duracao_evento_recorrente: 10)
License.last
License.last.environment_programs
License.last.environment_programs.last
License.last.environment_programs.last.activities
License.last.environment_programs.first
License.last.environment_programs.first.activities
Activity.last
exit
Venture.last
Venture.last.licenses
Venture.last.licenses.last
Venture.last.licenses.last.environment_programs
Venture.last.licenses.last.environment_programs.ast
Venture.last.licenses.last.environment_programs.last
Venture.last.licenses.last.environment_programs.last.activities
Venture.last.licenses.last.environment_programs.first.activities
exit
create_list(:event, 3, activity: activity)
exit
Date.today
exit
Date.today
exit
Date.today
Time.now
exit
1.month
1.month.ago
1.month.noq
1.month.now
1.month.today
1.month.future
1.month.since
exit
self.trigger
self.trigger.trigger_conditions_versions
exit
response.body
exit
response.body
exit
self.versions
self.step
exit
self.destroy!
self.trigger_conditions
self.trigger_conditions.first.versions
exit
self.user
self
self.reload
exit
self.step
self.step.reload
exit
step.reload
exit
Flow.find(26)
Flow.find(26).steps.first
Flow.find(26).steps.first.fields
Flow.find(26).steps.first
Flow.find(26)
Flow.find(26).the_version
Flow.find(26).the_version.my_steps
Flow.find(26).the_version.my_steps.first
Flow.find(26).the_version.my_steps.first.my_fields
Flow.find(26).the_version.my_steps.first.my_fields.first
Flow.find(26).versions
exit
Field.last
Flow.last
Flow.last.my_steps
Flow.last
Flow.last.my_steps
Flow.last.reload.my_steps
Field.last
{1=>111,2=>222,3=>333}.map {|k| k }
{1=>111,2=>222,3=>333}.map {|k,v| k }
exit
Field.last
Field.last.versions
Field.last.destroy!
Flow.last.reload
Flow.last.reload.versions
Flow.last.the_version
Flow.last.the_version.my_steps
Field.last.destroy!
Field.last
Field.last.step
exit
next
exit
field_versions
exit
next
error
exit
next
self.my_steps({}, true)
next
resource
resource.versions
resource.version
next
exit
Flow.find(26).versions.size
Flow.find(26).versions
x &&= 1
x=false
x &&= 1
x=true
x &&= 1
Flow.find(26).versions.class
Flow.find(26).versions.is_a? Array
Flow.find(26).version
Flow.find(26).resolution_states
Version.build! Flow.find(26).resolution_states.first
exit
Flow.where.not(id: 1)
Flow.last.resolution_states
Flow.last(2)
Flow.find(26).resolution_states
Flow.find(26).resolution_states.where(default: true)
Flow.find(26).resolution_states.where(default: true).not(draft: true)
Flow.find(26).resolution_states.all.where(default: true).not(draft: true)
Flow.find(26).resolution_states.all.where('default IS TRUE AND id != ?', 1)
Flow.find(26).resolution_states.where('default IS TRUE AND id != ?', 1)
Flow.find(26).resolution_states.where('default IS TRUE AND id != ?', 1).all
Flow.find(26).resolution_states.where('default IS TRUE AND id != ?', 1).to_sql
Flow.find(26).resolution_states.where('default IS TRUE').to_sql
Flow.find(26).resolution_states.where('default IS TRUE').all
Flow.find(26).resolution_states.where('default = TRUE').all
Flow.find(26).resolution_states
Flow.find(26).resolution_states.where('default = t')
Flow.find(26).resolution_states.where('default = t').first
Flow.find(26).resolution_states.where('`default` = t').first
Flow.find(26).resolution_states.where("'default' = t").first
Flow.find(26).resolution_states.where('default = t')
exit
next
resolution_default
exit
next
exit
next
exit
my_version
current_version
self.current_version
self
self.version
exit
flow.my_cases
flow.my_cases.present?
exit
flow.cases_arent_useing?
flow.cases_arent_using?
exit
flow.versions
next
flow.my_cases
exit
flow.my_cases
self.version
versions
versions.last.version
versions.last
exit
flow.my_cases
exit
flow.my_cases
next
cases.where(options.merge(flow_version: my_version))
cases
self.reload
self.reload.cases
exit
self.reload.cases
exit
response.body
exit
response.body
exit
Faker::Lorem.sentence 1
Faker::Lorem.sentence 2
Faker::Lorem.sentence 
Faker::Lorem.sentence 10
exit
venture
venture.licensing_schedules
step_data
whereami
l=create(:license, venture: venture, step_data: step_data) 
l.venture
exit
next
initial_flow
next
e
exit
next
step
x=step
next
exit
next
x=step
next
exit
next
e
exit
next
exit
next
initial_flow
initial_flow.version
initial_flow.version.i
initial_flow.version.id
next
step
exit
next
x=step
x.active
kase.case_steps.build(step: step)
next
e
exit
next
e
exit
step
[].flatten
x=1..10
x=1(..10)
x=(1..10)
x=(1..10).to_a
x[3]
x[3].next
x.index(3)
x.index(3).next
exit
Flow.last
Flow.last.reify
Flow.last.previsous_version
Flow.last.previous_version
Flow.last.versions
Flow.last.destroy!
Flow.last.versions
Flow.last.previous_version
Flow.last.previous_version.version
Version.reify(Flow.last.previous_version.version.id)
Version.reify(Flow.last.previous_version.version.id).version
Version.reify(Flow.last.previous_version.version.id).my_steps
Version.reify(Flow.last.previous_version.version.id).my_steps.first
Version.reify(Flow.last.previous_version.version.id).my_steps.first.version
Flow.last.previous_version.my_steps.first.version
Flow.last.previous_version.my_steps.first.versions
Flow.last.previous_version.my_steps.first.item
Flow.last.previous_version.my_steps.first.lice?
Flow.last.previous_version.my_steps.first.live?
Flow.last.previous_version.my_steps.first.index
Flow.last.previous_version.my_steps.first.sibling_versions
Flow.last.previous_version.my_steps.first.source_version
Flow.last.previous_version.my_steps.first.call(:source_version)
Flow.last.previous_version.my_steps.first.send(:source_version)
Flow.last.previous_version.my_steps.first.send(:source_version).live?
Flow.last.previous_version.my_steps.first.send(:source_version)
Step.last.live?
Flow.last.previous_version.my_steps.first.ancestors
Flow.last.previous_version.my_steps.first.class.ancestors
Flow.last.previous_version.class.ancestors
Flow.last.previous_version.version
Flow.last.previous_version.my_steps.first.version
Flow.last.previous_version
Version.reify(999)
Version.reify(1013)
Version.reify(1013).version
Version.reify(1009).version
Version.reify(1009).versions
Version.reify(1013).versions
Version.reify(1013).versions.first.version
Version.reify(1013).versions.first.reify.version
Version.reify(1013).versions.first.reify(has_one: false)
Version.reify(1013).versions.first.reify(has_one: false).version
Version.reify(1013).versions.first.reify(has_one: true).version
PaperTrail::Version.find(1013).reify
PaperTrail::Version.find(1013).reify.version
exit
PaperTrail::Version.find(1013).reify
PaperTrail::Version.find(1013).reify.version
PaperTrail::Version.find(1013)
PaperTrail::Version.last
PaperTrail::Version.last.reify
PaperTrail::Version.last.reify.version
PaperTrail::Version.where(item_type: 'Step').last
PaperTrail::Version.where(item_type: 'Step').first
PaperTrail::Version.where(item_type: 'Step').first.reify
PaperTrail::Version.where(item_type: 'Step').first.reify.version
Version.destroy_all
Version.all
Flow.last
Flow.last.destroy!
Flow.last
Flow.destroy_all
Case.destroy_all!
Case.destroy_all
Flow.destroy_all
CaseStep.destroy_all
Flow.destroy_all
exit
Flow.last.the_version(true)
Flow.last.the_version(true).version
Flow.last.the_version(true).my_resolution_states
Flow.last.the_version(true).my_resolution_states.first.version
Flow.last.the_version(true).my_steps
Flow.last.the_version(true).my_steps.first.version
Flow.last.the_version(true).my_steps.first.my_triggers
Flow.last.the_version(true).my_steps.first.my_fields
Flow.last.the_version(true).my_steps.first.my_fields.first.version
Flow.last
Flow.last.the_version(true).my_steps.first
exit
Stepx
exit
Step.last
Step.last.versions
Step.last.versions.first
Step.last.versions.first.reify
Step.last.versions.first.reify.version
exit
x=step
x.version
exit
next
exit
error_type
exit
error_type
exit
next
nex
next
exit
next
error
next
self.errors
next
field.field_type
data_field
'aa'.squish!
' a  a '.squish!
field.field_type
[1,2] - [1]
[1] = [1,2]
[1] - [1,2]
(1..10).to_a
(1..10).to_a.to_s
(1..10).to_a.to_s.to_a
Array((1..10).to_a.to_s)
Array.new (1..10).to_a.to_s
Array.call '[]'
Kernel.call
Kernel.send '[]'
exit
Array(value)
Array(field.value)
Array(field.values)
exit
Array(field.values)
Array(value)
exit
Array(value)
exit
Array(value)
exit
fields_params
exit
type
next
field
value
next
value
nex
value
next
self.errors
exit
self.errors
exit
value
exit
value
field.values
field.values.keys
exit
errors
exit
errors
exit
case_step
case_step_params
Version.reify(12)
exit
step.version
step.version.id
exit
next
case_step_params
case_step_params[:step_version]
next
exit
next
exit
response.body
flow.reload
@field.step.flow.reload
exit
@field.step.reload.fields
@field.step.reload.fields.size
@field.step.reload.fields.unscope
@field.step.reload.fields.unscoped
exit
next
e
exit
response.body
exit
''.to_a
Array([])
Array('')
Array.new ''
Array.new 
{a:111} - {b:111}
{a:111}.to_a - {b:111}.to_a
Array({a:111})
exit
subject
LicensingSchedule.ast
LicensingSchedule.last
LicensingSchedule
planning2
whereami
planning2.update data_da_solicitacao_da_licenca: 1.week.since
subject
planning2
planning
exit
response.body
exit
next
body
exit
response.body
exit
response.body
exit
kase.case_steps
trigger_id
trigger.id
exit
flow.steps.first.triggers
build(:trigger_condition, field: field)
x=build(:trigger_condition, field: field)
x.valid?
whereami
flow.steps.first.triggers << build(:trigger, action_type: 'disable_steps', action_values: [other_flow.steps.first.id], trigger_conditions: [build(:trigger_condition, field: field)])
flow.steps.first.triggers.last.trigger_conditions
next
trigger
next
condition_versions
next
exit
next
[].index(0)
[].index(0)next
[].index(0).next
exit
t=Trigger.last
exit
trigger.update! user: user, trigger_conditions_versions: x
trigger
self.trigger.update! user: user, trigger_conditions_versions: x
self.trigger
condition_versions = self.trigger.trigger_conditions_versions.dup
x= condition_versions.merge!(id.to_s => nil)
self.trigger.update! user: user, trigger_conditions_versions: x
self.trigger
self.trigger.update! user: user, trigger_conditions_versions: {1=>2}
self.trigger
self.trigger.update! user: user, trigger_conditions_versions: {1=>2}.to_h
self.trigger
t=Trigger.last
t.trigger_conditions_versions = {1=>2}
t
t.save!
t.reload
s=Step.last
s.fields_versions = {1=>2}
s.save!
s
t=Trigger.last
t.trigger_conditions_versions = {1=>2}
t
t.save
t.reload
exit
Trigger.last
exit
parsed_body['case']
exit
flow.steps
next
step.my_triggers
step.triggers
exit
step.triggers
Trigger.all
exit
step.triggers
step
x=step
exit
flow.steps
exit
step.my_triggers
exit
response.body
flow.get_new_step_to_case
flow.steps.pluck(:id)
flow.steps.pluck(:id) + [1]
user.groups
user.groups.first.permissions
user.groups.first.group_permissions
user.groups.first.group_permission
user.groups.first.permission
flow.get_new_step_to_case
exit
next
flow
flow.steps
exit
response.body
exit
parsed_body
exit
response.body
exit
@list_all_steps
exit
response.body
flow.get_new_step_to_case
@list_all_steps
exit
response.body
exit
x=step
next
exit
user_groups
user_groups.first.permission
case_step
exit
skips
next
response.body
exit
flow.steps.first.fields
exit
response.body
exit
response.body
exit
other_flow
other_step
response.body
exit
kase.initial_flow.find_step_on_list(safe_params[:step_id])
next
fields
case_step
next
case_step_params
next
kase.initial_flow.find_step_on_list(safe_params[:step_id])
next
kase.initial_flow.find_step_on_list(safe_params[:step_id])
next
exit
response.body
exit
flow.steps
flow
create(:step_type_form_without_fields, flow: flow)
flow
exit
response.body
exit
parsed_body['case']['current_step']
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
kase.steps_not_fulfilled
exit
response.body
exit
response.body
exit
next
kase1.initial_flow
next
response.body
next
safe_params
next
exit
filter_params
safe_params
exit
*parameters
parameters
case_query.join(' and ')
Case.where(case_query.join(' and '), *parameters)
Case.where(case_query.join(' and '), *parameters).to_sql
exit
response.body
exit
subject
exit
next
planning.update vencimento_planejado: 1.day.ago
schedule.update data_de_inicio: 1.day.ago
venture.update data_inicial_da_etapa: 2.days.ago
schedule.update data_de_inicio: 1.day.ago
planning.update vencimento_planejado: 1.day.ago
schedule.update data_de_inicio: 1.day.ago
exit
∫]
venture.update!  data_inicial_da_etapa: 2.days.ago
planning.update! vencimento_planejado: 1.day.ago
exit
next
exit
response.body
step.reload
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
response.body
exit
parsed_body['case']['status']
exit
response.body
exit
response.body
exit
expect(parsed_body['case']).to be_an_entity_of(kase.reload, display_type: 'full')
exit
response.body
exit
response.body
exit
qidsuery
ids
next
steps
next
order_ids
steps
get_flow.update! steps_versions: order_ids
get_flow.reload
get_flow.update! steps_versions: {"2"=>nil,"3"=>nil,"1"=>nil}
get_flow.reload
get_flow.update! steps_versions: {}
get_flow.reload
get_flow.update! steps_versions: {"2"=>nil,"3"=>nil,"1"=>nil}
get_flow.reload
get_flow.update! steps_versions: {"2"=>nil,"3"=>nil,"1"=>nil}.to_h
get_flow.reload
get_flow.update! steps_versions: {}
get_flow.update! steps_versions: {"3"=>nil,"0"=>nil}
get_flow.reload
exit
[A
  params
params
exit
schedule.licensing_step.licensing_phase.before 
schedule.licensing_step.licensing_phase.before.license(@venture)
@venture.licenses
@venture.licenses.last.step_data
@venture.licenses.last.step_data.licensing_schedule
@venture.licenses.last.step_data.licensing_schedule.licensing_step
@venture.licensing_schedules.map(&:licensing_step)
exit
w\hereami
exit
Flow.last
Flow.last.steps
Flow.first
Flow.first.steps
x=Flow.first
x.update! steps_versions: {"2"=>nil,"1"=>nil,"3"=>nil}
x.reload
exit
Flow.destroy_all
Field.last
exit
order_ids
get_flow.update! steps_versions: order_ids
get_flow.reload
get_flow.update! steps_versions: {}
get_flow.reload
get_flow.update! steps_versions: order_ids
get_flow.reload
exit
get_flow
get_flow.steps_versions
exit
get_flow.update! steps_versions: order_ids
get_flow.reload
exit
instance.steps_versions
exit
instance.steps_versions
instance.steps_versions.reverse
instance.steps_versions.revert
instance.steps_versions.invert
instance.steps_versions.to_a.reverse.to_h
instance.steps_versions.to_a.reverse
instance.steps_versions.to_a.reverse.to_h
instance.steps_versions.to_a.reverse.to_hash
Hash[instance.steps_versions.to_a.reverse]
exit
exitstep
step
x=step
kase.initial_flow.list_all_steps
safe_params[:step_id]
exit
x=step
exit
Flow.find(3)
Flow.find(3).steps
Field.first
exit
Log
Log.all
Log.all.first
Log.all.count
Log.where("DATE('d', created_at) = '24'")
Log.where("to_char('d', created_at) = '24'")
Log.where("to_char('D', created_at) = '24'")
Log.where("to_char(created_at, 'D') = '24'")
Log.where("to_char(created_at, 'd') = '24'")
Log.where("to_char(created_at, 'DD') = '24'")
Log.where("to_char(created_at, 'YYYYMM') = '201502'")
Log.where("to_char(created_at, 'YYYYMM') = ?", '201502')
Date.today.strftime('%Y%d')
RegularityHistoryVenture
exit
UpdateRegularityHistoryVentureWorker
UpdateRegularityHistoryVentureWorker.perform
UpdateRegularityHistoryVentureWorker.new.perform
next
RegularityHistoryVenture
exit
UpdateRegularityHistoryVentureWorker.new.perform
next
UpdateRegularityHistoryVentureWorker.new.perform
next
exit
UpdateRegularityHistoryVentureWorker.new.perform
exit
UpdateRegularityHistoryVentureWorker.new.perform
next
exit
UpdateRegularityHistoryVentureWorker.new.perform
hisotyr
history
x=history
whereami
x=history
exit
UpdateRegularityHistoryVentureWorker.new.perform
x=history
today
venture.id
RegularityHistoryOfVenture
RegularityHistoryOfVenture.last
RegularityHistoryOfVenture.all
RegularityHistoryOfVenture.all.each{|x| x|;nil
RegularityHistoryOfVenture.all.each{|x| x};nil
RegularityHistoryOfVenture.all.each{|x| x}
RegularityHistoryOfVenture.delete_all
exit
UpdateRegularityHistoryVentureWorker.new.perform
exit
UpdateRegularityHistoryVentureWorker.new.perform
x=history
exit
Log.last
exit
UpdateRegularityHistoryVentureWorker.perform_async
Log.last
UpdateRegularityHistoryVentureWorker.perform_async
reload!
UpdateRegularityHistoryVentureWorker.perform_async
UpdateRegularityHistoryVentureWorker.perform_sync
UpdateRegularityHistoryVentureWorker.perform
UpdateRegularityHistoryVentureWorker.perform_sync
UpdateRegularityHistoryVentureWorker.perform_async
Log.last
reload!
UpdateRegularityHistoryVentureWorker.perform_async
reload!
UpdateRegularityHistoryVentureWorker.perform_async
reload!
UpdateRegularityHistoryVentureWorker.perform_async
reload!
UpdateRegularityHistoryVentureWorker.perform_async
reload!
UpdateRegularityHistoryVentureWorker.perform_async
Log.last
UpdateRegularityHistoryVentureWorker.perform_async
Log.where(user_name: nil)
Log.where(user_name: nil).delete_all
exit
Time.now
exit
Flow
Flow::Entity
$
$.inspect
exit
gon.positions
@venture
@venture.venture_geos.by_vnetures
@venture.venture_geos.by_ventures
exit
return
@geos_requirements
exit
geo
exit
params[:type]
@geos_requirements.first
@geos_requirements
exit
@venture
@venture.venture_geos
exit
VentureGeo.count
VentureGeo.by_venture.count
VentureGeo.by_ventures.count
VentureGeo.by_ventures
exit
{a:1, b:2}.to_param
{a:1, b:2}.to_query
exit
get_capabilities(layer)
x=get_capabilities(layer)
exit
x=get_capabilities(layer)
exit
Faraday
Faraday.new
uri = URI('http://199.168.98.170/cgi-bin/mapserv?LAYERS=CLIMAS_ZONAIS_900913&MAP=%2Fhome%2Fdeployer%2Fmaps%2Fclimas_zonais_900913.map&REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0')
res = Net::HTTP.get(uri)
res.body
xml = Nokogiri::XML(res)
res = Net::HTTP.get('http://199.168.98.170/cgi-bin/mapserv?LAYERS=CLIMAS_ZONAIS_900913&MAP=%2Fhome%2Fdeployer%2Fmaps%2Fclimas_zonais_900913.map&REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0')
xml = Nokogiri::XML.new(res)
xml
xml.to_hash
xml.to_hash['Capability']
exit
x=get_capabilities(layer)
exit
xml
xml.to_hash
xml.to_hash['WMT_MS_Capabilities']
xml.to_hash['WMT_MS_Capabilities']['Capability']
exit
capabilities
capabilities['BoundingBox']
capabilities['BoundingBox'].valyes
capabilities['BoundingBox'].values
capabilities['BoundingBox'].values.delete(0)
capabilities['BoundingBox'].values[1..-1]
capabilities['BoundingBox'].values[1..-1].map(&:to_f)
capabilities['BoundingBox'].values[1..-1].map(&:to_f).join(',')
capabilities['BoundingBox'].values[1..-1].map(&:to_f).join
exit
uri
exit
Net::HTTP.get(uri)
exit
res
rrr=Net::HTTP.get_response(uri)
rrr.content_type
exit
res_layer.body
res_layer.success
res_layer
res_layer.body
xml = Nokogiri::XML res_layer.body
xml.to_hash['BODY']
xml.to_hash
xml['HTML']
xml.to_hash['HTML']
xml.to_hash['HTML']['BODY']
xml = Nokogiri::HTML res_layer.body
xml.to_hash['HTML']
xml.to_hash
exit
uri
uri.url
uri.uri
uri.to_s
exit
body
res.body
Nokogiri::HTML res.body
xml=Nokogiri::HTML res.body
xml.to_hash
res.body
res.body.strip_tags
strip_tags res.body
sanitize res.body
exit
Loofah
res.body.gsub(/<!.*?$/, '')
strip_tags(res.body).gsub(/<!.*?$/, '')
exit
@geos
exit
@geos
exit
@geos
@geos_requirements
@geos.first
@geos.first.geo_data
@geos_requirements.first
@geos_requirements.first.geo_data
exit
@geos_requirements.first.geo_data
exit
@geos_requirements.first.geo_data
exit
@geos_requirements.first.geo_data
exit
@geos_requirements.first.geo_data
@geos.first.geo_data
exit
@geos.where.to_sql
@geos.to_sql
exit
@geos.first.geo_data
exit
@geos_requirements = VentureGeo.by_requirements(@venture.eventual_requirements.pluck(:id)).where(shape: true)
exit
labels
_
exit
labels
exit
labels
exit
param
param.first
dashboard_params
params
exit
label
exit
dashboard_params
label
exit
label
param
exit
label
param.last
exit
label
exit
label
exit
labels
exit
eixt
exit
key
exit
key
exit
key
value
value.flatten
value.compact
value.first
value.first.
end
exit
label
exit
label
exit
label
param
exit
[eventual_requirements_status, licencas_status, atividades_status]
[eventual_requirements_status, licencas_status, atividades_status].flatten
[eventual_requirements_status, licencas_status, atividades_status].map(&:count)
[eventual_requirements_status, licencas_status, atividades_status].map(&:first)
[eventual_requirements_status, licencas_status, atividades_status].map(&:first).map(&:total)
[eventual_requirements_status, licencas_status, atividades_status].map(&:first).compact.map(&:total)
exit
[eventual_requirements_status, licencas_status, atividades_status].map(&:first).compact.map(&:total)
[eventual_requirements_status, licencas_status, atividades_status]
[eventual_requirements_status, licencas_status, atividades_status].map(&:first).compact.map(&:total)
exit
[eventual_requirements_status, licencas_status, atividades_status]
[eventual_requirements_status, licencas_status, atividades_status].map(&:first).compact.map(&:total)
exit
[eventual_requirements_status, licencas_status, atividades_status]
[eventual_requirements_status, licencas_status, atividades_status].map(&:first).compact.map(&:total)
exit
[eventual_requirements_status, licencas_status, atividades_status]
Venture.first
Venture.first.states
Venture.first.cities
exit
[eventual_requirements_status, licencas_status, atividades_status]
exit
data = data.where(key => value).to_sql
exit
data = data.where(key => value).to_sql
data = data.where(key => value)
exit
data = data.where(key => value).to_sql
exit
[eventual_requirements_status, licencas_status, atividades_status]
whereami
licencas_status
ActualLicensesStatus
::ActualLicensesStatus
ActualLicenseStatus
ActualLicenseStatus.first
ActualLicenseStatus.where({}).to_sql
ActualLicenseStatus.first
reload!
exit
eventual_requirements_status
exit
@filtros
exit
@filtros
exit
@filtros
exit
@filtros
params
exit
dashboard_params
exit
ActualLicenseStatus.first
ActualLicenseStatus.first.cities
reload!
ActualLicenseStatus.first.cities
ActualLicenseStatus.first
ActualActivitiesStatus.last
ActualLicenseStatus
ActualLicenseStatus.last
exit
ActualActivitiesStatus.last
subject
subject.status
exit
Venture.count
DashboardEventualRequirement
DashboardEventualRequirement.all
exit
DashboardEventualRequirement.all
exit
labels
dashboard_params
exit
File.exists? Rails.root.join('app', 'images', 'codevasf-background.jpg')
exit
@temp_file
exit
Venture.firt
Venture.first.licensing_schedules.first
Venture.first.licensing_schedules.first.activities
Attachment.first
Attachment.first.file_naem
Attachment.first.file_name
Attachment.first.filename
Attachment.first.document.filename
Attachment.first.document.file_name
Attachment.first.document_file_name
Attachment.first.document.path
reload!
VentureFiles.new(Venture.first)
reload!
VentureFiles.new(Venture.first)
Venture.first.licensing_schedules.first
Venture.first.licensing_schedules.first.xxx
Venture.first.licensing_schedules.first.try(:xxx)
reload!
x=VentureFiles.new(Venture.first)
x.add_all_used_files
reload!
x=VentureFiles.new(Venture.first)
x.add_all_used_files
reload!
x=VentureFiles.new(Venture.first)
x.add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
license
license.environment_programs
license.environment_programs.map(*:activities)
license.environment_programs.map(&:activities)
license.environment_programs.map(&:activities).map(&:events)
license.environment_programs.map(&:activities).map(&:events).map(:attachments)
license.environment_programs.map(&:activities).map(&:events).map(&:attachments)
license.environment_programs.map(&:activities).map(&:events).map(&:attachments)exit
exit
license.environment_programs.map(&:activities).map(&:events).map(&:attachments)
license.environment_programs.map(&:activities)
license.environment_programs.map(&:activities).map(&:events)
license.environment_programs.map(&:activities).first
license.environment_programs.map(&:activities).first.events
license.environment_programs.map(&:activities).first
Event.where(activity_id: 1)
Acitivity.find(1).events
exit
Acitivity.find(1).events
Activity.find(1)
Activity.find(1).events
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
license.environment_programs.map(&:activities).first.events
exit
license.environment_programs.map(&:activities).first.events
license.environment_programs.map(&:activities).first
license.environment_programs.map(&:activities)
license.environment_programs.map(&:activities).flatten
exit
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
attachment
attachments
attachments.compact
attachments.keys
attachments.sizr
attachments.size
attachments.compact.size
attachments.flatten.size
exit
x=VentureFiles.new(Venture.first).add_all_used_files
exit
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
x.files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
file
file.class
file.is_a? VentureGeo
file.shape_file.path
exit
@files
file.clas
file.class
file.document.path
exit
@files
file.class
exit
xit
exit
exi
exit
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
x.files
['a' => 1]
['a' => 1].to_a
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
VentureGeo.first.shape_file
VentureGeo.first.shape_file_file_name
VentureGeo.last
VentureGeo.last.shape_file_file_name
exit
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
file
file.shape_file_file_name
file.shape
exit
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
x.files
x.generate!
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
x.generate!
file
exit
file
exit
file
file[:folder]
exit
reload!
x=VentureFiles.new(Venture.first).add_all_used_files
x.generate!
exit
VentureGeo.to_csv
VentureGeo.all.to_csv
VentureGeo.all.to_h.to_csv
VentureGeo.all.to_h
VentureGeo.all
VentureGeo.where(shape:false)
VentureGeo.where(shape:false).to_h
Hash.newVentureGeo.where(shape:false)
Hash.new VentureGeo.where(shape:false)
Hash[VentureGeo.where(shape:false)]
VentureGeo.where(shape:false)
VentureGeo.where(shape:false).to_csv
VentureGeo.where(shape:false).map(&:attributes)
VentureGeo.where(shape:false).map(&:attributes).to_h
VentureGeo.where(shape:false).map(&:attributes).to_csv
VentureGeo.where(shape:false).map(&:attributes)
VentureGeo.where(shape:false).map(&:attributes).class
VentureGeo.where(shape:false).map(&:attributes).class.first
VentureGeo.where(shape:false).map(&:attributes).first
VentureGeo.where(shape:false).map(&:attributes).first.to_csv
VentureGeo.where(shape:false).first.attributes.to_csv
VentureGeo.where(shape:false).first.attributes
VentureGeo.where(shape:false).first.attributes.class
VentureGeo.where(shape:false).first.attribute
exit
x=0
puts x++
nd
puts x+1
x
x+=1
x
puts x+=1
x
exit
ventures
filter_venture_data(Venture.availables)
exit
ventures
whereami
exit
]
filter_data(ActualActivitiesStatus.by_status)
exit
filter_data(ActualActivitiesStatus.by_status)
filter_data(ActualActivitiesStatus.all)
ActualActivitiesStatus.all
params
ActualActivitiesStatus.all
ActualActivitiesStatus.all.where(:whatershed_id: [1,2,3,4])
ActualActivitiesStatus.all.where(whatershed_id: [1,2,3,4])
ActualActivitiesStatus.all.where('whatershed.id' => [1,2,3,4])
ActualActivitiesStatus.where('whatershed.id' => [1,2,3,4])
ActualActivitiesStatus.where('wathershed.id' => [1,2,3,4])
ActualActivitiesStatus.where('watershed.id' => [1,2,3,4])
ActualActivitiesStatus.where('watersheds.id' => [1,2,3,4])
ActualActivitiesStatus.all.select('watersheds.id')
ActualActivitiesStatus.all.select('watersheds.id as xxx').map(&:xxx)
ActualActivitiesStatus.all.first
ActualActivitiesStatus.all.first.watersheds
ActualActivitiesStatus.all.map(&:watersheds)
exit
atividades_status
ActualActivitiesStatus.all.map(&:watersheds)
exit
ActualActivitiesStatus
ActualActivitiesStatus.first
ActualActivitiesStatus.first.watersheds
Venture.find(1).watersheds
reload!
ActualActivitiesStatus.first.watersheds
ActualActivitiesStatus.count
ActualActivitiesStatus.pluck(:id)
exit
options[:only].try(:[], :case_steps))
options[:only].try(:[], :case_steps)
options[:only]
exit
options
exit
options
exit
exitoptions
options
options[:only]
options[:only][:current_step]
Hash[options[:only]]
options[:only].to_h
options[:only]
exit
change_options_to_return_fields(:current_step, options)
exit
eventual_requirements_status 
atividades_status
exit
atividades_status
exit
atividades_status
exit
ActualActivitiesStatus
ActualActivitiesStatus.first
ActualActivitiesStatus.count
reload!
ActualActivitiesStatus.count
Activities.count
Activity.count
reload!
Activity.count
ActualActivitiesStatus.count
ActualActivitiesStatus.first
ActualActivitiesStatus.first.cities
ActualActivitiesStatus.first.watersheds
ActualActivitiesStatus.all.map(&:watersheds)
ActualActivitiesStatus.all.map(&:cities)
ActualActivitiesStatus.first.cities.to_sql
ActualActivitiesStatus.first
reload!
ActualActivitiesStatus.first
reload!
ActualActivitiesStatus.first
reload!
ActualActivitiesStatus.first
ActualActivitiesStatus.first.cities.to_sql
reload!
ActualActivitiesStatus.first.cities.to_sql
reload!
ActualActivitiesStatus.first.cities.to_sql
exit
DashboardEventualRequirement.by_status
exit
licencas_status
licencas_status.group
licencas_status.group(:status)
licencas_status.map(&:id)
licencas_status.group_by(:status)
licencas_status.group_by{|l| l.status}
licencas_status.group_by(&:status)
licencas_status.group_by(&:status, &:regularidade)
licencas_status.group_by(&:status)
licencas_status.group_by(&:status).keys
licencas_status.group_by(&:status)
licencas_status.group_by(&:status).map{|l| l}
licencas_status.group_by(&:status).map{|k,d| {k => d.size}}
licencas_status.group_by(&:status).map{|k,d| {k => d.size}}.first
licencas_status.group_by(&:status).map{|k,d| {k => d.size}}.first.key
licencas_status.group_by(&:status).map{|k,d| {k => d.size}}.first.keys
licencas_status.group_by(&:status)
licencas_status.first
licencas_status.group_by(&:status)
licencas_status.group_by(&:status).first
licencas_status.group_by(&:status).first.first
licencas_status.group_by(&:status).each {|v| puts v};nil
licencas_status.group_by(&:status).each {|k,v| puts v};nil
licencas_status.group_by(&:status).each {|k,v| puts k};nil
exit
licencas_status
whereami
filter_data(ActualLicenseStatus.all).uniq
filter_data(ActualLicenseStatus.all).uniq.first
filter_data(ActualLicenseStatus.all).uniq.first.regularidade
exit
datum
datum.last
datum.last.first
datum.last.first.try(:regularidade)
exit
datum.last.first.try(:regularidade)
exit
datum.last.first.try(:regularidade)
exit
licencas_status
atividades_status
eventual_requirements_status
exit
ventures
ventures.to_sql
exit
venture_ids
exit
DashboardEventualRequirement
DashboardEventualRequirement.first
DashboardEventualRequirement.first.venture
reload!
DashboardEventualRequirement.first.venture
reload!
ActualActivitiesStatus.first
ActualActivitiesStatus.first.venture
ActualLicenseStatus.first
ActualLicenseStatus.first.venture
reload!
Venture.availables.to_sql
reload!
Venture.availables.to_sql
reload!
Venture.availables
Venture.availables.count
Venture.availables.uniq
Venture.availables.uniq.size
Venture.availables.pluck(:id)
reload!
Venture.availables.pluck(:id)
reload!
Venture.availables.pluck(:id)
reload!
Venture.availables.pluck(:id)
reload!
Venture.availables.pluck(:id)
exit
Venture.to_dashboard
Venture.unclosed.count
Venture.to_dashboard - Venture.unclosed
Venture.unclosed - Venture.to_dashboard
x=Venture.unclosed - Venture.to_dashboard
x.map(&:licensing_schedules)
reload!
Venture.to_dashboard.to_sql
Venture.to_dashboard
reload!
Venture.to_dashboard.count
Venture.to_dashboard.size
exit
1.class
0 != nil ? 1 : 2
exit
VentureTableItem.actives.to_sql
exit
RegularityHistoryOfVenture.alll
RegularityHistoryOfVenture.all
RegularityHistoryOfVenture.group(:regularidade).select('updated_at, count(id)')
RegularityHistoryOfVenture.group(:regularidade).select('to_char(updated_at,\'DD\'), count(id)')
reload!
RegularityHistoryOfVenture.by_status
reload!
RegularityHistoryOfVenture.by_status
reload!
RegularityHistoryOfVenture.by_status
reload!
RegularityHistoryOfVenture.by_status
RegularityHistoryOfVenture.by_status.map{|h| h.regularidade}
RegularityHistoryOfVenture.by_status.map{|h| h.data}
RegularityHistoryOfVenture.by_status.map{|h| h.total}
reload!
RegularityHistoryOfVenture.by_status.group_by(&:data)
exit
ActualActivitieStatus.all
ActualActivitiesStatus.all
ActualActivitiesStatus.where(venture_id: 28)
ActualActivitiesStatus.where(venture_id: 28).count
ActualActivitiesStatus.by_status(28)
ActualActivitiesStatus.by_status(28).map(&:total)
ActualActivitiesStatus.by_status(28).map{|a| {a.total, a.status, a.regularidade}
ActualActivitiesStatus.by_status(28).map{|a| {a.total, a.status, a.regularidade}}
ActualActivitiesStatus.by_status(28).map{|a| [a.total, a.status, a.regularidade]}
exit
EventualRequirement.to_expire.count
EventualRequirement.to_expire
EventualRequirement.to_expire.map(&:days_to_expire)
AlertParameter.first
EventualRequirement.to_expire.all.second
EventualRequirement.to_expire.all.second.days_to_expire
EventualRequirement.to_expire.all.second.licensing_schedule
v=EventualRequirement.to_expire.all.second.licensing_schedule.venture
v.venture_type
v.licensing_schedules
v.completed?
exit
UpdateRegularityHistoryVentureWorker
UpdateRegularityHistoryVentureWorker.perform
UpdateRegularityHistoryVentureWorker.
end
UpdateRegularityHistoryVentureWorker.perform_async
reload!
RegularityHistoryOfVenture
RegularityHistoryOfVenture.by_statys
RegularityHistoryOfVenture.by_status
RegularityHistoryOfVenture.by_status.first
reload!
RegularityHistoryOfVenture.by_status.first
reload!
RegularityHistoryOfVenture.by_status.first
RegularityHistoryOfVenture.by_status.first.regular
RegularityHistoryOfVenture.by_status.first.to_h
RegularityHistoryOfVenture.by_status.first.to_json
reload!
RegularityHistoryOfVenture.by_status.first.to_json
JSON.parse _
JSON.parse RegularityHistoryOfVenture.by_status.group_by(&:data).to_json
reload!
JSON.parse RegularityHistoryOfVenture.by_status.to_json
reload!
JSON.parse RegularityHistoryOfVenture.by_status.to_json
reload!
JSON.parse RegularityHistoryOfVenture.by_status.to_json
'2015-02-28'.to_date
reload!
UpdateRegularityHistoryVentureWorker.perform_async
exit
RegularityHistoryOfVenture.by_status.first.to_json
RegularityHistoryOfVenture.by_status.to_json
JSON.parse RegularityHistoryOfVenture.by_status.to_json
exit
current_user.regional_superintendency.ventures.count
current_user.regional_superintendency.ventures.actives.count
current_user.regional_superintendency.ventures.actives.size
current_user.regional_superintendency.ventures.actives.to_a.size
exit
@result
@result.keys
@result.keys.group_by{|k| k}
@result.keys.first.split
@result.keys.first.split.first(2)
@result.keys.first.split.first(2).join
@result.keys.first.split.first(2).join(' ')
@result.keys.group_by{|k| k.split.first(2).join(' ') }
exit
@result
@result.keys
exit
User.first
User.first.update regional_superintendency_id: RegionalSuperintendency.first.id
exit
before_phase
before_phase.license(@schedule.venture)
exit
Venture.find(14).licensing_schedules.map(&:step_data).flatten.map(&:licenses)
Venture.find(14).licensing_schedules.map(&:step_data).flatten
x=Venture.find(14).licensing_schedules.map(&:step_data).flatten.compact
License.find(14)
License.find(14).step_data.licensing_schedule.licensing_step
License.find(17).step_data.licensing_schedule.licensing_step
exit
Cache.all
Rails::Cache
Rails.cache
Rails.cache.read('x')
current_user
current_user.groups
session
AES
aes
cache
cache.read('x')
current_user.groups
groups=current_user.groups.pluck(:id)
Rails.cache.write('g1', Permission.where(group_id: groupsfirst))
Rails.cache.write('g1', Permission.where(group_id: groups.first))
Rails.cache.read('g1')
Rails.cache.write('g1', Permission.where(group_id: groups.first.to_h))
Rails.cache.write('g1', Permission.where(group_id: groups.first.to_hash))
Permission.where(group_id: groups.first).to_h
Permission.where(group_id: groups.first)
Permission.where(group_id: groups.first).to_a
Permission.where(group_id: groups.first).to_a.to_h
Permission.where(group_id: groups.first).first
Permission.where(group_id: groups.first).first.to_h
Permission.where(group_id: groups.first).first.attributes
Permission.where(group_id: groups.first).map(&:attributes)
p=Permission.where(group_id: groups.first).map(&:attributes)
Rails.cache.write('g1', p)
Rails.cache.read('g1')
x=Rails.cache.read('g1')
x.first
x.first[:id]
x.first['id']
exit
session
Application
Codevasf
Codevasf::Application
Codevasf::Application.config
Codevasf::Application.config.session_store
Codevasf::Application.config.session_store.session
exit
session
@session
@session[:groups]
exit
@theme
@result.each {|k,v| k};nil
@result.each {|k,v| puts k};nil
@theme
exit
@thema
@theme
exit
@theme
exit
EventualRequirementThematic.where.not(status: nil).group_by(&:status)
exit
UpdateRegularityHistoryVentureWorker.perfom_async
UpdateRegularityHistoryVentureWorker
UpdateRegularityHistoryVentureWorker.perform_async
UpdateRegularityHistoryVentureWorker.perform_in 10.second.from_now
UpdateRegularityHistoryVentureWorker.perform_async
UpdateEffortVentureWorker.perform_async
UpdateEffortVentureWorker.
UpdateEffortVentureWorker.next_scheduled_occurrence
exit
UpdateEffortVentureWorker.perform_async
exit
filter_by(GeoventureThematic, ventures_filter)
exit
@theme
exit
alert
alert.vencimento_de_licenca
alert.vencimento_de_licenca_alerta_vermelho
@result.license_current
@result.license_expired
@result.without_license
@result.license_to_expire_red(alert.vencimento_de_licenca_alerta_vermelho)
exit
@result.license_to_expire_red(alert.vencimento_de_licenca_alerta_vermelho)
exit
I18n
I18n.default_locale
I18n.t('activerecord')
exit!
exit
page
page.body
puts page.body
exit!
I18n.t('devise')
I18n.t('pt_br')
I18n.t('simple_form')
exit
puts page.body
eixt
exit
exit!
I18n.t('simple_form')
I18n.t('devise')
exit
@eventual_requirement
eventual_requirement_params
exit
eventual_requirement_params
@eventual_requirement
exit
Venture.find_by_sql 'SELECT NOW()'
Venture.find_by_sql('SELECT NOW() as x').x
Venture.find_by_sql('SELECT NOW() as x').first.x
exit
puts page.body
fill_in 'user[email]', with: 'xxxx'
next
find('user[password]')
find("name=['user[password]']")
find("name='user[password'")
find("name='user[password]'")
click_button 'Entrar'
page.current_url
puts page.body
exit!
params
action_name
exit
GNTP
GNTP.notify({
    :app_name => "Instant notify",
    :title    => "Instant notification",
    :text     => "Instant notification available now.",
    :icon     => "http://www.hatena.ne.jp/users/sn/snaka72/profile.gif",
})
GNTP.notify({app_name: "Instant notify", title: "Instant notification", text: "Instant notification available now.", icon: "http://www.hatena.ne.jp/users/sn/snaka72/profile.gif"})
growl = GNTP.new("Ruby/GNTP self test")
growl.register({:notifications => [{
        :name     => "notify",
        :enabled  => true,
}]})
growl.register({:notifications => [{
        :name     => "notify",
        :enabled  => true,
}]})
growl.notify({
    :name  => "notify",
    :title => "Congratulation",
    :text  => "Congratulation! You have successfully installed ruby_gntp.",
    :icon  => "http://www.hatena.ne.jp/users/sn/snaka72/profile.gif",
    :sticky=> true,
})
growl.notify({
    :name  => "notify",
    :title => "Congratulation",
    :text  => "Congratulation! You have successfully installed ruby_gntp.",
    :icon  => "http://www.hatena.ne.jp/users/sn/snaka72/profile.gif",
    :sticky=> true,
})
exit
growl = GNTP.new("Ruby/GNTP self test")
growl.register({:notifications => [{
        :name     => "notify",
        :enabled  => true,
}]})
growl.notify({
    :name  => "notify",
    :title => "Congratulation",
    :text  => "Congratulation! You have successfully installed ruby_gntp.",
    :icon  => "http://www.hatena.ne.jp/users/sn/snaka72/profile.gif",
    :sticky=> true,
})
GNTP.notify({
    :app_name => "Instant notify",
    :title    => "Instant notification",
    :text     => "Instant notification available now.",
    :icon     => "http://www.hatena.ne.jp/users/sn/snaka72/profile.gif",
})
exit
cancelado
replanejamento
exit
replanejamento
@event
@event.replanejamento
exit
Venture.last
exit
parameters.select { |key, value| value.present? }
exit
puts page.body
find('user[name]')
find('#user_name')
find('#user_name').val
find('#user_name').value
exit
puts page.body
whereami
click_button 'Atualizar Usuário'
page.url
page.current_url
puts page.body
exit
puts page.body
exit
puts page.body
exit
next
@user
current_user
authorize @user
exit
exit!
next
authorize @user
exit
exit!
exit
authorize @user
next
exit
puts page.body
flash
exit
next
flash
next
flash
exit!
exit
exit!
authorize @user
exit
authorize User
authorize @users
authorize
authorize :index?
authorize @users
exit!
exit
exit!
exit
puts page.body
exit
exit!
puts page.body
exit
puts page.body
exit!
puts page.body
exit
puts page.body
exit!
GeoventureThematic.irregular
exit
GeoventureThematic.irregular
UpdateRegularityHistoryVentureWorker.send('regular_com_atencao?', 6)
UpdateRegularityHistoryVentureWorker.new.send('regular_com_atencao?', 6)
UpdateRegularityHistoryVentureWorker.new.send('irregular?', 6)
UpdateRegularityHistoryVentureWorker.new.send('irregular?', 13)
UpdateRegularityHistoryVentureWorker.new.send('regular_com_atencao?', 13)
UpdateRegularityHistoryVentureWorker.new.send('regular_com_atencao?', 28)
UpdateRegularityHistoryVentureWorker.new.send('irregular?', 28)
UpdateRegularityHistoryVentureWorker.new.send('irregular?', 19)
UpdateRegularityHistoryVentureWorker.new.send('irregular?', 23)
UpdateRegularityHistoryVentureWorker.new.send('irregular?', 6)
UpdateRegularityHistoryVentureWorker.new.send('regular_com_atencao?', 6)
exit
@result.count
@result.regular.count
@result.iregular.count
@result.irregular.count
@result.regular_com_atencao.count
exit
@result.regular.count
@result.regular_com_atencao.count
ActiveRecord::Base.logger = nil
@result.regular_com_atencao.count
@result.regular.count
@result.irregular.count
@result.regular.count
@result.regular_com_atencao.count
exit
GeoventureThematic.irregular
GeoventureThematic.irregular.count
GeoventureThematic.regular.count
GeoventureThematic.regular_com_atencao.count
GeoventureThematic.where(tipo_id: 6)
exit
@result.regular.count
@result.regular_com_atencao.count
@result.irregular.count
next
regults
results
results.first.first
results.first.first.size
results[1].first.size
results[2].first.size
exit
result.first.size
index
geo_json_data_0
exit
RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection(result.first)).to_json
JSON.parse(RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection(result.first)).to_json)
JSON.parse(RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection(result.first)).to_json)['features']
JSON.parse(RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection(result.first)).to_json)['features'].size
result.first.size
GeoventureThematic.to_feature_collection(result.first)
GeoventureThematic.to_feature_collection(result.first).to_json
JSON.parse(GeoventureThematic.to_feature_collection(result.first).to_json)
exit
puts page.body
exit!
puts page.body
exit
puts page
puts page.body
puts subject
exit!
find('table .btn-danger').click_link
find('table .btn-danger').click
puts page.body
exit!
step_data_params
@step_data.update(step_data_params)
exit
@step_data.update(step_data_params)
@step_data.errors
exit
dado_etapa
dado_etapa.numero_do_processo
dado_etapa
dado_etapa.licensing_schedule
exit
errors
errors[:cnpj]
errors.cnpj
exit
'0'.zero?
'0'.to_i.zero?
exit
Event.all
Event.where('fim_planejado >= ?', Date.today)
Activity.new.send('month_difference', Date.today - 1.month, Date.today)
reload!
Activity.new.send('month_difference', Date.today - 1.month, Date.today)
Activity.new.send('month_difference', Date.today - 1.month - 10.days, Date.today)
Activity.new.send('month_difference', (Date.today - 1.month) - 10.days, Date.today)
Activity.new.send('month_difference', (Date.today - 2.month) - 10.days, Date.today)
Activity.new.send('month_difference', (Date.today - 2.month) - 20.days, Date.today)
Activity.new.send('month_difference', (Date.today - 2.month) - 40.days, Date.today)
Date.today - 2.months - Date.today
(Date.today - 2.months) - Date.today
((Date.today - 2.months) - Date.today).to_days
((Date.today - 2.months) - Date.today).to_i
(Date.today - (Date.today - 2.months)).to_i
(Date.today - (Date.today - 2.months)).to_i / 7
89/7
88/7
87/7
exit
1.times {|n| n};nil
1.times {|n| puts n};nil
exit
origin
next
data_inicial
origin.inicio_planejadpo
origin.inicio_planejado
data_fim
origin.vencimento_planejado
next
erros
errors
data_fim
data_inicio
exit
data_final
data_fim
exit
data_final
data_fim
exit
puts page.body
exit
number
number.to_i
number_to_human_size(number.to_i)
number_to_human_size(6620)
number_to_human_size(6690)
number_to_human_size(6690, precision: 2)
number_to_human_size(6690, precision: 3)
exit
ActiveRecord::Base.connection.execute("SELECT pg_size_pretty(pg_database_size('postgres'))")
ActiveRecord::Base.connection.execute("SELECT pg_size_pretty(pg_database_size('postgres'))").first
number = number * 8
exit
helpers.responsible_for_program_or_activity_list
helper.responsible_for_program_or_activity_list
def x
  return 1,2
end
x
a,b=x
a
b
def x
  1,2
def x
  [1,2]
end
a,b=x
a
b
def x
  [1,2,3,4]
  ed
end
def x; [1,2,3,4]; end
a,b=x
a
b
exit
pluralize
exit
group
exit
group
ns
exit
group
group.last
group.last.first
group.last.first.venture_geo
exit
group
exit
group
'aaa,xxxx'.split
exit
group
exit
geom_attr_name
read_attribute(:geo_data)
read_attribute(:xxx)
read_attribute(:name)
property_names
hash
properties
class
end
self
self.lat
calller
send(property_names.first)
exit
respond_to? :xxx
respond_to? :lat
exit
hash
properties
property_names
send :apelido
self.send(:apelido)
self.send('apelido')
self.apelido
exit
accessible.where(finalizada_em: nil).blank? 
accessible.where(finalizada_em: nil)
exit
Venture.find(2).licensing_schedules
Venture.find(2).licensing_schedules.last(2).first
Venture.find(2).licensing_schedules.last(2).first.update finalizada_em: nil
exit
CreateAdminService.new
CreateAdminService.new.call
next
exit
Rails.root.join('app', 'assets', 'javascript', controller_name)
File.exists?(Rails.root.join('app', 'assets', 'javascript', controller_name))
File.exists?(Rails.root.join('app', 'assets', 'javascripts', controller_name))
File.exists?(Rails.root.join('app', 'assets', 'javascripts', "#{controller_name}.js.coffee"))
File.exists?(Rails.root.join('app', 'assets', 'javascripts', "#{controller_name}.coffee"))
exit
Configuration
Configuration.xxx
Configurarion
Configurarion.xxx
Configurarion.payroll_data_start_from_years_ago
exit
exit!
Configuration.payroll_data_start_from_years_ago
::Configuration.payroll_data_start_from_years_ago
exit
report_ventures_with_compensation_params
parmas
params
exit
params
exit
payroll_datum_params
next
exception
exit
payroll_datum_params
exit
names
names.order_by(&:size)
names.sort_by(&:size)
names.sort_by(&:size).reverse
exit
names
exit
PayrollDatum.last
build(:payroll_datum)
exit!
PayrollDatum.last
build(:payroll_datum)
exit
build(:payroll_account_value, value: 1_000_000_000)
build(:payroll_account_value, value: 1_000_000_000).value
build(:payroll_account_value, value: 1_000_000_000).value.to_f
build(:payroll_account_value, value: 1_000_000_000).valid?
build(:payroll_account_value, value: 1_000_000_000_000).valid?
x=build(:payroll_account_value, value: 1_000_000_000_000)
x.valid?
x.errors
exit!
param
exit
param
exit
param
exit
param
exit
param
exit
param
param.last
param.last.pop
param.last[0]
param.last[0].delete
param.last
param.last.pop(0)
param.last
exit
@filtros
exit
@filtros
exit
payroll_account_value_params
@payroll_account_value
exit
@company.payroll_data
whereami
@company.payroll_data.where(payroll_account: @payroll_accoutn)
@payroll_account.payroll_account_values.where(payroll_datum: @company.payroll_data)
@payroll_account.payroll_account_values.where(payroll_datum: @company.payroll_data).count
@payroll_account.payroll_account_values.where(payroll_datum: @company.payroll_data).update(incide_no_inss: true)
@payroll_account.payroll_account_values.where(payroll_datum: @company.payroll_data).update(:incide_no_inss, true)
@payroll_account.payroll_account_values.where(payroll_datum: @company.payroll_data).update_all(incide_no_inss: true)
exit
referencua
referencia
self.referencia
exit
referencia
exit
selic_rate
SelicRate.last(months_ago)
total
exit
company.payroll_data.to_potential
exit!
next
aliquotas
aliquotas.to_f
payroll.aliquota_sat * payroll.aliquota_fap 
payroll.aliquota_empresa + payroll.aliquota_terceiros
payroll.aliquota_sat * payroll.aliquota_fap + (payroll.aliquota_empresa + payroll.aliquota_terceiros)
(payroll.aliquota_sat * payroll.aliquota_fap + (payroll.aliquota_empresa + payroll.aliquota_terceiros)).to_f
payroll
payroll.aliquota_sat
payroll.aliquota_sat.to_f
exit!
next
aliquotas
aliquotas.to_f
next
total_verba
total_verba.to_f
total_verba * SelicRate.until_today(payroll.referencia).present_value_component.reduce(1.0, :*)
_.to_f
exit
exit!
aliquotas
aliquotas.to_f
payroll_account.payroll_account_values.find_by(payroll_datum: payroll).value
payroll_account.payroll_account_values.find_by(payroll_datum: payroll).value.to_f
total
total_verba
total_verba.to_f
SelicRate.until_today(payroll.referencia).present_value_component.reduce(1.0, :*)
exit
total_verba.to_f
aliquotas
payroll_account.payroll_account_values.find_by(payroll_datum: payroll).value
payroll_account.payroll_account_values.find_by(payroll_datum: payroll).value.to_f
payroll.referencia
payroll_data.to_potential
SelicRate.all
PayrollDatum.all
exit!
PayrollDatum.all
exit
exit!
PayrollDatum.all
exit
total_verba
exit
total_verba
exit
exit!
build(:payroll_datum).valid?
exit
License.last
License.last.status
License.last.regularidade
exit
company
next
user
exit
column_names
column_names + 'status_regularidade_empreendimento'
column_names + ['status_regularidade_empreendimento']
exit
[1, 2, 3].delete(3)
[1, 2, 3]
exit
VenturesDatatable.new(view_context, params[:format]).as_table
exit
,l@ventures_table_itens
@ventures_table_itens
_.first
params
next
exit
next
@deposit
exit
continue
\
help
c
@payroll_data
@payroll_data.file
exit
file.original_filename
File.extname(file.original_filename) 
file.path
Roo::Spreadsheet.open(file.path)
x=Roo::Spreadsheet.open(file.path)
x.info
exit
activity.status_regularidade
exit
@result.license_to_expire_warning(alert.vencimento_de_licenca, alert.vencimento_de_licenca_alerta_vermelho)
RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection(@result.license_to_expire_warning(alert.vencimento_de_licenca, alert.vencimento_de_licenca_alerta_vermelho))
)
RGeo::GeoJSON.encode(GeoventureThematic.to_feature_collection(@result.license_to_expire_warning(alert.vencimento_de_licenca, alert.vencimento_de_licenca_alerta_vermelho))).to_json
exit
index
result.last
exit
result.last
exit
result.last
exit
@payroll_data.import?
exit
row
whereami
index
exit
row
spreadsheet.last_row
spreadsheet.cell
spreadsheet.cell(0)
spreadsheet.cell
exit
exit!
row
spreadsheet
spreadsheet.cell(0
)
spreadsheet.last_column
spreadsheet.column(0)
spreadsheet.column(1)
spreadsheet.cell(1, 2)
spreadsheet.cell(1, 1)
spreadsheet.cell(1, 2)
spreadsheet.cell(1, 3)
spreadsheet.cell(1, 3).match /^(\d{2})\/(\d{4})$/ ? Date.new($2, $1, 1) : nil
spreadsheet.cell(1, 3).match(/^(\d{2})\/(\d{4})$/) ? Date.new($2, $1, 1) : nil
$12
$1
$2
spreadsheet.cell(1, 3).match(/^(\d{2})\/(\d{4})$/) ? Date.new($2.to_i, $1.to_i, 1) : nil
'1.23%'
'1.23%'.to_f
'r$ 1.23'.to_f
'1,23%'.gsub(',', '.')
'1,23%'.gsub(',', '.').gsub(/[^0-9\.]+/, '')
exit
exit!
@payroll_data.import_data
exit
@import_data
@import_data.push 1
spreadsheet.last_column
exit
payroll_account
exit
payroll_account
exit
payroll_account
exit
payroll_account
exit
payroll_account
exit
payroll_account
exit
payroll_account
exit
payroll_account
exit
payroll_account
row
spreadsheet.last_row
exit
@import_data
whereami
next
exit
@payroll_data.import_data
@payroll_data.import_data.select { |c| c.errors.present? }
@payroll_data.import_data.select { |c| c.payroll_account_values.errors.present? }
@payroll_data.import_data.select { |c| c.payroll_account_values.map(&:errors).compact.present? }
@payroll_data.import_data.select { |c| c.payroll_account_values.map(&:errors).compact.present? }.first
@payroll_data.import_data.select { |c| c.payroll_account_values.map(&:errors).compact.present? }.first.payroll_account_values
@payroll_data.import_data.select { |c| c.payroll_account_values.map(&:errors).compact.present? }.first.payroll_account_values.first
@payroll_data.import_data.select { |c| c.payroll_account_values.map(&:errors).compact.present? }.first.payroll_account_values.first.errors
@payroll_data.import_data.select { |c| c.payroll_account_values.map(&:errors).compact.present? }.first.payroll_account_values.map(&:errors)
@payroll_data.import_data.select { |c| c.payroll_account_values.map(&:errors).flatten.compact.present? }.first.payroll_account_values.map(&:errors)
@payroll_data.import_data.first
exit
column
spreadsheet.cell(1, column)
@import_data
exit
@payroll_data.import_data
exit
@import_data.map { |payroll| payroll.save! && payroll.payroll_account_values.map(&:save!) }
@import_data.last.payroll_account_values
exit
payroll_value.value
payroll_value.value.to_f
payroll_value.valid?
payroll_value.save!
exit
payroll_value.value.to_f
exit
spreadsheet.cell(2, column)
spreadsheet.cell(3, column)
spreadsheet.cell(4, column)
exit
spreadsheet.cell(2, column)
get_decimal(spreadsheet.cell(2, column))
spreadsheet.cell(2, column).class
exit
qtheme
theme
exit
qexit
exit
@result.count
@result.where(status_da_licenca: 'Sem Licença')
whereami
@result.where(status_da_licenca: 'Próxima Licença Solicitada Fora do Prazo')
exit
@deposit
next
step
captured?
whereami
account.transactions.find_by_origin_id(id)
id
account.transactions
exit
response
exit
next
step
next
response
exit
next
step
next
response
exit
next
register
exit!
next
step
next
response
exit!
next
step
next
response
exit
next
step
next
response
exit!
Bank::Gateway::Cielo.new(id: @deposit.token,description: 'Adicao de creditos no FOCO|Bank', value: @deposit.virtus / Bank::Config.first.virtus.to_f, flag: @deposit.payment_type, return_to: bank_deposit_url(@deposit))
xxx=_
xxx
exit!
resp=Bank::Gateway::Cielo.new(id: @deposit.token,description: 'Adicao de creditos no FOCO|Bank', value: @deposit.virtus / Bank::Config.first.virtus.to_f, flag: @deposit.payment_type, return_to: bank_deposit_url(@deposit))
next
response
exit!
next
response
exit
next
step
next
response
exit
next
response
exit!
next
response
exit
next
response
exit!
puts page.body
exit!
find('.ready-to-calc')
find('.ready-to-calc').text()
exit
find('.release-calc')
puts page.text
exit!
page.text
find('.ready-to-calc')
next
exit
exit!
page.text
exit!
find('.ready-to-calc')
find('.ready-to-calc').class
find('.ready-to-calc').css
find('.ready-to-calc')
find('.ready-to-calc').elem
find('.ready-to-calc').classify
find('.ready-to-calc').class_name
find('.ready-to-calc').class_attribute
exit
exit!
payroll_datum
payroll_datum.company
payroll_datum.company.status
payroll_datum.company.update! status: :open
payroll_datum.company
payroll_datum.company.status
exit
@import_data.select{|p|p.errors.present?}
next
exception
exit
next
response
exit!
next
@uri
next
attributes
exit
response
exit
next
step
next
@uri
@uri.request_uri
next
attributes
exit!
next
response
exit
next
step
next
response
exit!
exit
params_to_xml
exit!
exit
response
exit
exit!
exit
response
exit
next
exit
response
exit
ENV['FAKE_DATA']
next
exit
get_decimal(spreadsheet.cell(6, column))
get_decimal(spreadsheet.cell(7, column))
spreadsheet.last_row 
exit
EXIT
exit
response
exit
response
exit
next
exception
exit!
@uri.host
@uri.post
@uri.port
@uri.request_uri
next
exception
exit!
@options
exit!
exit
next
exit!
@options
exit
params_to_xml
exit
response
exit!
exit
response
exit!
exit
response
exit!
exit
response
exit
response
exit
params_to_xml
exit!
exit
response
params_to_xml
attributes
exit
response
exit
next
exit
next
exit
next
exit
register
next
@deposit.errors
exit!
exit
response
exit
next
step
next
attributes
exit
exit!
next
cielo
cielo.client_number
Rails.env
YAML.load_file(Rails.root.join('config', 'general.yml'))
exit!
controller_name
controller_name.camelize
controller_name.camelize.constantize
controller_name.singularize
controller_name.singularize.constantize
controller_name.singularize.camelize.constantize
exit
next
cielo
exit
next
cielo.number
cielo.client_number
cielo
exit!
response
exit
next
exit
response
exit
config.valid?
next
step
next
options.job_stats
next
exit
config
exit
next
upload_files
next
exit
payrolls
exit
build(:payroll_account_value)
build(:payroll_account_value).valid?
exit
build(:payroll_account_value).valid?
build(:payroll_account_value).payroll_data
build(:payroll_data)
build(:payroll_datum)
exit!
build(:payroll_account_value, value: '')
exit!
EXIT
exit
create(:payroll_datum, basic_data.merge(referencia: Date.new(2014,  7, 1), payroll_account_values: [build(:payroll_account_value_inss, value: 98_000)]))
create(:payroll_datum, basic_data.merge(referencia: Date.new(2014,  7, 1), payroll_account_values: []))
create(:payroll_datum, basic_data.merge(referencia: Date.new(2014,  7, 1)))
basic_data.merge(referencia: Date.new(2014,  7, 1)
  basic_data.merge(referencia: Date.new(2014,  7, 1)
    end
basic_data.merge(referencia: Date.new(2014,  7, 1))
PayrollDatum.last
PayrollDatum.all
PayrollDatum.where(payroll_id: 1)
exit
exit!
exit
build(:payroll_datum)
build(:payroll_datum).valid?
exit
build(:payroll_datum, referencia: '').valid?
''.to_date
exit!
build(:payroll_datum, referencia: '').valid?
build(:payroll_datum, referencia: '')
exit!
build(:payroll_datum, referencia: '')
build(:payroll_datum, referencia: '').valid?
exit!
build(:payroll_datum).valid?
build(:payroll_datum)
x=build(:payroll_datum)
x.valid?
x.errors
PayrollDatum.where(payroll_id: 1)
exit!
PayrollDatum.where(payroll_id: 1)
x=build(:payroll_datum)
x.valid?
x.errors
PayrollDatum.where(payroll_id: 1)
exit
build(:payroll_datum)
build(:payroll_datum).payroll
build(:payroll_datum).payroll.payroll_data.last
build(:payroll_datum).payroll.payroll_data.last.referencia + 1.month
exit
OpenSSL::SSL::OP_NO_TLSv1
next
attributes
exit
next
attributes
exit!
@payroll_datum.update(payroll_datum_params)
exit
puts page.body
exit!
find 'payroll[contrato]'
find '#payroll_contrato'
find('#payroll_contrato').fill
find('#payroll_contrato').fill_in
find('#payroll_contrato').fill_in with: ''
find('#payroll_contrato').fill_in 'a'
find('#payroll_contrato').fill_in {with: ''}
find('#payroll_contrato').fill_in({with: ''})
find('#payroll_contrato').value = '1'
find('#payroll_contrato').input
find('#payroll_contrato').value
exit!
inicia_em
exit
inicia_em
self.update status: 1
exit
status
exit
inicia_em
finaliza_em
exit
started_at
exit
payroll_data.to_potential.to_sql
exit
self
self.payroll
exit
payroll_data.to_potential.to_sql
exit
payroll_data.to_potential.to_sql
self
exit
payroll_data.to_potential.to_sql
exit
payroll_data.to_potential.to_sql
exit
payroll_data.to_potential.to_sql
exit
payroll_data.to_potential
payroll_data.to_potential.to_sql
payroll_data
payroll_data.first
payroll_data.last
payroll_data.to_potential.to_sql
payroll
self
exit!
exit
@report_effort.count
@report_effort
exit
efforts.count
params
params[:report_effort]
efforts.where(licenciamento_codevasf: false)
efforts.where(licenciamento_codevasf: false).count
efforts.where(licenciamento_codevasf: true).count
exit
efforts
exit
''.present?
'0'.present?
exit
frequencia
continue
next
@report_table
@report_table.to_csv
continue
response
l=
continue
register
continue
response
continue
register
continue
response
continue
register
continue
expected
json_response
movement.total_buy_unit_cost
continue
c
exit
SummarizedDailyMovement.joins(:product, :store).where(
  products: {
    code: params[:product_id],
    business_group_id: business_group_id
  },
  stores: { id: store_id }
).order(movement_date: :desc)
_
x=_
x.first
x.first.total_buy_unit_cost
x.first.buy_unit_cost
x.first.last_buy_unit_cost
x.first.last_buy_unit_cost.to_f
x.first.trade_in
43 * 38.0
continue
exit
json_response
expected
exit
continue
exit
@movements
@movements.to_sql
@movements.to_sql.gsub('"', '')
exit
@movements
exit
@movements
whereami
next
continue
c
n
exit
params
exit
continue
params
continue
params
continue
params
continue
params
continue
params
continue
params
continue
@page
c
@page
@movements
@movements.page
@movements.page_id
@movements.per_page
@movements.total_pages
continue
c
@page
c
User.last
User.first
User.last
User.last.update name: 'teste'
exit
@deposit
continu
continue
register
exit!
continue
response
@federal_service
@federal_service.taxes
federal_sercice_params
federal_service_params
params
exit!
@federal_service.taxes
federal_service_params
paraexit!
exit!
@federal_service.taxes
exit!
puts page.body
exit
puts page.body
find('#city_select')
find('#city_select').val()
find('#city_select').value
@states
continue
exit
puts page.body
find('#federal_retention_data')
find('#federal_retention_data').value
exit
FederalRetention
FederalRetention::Items
FederalRetention::Item
FederalRetention::Item.first
FederalRetention::Item.new
reload!
FederalRetention::Item.new
reload!
FederalRetention::Item.new
reload!
exit
continue
exit
next
exit!
next
step
next
continue
next
continue
record
options[:html]
simple_form_css_class(record, options)
next
step
next
default_field_error_proc
next
options
step
next
record
next
object
next
options
model_name_from_record_or_class(object)
options[:as]
next
step
convert_to_model(object)
next
options
polymorphic_path(record, {})
next
step
record_or_hash_or_array
next
step
get action, type
next
record_or_hash_or_array.compact
next
record_or_hash_or_array.first.is_a?(ActionDispatch::Routing::RoutesProxy)
next
builder.handle_list record_or_hash_or_array
builder
builder.handle_list
step
next
record_list
record_list.pop
next
l+
end
l=
record
record.model_name
record.model_name.singular_route_key
record.model_name
FederalRetention::Items
::FederalRetention::Items
::FederalRetentions::Items
record.model_name.klass
record.model_name.singular_route_key
whereami
record_list
step
route
suffix
route
next
record.to_model
record.to_model.singular_route_key
next
model
args
model
model.model_name
FederalRetention::Item
FederalRetention::Item.model_name
reload!
FederalRetention::Item.model_name
reload!
FederalRetention::Item.model_name
reload!
FederalRetention::Item.model_name
reload!
continue
exit!
exit
FederalRetention::Item.model_name
exit
controller_name
exit
FederalRetentionItem.new
FederalRetentionItem.model_name
FederalRetentionItem.model_name.name
FederalRetentionItem.model_name.route_key
OpenStruct.new(FederalRetentionItem.model_name)
FederalRetentionItem.model_name
FederalRetentionItem.model_name.attributes
FederalRetentionItem.model_name.instance_variables
reload!
FederalRetentionItem.model_name
exit
FederalRetention::Item.model_name
reload!
FederalRetention::Item.model_name
exit
continue
controller_name
continue
SupplyDetailQuery
SupplyDetailQuery.new.get_next_order
continue
SupplyDetailQuery.new.get_next_order
SupplyDetailQuery.new(params).get_next_order
continue
SupplyDetailQuery.new(params).get_next_order
continue
SupplyDetailQuery.new(params).get_next_order
SupplyDetailQuery.new(params, business_group_id, store_id).get_next_order
order
order.to_sql
order.to_sql.gsub('\"', '')
order.to_sql.gsub('"', '')
order.to_sql.gsub('"', '').gsub("\n", '')
continue
SupplyDetailQuery.new(params, business_group_id, store_id).get_next_order
order
OrdersCalendar::Inheritance
OrdersCalendar::Inheritance.new(store_id)
OrdersCalendar::Inheritance.solve(store_id)
OrdersCalendar::Inheritance.solve(product_store.store)
OrdersCalendar::Inheritance.solve(product_store.store, resource_id: product_store)
OrdersCalendar::InheritanceQuery.new(product_store.store)
OrdersCalendar::InheritanceQuery.new(product_store.store).inheritance
OrdersCalendar::InheritanceQuery.new(product_store.store).inheritance(product_store.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id))
OrdersCalendar::InheritanceQuery.new(product_store.store).inheritance(product_store.attributes.symbolize_keys.slice(:sector_id, :group_id, :sub_group_id))
product_store.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id)
OrdersCalendar.first
store_id
OrdersCalendar.first.orders_calendar_days
OrdersCalendar::InheritanceQuery.new(product_store.store).inheritance
exit
exit!
continue
register
response
continue
whereami
continue
User.new.companies
User.new.companies.name
User.new.companies.first
User.new.companies.first.name
exit
OrdersCalendar::InheritanceQuery.new(product_store.store).inheritance
SupplyDetailQuery.new(params, business_group_id, store_id).get_next_order
params
continue
User.roles
User.roles.cliente
User.roles['cliente']
exit
whereami
params
next
company_params
next
continue
SupplyDetailQuery.new(params, business_group_id, store_id).get_next_order
continue
SupplyDetailQuery.new(params, business_group_id, store_id).get_next_order
continue
SupplyDetailQuery.new(params, business_group_id, store_id).get_next_order
continue
SupplyDetailQuery.new(params, business_group_id, store_id).get_next_order
continue
product_store.sector_id
product_store.supplier_by_systematic
product_store.supplier_by_systematic.id
@store_id
continue
@store_id
product_store.sector_id
SupplyPolicy.first
SupplyPolicy.all
continue
product_store
product_store.sector_id
product_store.sector
continue
product_store.product_class_id
SupplyPolicy
SupplyPolicy.where(store_id: @store_id, sector_id: product_store.sector_id).count
product_store.product_class
SupplyPolicy.where(store_id: @store_id, sector_id: product_store.sector_id).all
continue
@supply_policy
@supply_policy.update service_level: 50, coverage_stock_days: 5
continue
product_store.supplier
product_store.sub_group
continue
week_day
week_calendar
week_calendar[week_day]
week_calendar
week_calendar.find{|k,v| k > 2}
continue
next
week_calendar
next
next_day_week
continue
next
weeks
days
week_day
continue
next
week_of_month
origin_week_of_month
week_day
origin_week_day
next_day_week
continue
next
weeks
days
date
date.from_now
date.since(weeks.weeks)
date.since(weeks.weeks).since(days.days)
date.since(1.weeks).since(days.days)
date + 1.weeks + days.days
continue
p
params
continue
@company_service
@company_service.taxes
continue
puts page.body
continue
Company.order(created_at: :desc)
Company.order(created_at: :desc).take
Company.order(created_at: :desc).take.to_sql
Company.order(created_at: :desc).take
Time.zone.today
Time.current
Time.current.class
Time.zone.today.class
Time.today
exit
credential.fields.first.name
credential.fields.first.nome
puts page.body
continue
puts page.body
continue
taxes
Tax.where(id: params[:profile_association][:taxes])
params[:profile_association][:taxes]
params[:profile_association]
params
continue
next
week_of_month
origin_week_of_month
weeks
continue
date
continue
date
next
exception
continue
next
total
movement.final_stock.to_i
sum_prediction_sales_to(date)
sum_prediction_deliveries_to(date)
continue
x
whereami
x.order
x.call
x.order
continue
x.order
continue
x.order
continue
x.order
x.order_item
x.order.order_items
x.order.order_items.new({})
x.order.order_items.new(product_id: 1)
x.order_item
x.order
x.order_item
y=x.order.order_items.new(product_id: 1)
y
continue
supply_service.order_item
supply_service.order
supply_service.order_item
continue
supply_service.order
supply_service.order_item
supply_service
supply_service.ps
continue
supply_service.order_item
exit!
supply_service.order_item
supply_service.call
supply_service.order_item
exit!
supply_service.xxx
supply_service.xxxx
supply_service.call
supply_service.xxxx
supply_service.xxxx = 1
continue
supply_service.xxxx
supply_service.order_item
continue
supply_service
supply_service.order_item
supply_service.instance_variable_names
continue
supply_service.instance_variable_names
continue
supply_service.order
supply_service.order_item
continue
supply_service.order_item
supply_service.order
continue
supply_service(@next_date).order_item
continue
puts page.body
exit
puts page.body
exit
continue
@next_date
continue
@next_date
continue
date
store_can_order? date
date = get_next_order_day(date)
store_can_order? date
date = get_next_order_day(date)
store_can_order? date
date = get_next_order_day(@date)
store_can_order? date
step
next
activity
date
@store_id
ActivityCalendar.all
activity.blank?
continue
@next_date
continue
@order
@order.save
continue
@next_date
supply_service(@next_date)
supply_service(@next_date).order
supply_service(@next_date).order_item
continue
@supply_detail
@supply_detail.order
@supply_detail.last_order
@supply_detail.final_stock
@supply_detail.xxx
continue
@supply_detail.xxx
object
object.movement
object.order
object.last_order
movement
pending_orders
helper
h
whereami
pending_orders
h.number_with_delimiter
l
continue
user
scope
next
continue
params
Order.all
OrderItem.all
params[:product_id]
Product.find_by_code(params[:product_id])
params
l=
SupplyDetailQuery.new(params[:product_id], business_group_id, store_id)
SupplyDetailQuery.new(params[:product_id], business_group_id, store_id).movement
EXIT
exit
continue
movement.product_id
@store_id
ProductStore.all
continue
final_stock
next
@supply_service.call
@supply_service.context
@supply_service.order
@supply_service.supply
@supply_service
@supply_service.context
@supply_service.supply_model.context
@supply_service.supply_model
@supply_service.supply_model.context
@supply_service.base_date
@supply_service.call
@supply_service.date
continue
Product.first
continue
supply_type
self
continue
next
continue
exit
exit!
continue
calendar.to_a
calendar
week_day
exit!
continue
exit!
count_weeks
continue
count_weeks
next_day
count_weeks == 6
count_weeks == 8
exit!
count_weeks 
continue
count_weeks 
l-
end
l=
up
count_weeks < =6
count_weeks <= 6
count_weeks <= 6 && next_day.blank?
exit!
count_weeks
exit!
continue
count_weeks
continue
exit!
continue
count_weeks
continue
SummarizedDailyMovement.where(product_id:    product_store.product_id,
  store_id:      @store_id,
  movement_date: @date..date
)
SummarizedDailyMovement.first
exit
continue
movement.final_stock.to_i
sum_prediction_sales_to(date)
sum_prediction_deliveries_to(date)
1 - 6 + 2
1 - 6
continue
OrderCalendar
OrdersCalendar
OrdersCalendarDay.all
OrdersCalendar.all
product_store.business_group_id
movement.business_group_id
product_store.store_id
continue
next
date
@date
exit
next
continue
next
date
next
e
continue
next
date
@date\
end
@date
OrdersCalendar.all
OrdersCalendar.first.orders_calendar_days
continue
next
date
continue
next
step
next
calendar.to_a
exit
next
date
continue
next
step
next
calendar.to_a
OrdersCalendar.first.orders_calendar_days
OrdersCalendar.first
product_store
continue
next
step
next
calendar.to_a
product_store
OrdersCalendar.first
OrdersCalendar.all
OrdersCalendar.first.orders_calendar_days
next
calendar
continue
next
step
next
calendar
whereami
product_store.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id)
OrdersCalendar.first.orders_calendar_days.first.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id)
OrdersCalendar.first.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id)
continue
next
get_next_order_day(@date)
step
next
calendar
calendar.to_a
whereami
calendar.inheritance(product_store.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id))
OrdersCalendar.first.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id)
calendar.inheritance(product_store.attributes.symbolize_keys.slice(:supplier_id))
product_store.supplier_id
continue
get_next_order_day(@date)
next
step
next
OrdersCalendar.first.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id)
product_store.attributes.symbolize_keys.slice(:supplier_id, :sector_id, :group_id, :sub_group_id)
calendar.inheritance(product_store.attributes.symbolize_keys.slice(:supplier_id))
OrdersCalendar.all
product_store
continue
next
step
next
calendar
calendar.inheritance
continue
next
step
next
calendar.to_a
continue
next
date
next
@service.order
@service.order_item
continue
@service
@service.order_item
continue
@service.order_item
continue
@service
next_order
@supply_service
@supply_service.call
get_next_order_day(@date)
step get_next_order_day(@date)
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
calendar.to_a
continue
get_next_order_day(@date)
calendar.to_sa
calendar.to_a
next
count_weeks
next
count_weeks
next
calendar
week_calendar
OrdersCalendar.first.orders_calendar_days
week_of_month(date)
week_of_month
calendar
calendar[week_of_month]
whereami
next
count_weeks
next
week_calendar
next
next_day_week
next
n_weeks
next
n_days
date
date + -2 + -1
count_weeks
date + count_weeks.weeks
continue
next
continue
next
count_weeks
n_days
next
n_days
date
date + count_weeks.weeks
date + count_weeks.weeks + n_days.days
next_days
next_day
origin_week_day
2 - 4
week_day
next_day
continue
exit!
next
whereami
next_day
origin_week_day
next
n_days
date
date + count_weeks.weeks
count_weeks
date + count_weeks.weeks + n_days
exit!
day
value
day % 7
1 % 7
41 % 7
41 / 7
30 / 7
20 / 7
10 / 7
7 / 7
3 / 7
6 / 7
7 / 7
reload!
continue
next_day
count_weeks
date
continue
count_weeks
next_day
continue
count_weeks
next_day - origin_week_day
continue
movement.final_stock
continue
whereami
x
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date)
whereami
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8)')
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total')
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total').total
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total').first
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total')
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total')[0]
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total')[0].total
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total').to_a.first
y=SummarizedDailyMovement.where(product_id:    product_store.product_id,store_id:      @store_id,movement_date: @date..date).select('sum(pvdm8) as total').to_a.first.total
continue
exit!
next
OrdersCalendarDay.first
continue
OrdersCalendarDay.first
calendar
week_of_month
next
week_calendar
week_of_month
next
week_calendar
next
next_day_week
next
next_day
next
subject
cotinue
continue
date
count_weeks
next_day
origin_week_day
next_day - origin_week_day
date + count_weeks.weeks + (next_day - origin_week_day).days
date + 4.weeks + (next_day - origin_week_day).days
continue
count_weeks
date + (count_weeks - 1).weeks + (next_day - origin_week_day).days
continue
date + (count_weeks - 1).weeks + (next_day - origin_week_day).days
continue
date
count_weeks
calendar
continue
origin_week_day
next_day
Date.today.wday
calendar
count_calendar
count_weeks
date + (count_weeks - 1).weeks + (next_day - origin_week_day).days
date + (count_weeks).weeks + (next_day - origin_week_day).days
calendar
continue
date + (count_weeks).weeks + (next_day - origin_week_day).days
calendar
count_weeks
continue
date + (count_weeks).weeks + (next_day - origin_week_day).days
continue
next_day
count_weeks
calendar
continue
date
continue
calendar
exit
exit!
date
store_order_on?(date)
context
continue
exit!
date
context
exit
exit!
calendar.to_a
OrdersCalendarDay.all
OrdersCalendar.first
OrdersCalendar.all
whereami
@ps.store
OrdersCalendar.all
continue
exit!
calendar.to_a
@ps.store
OrdersCalendar.all
exit!
calendar.to_a
continue
interval
continue
interval
continue
coverage_sum
coverage_weighted_sum
exit!
continue
context
context.forecast
continue
exit!
continue
exit!
continue
coverage_amount
order_quantity
linear_front
current_inventory
pending_orders
exit
coverage_sum
continue
coverage_amount
order_quantoty
order_quantity
continue
exit!
interval
exit!
interval
deadline
continue
list_api_params
CockpitForecastListQuery.new(list_api_params)
CockpitForecastListQuery.new(list_api_params).all
CockpitForecastListQuery.new(list_api_params).query
CockpitForecastListQuery.new(list_api_params).query.to_sql
SummarizedDailyMovement.where(movement_date: Date.today)
`1\"SELECT\ \\\"cockpit_details_lists\\\".\*\ FROM\ \\\"cockpit_details_lists\\\"\ WHERE\ \\\"cockpit_details_lists\\\".\\\"business_group_id\\\"\ =\ \'44da87eb-9749-4a68-b141-aa8f985c0874\'\ AND\ \\\"cockpit_details_lists\\\".\\\"store_id\\\"\ =\ \'b3a6f8c0-7a49-4094-aec5-0013ffb25156\'\ AND\ \\\"cockpit_details_lists\\\".\\\"regional_id\\\"\ =\ \'e3743a3b-d4b2-49d6-840a-f51932f9035c\'\ AND\ \\\"cockpit_details_lists\\\".\\\"movement_date\\\"\ =\ \'2015-10-26\'\"
end
puts 1
' 
"
`
SummarizedDailyMovement.where(movement_date: Date.today)
ForecastJob.perform_later "0042e497-d0f4-4bb5-ba70-e2d15174f737"
SummarizedDailyMovement.where(movement_date: Date.today)
SummarizedDailyMovement.reload.where(movement_date: Date.today)
continue
line
continue
line
next
continue
next
format(default_params.merge(Hash[*header.zip(line).to_a.flatten]))
exit
continue
next
format(default_params.merge(Hash[*header.zip(line).to_a.flatten]))
exit
continue
next
format(default_params.merge(Hash[*header.zip(line).to_a.flatten]))
default_params.merge(Hash[*header.zip(line).to_a.flatten])
default_params
continue
line
continue
line
next
format(default_params.merge(Hash[*header.zip(line).to_a.flatten]))
exit
exit!
continue
line
probe_separator
separator
exit
probe_separator
exit
probe_separator
exit
continue!
continue
exit!
line
exit
line
continue
line
next
default_params
continue
next
default_params
default_params.merge(Hash[*header.zip(line).to_a.flatten])
format(default_params.merge(Hash[*header.zip(line).to_a.flatten]))
header
continue
raise
continue
raise
raise Exception
continue
exit!
next
self.header
line
first_line_header?
self.header = 1
self.header = []
self.header
exit!
line
next
line
first_line_header?
line
self.header = line
self.header
exit!
continue
self.header
next
default_params.merge(Hash[*header.zip(line).to_a.flatten])
exit
exit!
continue
next
continue
next
hash
exit
exit!
continue
next
continue
next
hash
next
hash
whereami
next
continue
next
hash
whereami
next
continue
next
hash
next
continue
exit
continue
next
hash
continue
exit
next
hash
whereami
create_or_update(hash)\
end
create_or_update(hash)
exit
exit!
hash
whereami
continue
hash
create_or_update(hash)
continue
exit!
hash
create_or_update(hash)
business_group
business_group.stores.first.product_stores
business_group.stores.first.products_stores
%i(a b)
continue
exit
exit!
hash
continue
create_or_update(hash)
continue
h
help
exit
exit-all
!!@
!!!
erros
errors
continue
enqueued_jobs
assert_enqueued_jobs 1
ForecastJob.perform_later('')
assert_enqueued_jobs 1
store.products_stores
next
assert_enqueued_jobs 1
continue
subject.errors
store.product_movements
subject
subject.imported
subject.importeds
subject.imports
subject.import
continue
subject.errors
continue
create_or_update(format(default_params.merge(clean_hash(row.to_hash))))
errors
ProductMovement.all
continue
create_or_update(format(default_params.merge(clean_hash(row.to_hash))))
continue
subject
ProductMovement.all
continue
subject
ProductMovement.all
continue
ProductMovement.all
continue
self
continue
column
action
summarization
continue
summarization
continue
summarization
continue
summarization
continue
movements
ProductMovement.all
StockAndPendingOrder.all
ProcessPendingOfStockAndMovement.all
SummarizedDailyMovement.all
exit!
movements
ProcessPendingOfStockAndMovement.all
ProcessPendingOfStockAndMovement.all.to_sql
exit!
movements
exit!
movements
continue
next
obj
next
obj.errors
continue
exit!
continue
context
context.count
ProcessPendingOfStockAndMovement.all
exit!
continue
movements
exit!
movements
continue
movements
exit!
continue
movements
continue
subject.destroy!
continue
subject.destroy!
continue
text
tprofiles
exit!
Delayed::Job.count
job
continue
job
continue
Delayed::Job.count
job
continue
exception
exception.to_s
continue
e
Delayed::Job.all
exit!
job
@xxx
@xxx = job
continue
@xxx
@xxx.id
@xxx.job_id
ProductStore.last
ProductStore.last.display_rack_capacity
ProductStore.last.increment :display_rack_capacity
ProductStore.last.reload
ProductStore.last.increment :display_rack_capacit
exit!
x
total_processed
process_with_errors
process_with_errors.size
whereami
total_process
29/1147
29/1147.0
(29/1147.0)*100
continue
JobProcessManager.first.process_with_errors.each{|id| Delayed::Job.find_by(id: id) }
JobProcessManager.first.process_with_errors.map{|id| Delayed::Job.find_by(id: id).present? };nil
JobProcessManager.first.process_with_errors.map{|id| Delayed::Job.find_by(id: id).present? }
JobProcessManager.first.process_with_errors.first(5)
ActiveJob
ActiveJob.find
Delayed::Job.first
exit
job
job.
end
whereami
exit!
c
continue
next
continue
exit!
job
continue
e
SupplyService
exit!
job
continue
exit!
Nokogiri
xml=Nokogiri::XML('/Users/euricovidal/Downloads/example.xml')
xml=Nokogiri::XML(File.open('/Users/euricovidal/Downloads/example.xml'))
xml=Nokogiri::XML(File.open('/Users/euricovidal/Downloads/example.xml')){|c| c.strict.nonet}
xml=Nokogiri::XML(File.open('/Users/euricovidal/Downloads/exemplo.xml')){|c| c.strict.nonet}
xml=Nokogiri::XML('/Users/euricovidal/Downloads/examplo.xml')
xml=Nokogiri::XML(File.open('/Users/euricovidal/Downloads/exemplo.xml')){|c| c.strict.nonet}
xml
xml.to_h
xml=Nokogiri::XML(File.open('/Users/euricovidal/Downloads/exemplo.xml'))
xml=Nokogiri::XML(File.read('/Users/euricovidal/Downloads/exemplo.xml'))
xml=Nokogiri::Slop(File.read('/Users/euricovidal/Downloads/exemplo.xml'))
xml=Nokogiri::Slop(File.read('/Users/euricovidal/Downloads/exemplo.xml').to_s)
xml=Nokogiri::XML(File.read('/Users/euricovidal/Downloads/exemplo.xml'))
CNPJ
exit
xml=Nokogiri::XML(File.read('/Users/euricovidal/Downloads/exemplo.xml'))
xml['document]
xml['document']
'
xml['document']
xml.first
xml
xml.document
xml.document.children
xml.document.document
xml.document.document.document
xml.children
xml.children.first
xml.children.first.children
xml.children.first.children.document
xml.children.first.children
xml.children.first.children.element
xml
xml.xpath('//USUARIO_CPF_CNPJ')
xml.xpath('//USUARIO_CPF_CNPJ').to_s
xml.xpath('//USUARIO_CPF_CNPJ').text
xml.document.document
reload!
xml=Nokogiri::XML(File.read('/Users/euricovidal/Downloads/exemplo.xml'))
xml.xpath('//USUARIO_CPF_CNPJ')
xml.xpath('//USUARIO_CPF_CNPJ').text
xml.xpath('//USUARIO_CPF_CNPJ').first
xml.xpath('//USUARIO_CPF_CNPJ').first.text
xml.xpath('//USUARIO_CPF_CNPJ').first.to_s
xml.xpath('//USUARIO_CPF_CNPJ').first.text
xml.xpath('//USUARIO_CPF_CNPJ[0]').first.text
xml.xpath('//USUARIO_CPF_CNPJ[0]')
xml.xpath('//[0]USUARIO_CPF_CNPJ')
xml.xpath('//USUARIO_CPF_CNPJ[0]')
xml.xpath('//USUARIO_CPF_CNPJ').first.text
xml.xpath('//NOTA_FISCAL')
xml.xpath('//NOTA_FISCAL').size
xml.xpath('//NOTA_FISCAL').first
xml.xpath('//NOTA_FISCAL').first['TIPO']
xml.xpath('//NOTA_FISCAL').first.size
xml.search('//NOTA_FISCAL')
xml.search('//NOTA_FISCAL').size
xml.search('//NOTA_FISCAL').first
xml.search('NOTA_FISCAL').first
xml.search('USUARIO_CPF_CNPJ').first
xml.search('USUARIO_CPF_CNPJ').first.to_s
xml.search('USUARIO_CPF_CNPJ').first.text
xml.at('USUARIO_CPF_CNPJ').text
xml.search('NOTA_FISCAL').first
xml.search('NOTA_FISCAL').first.search('TIPO')
xml.search('NOTA_FISCAL').first.at('TIPO')
xml.search('NOTA_FISCAL').first.at('TIPO').text
xml.search('NOTA_FISCAL').first.at('tipoo').text
xml.search('NOTA_FISCAL').first.at('tipo').text
exit
xml=Nokogiri::XML(File.read('/Users/euricovidal/Downloads/exemplo.xml'))
xml.xpath('//TOMADOR')
xml.xpath('//TOMADOR*')
xml.xpath('//TOMADOR.')
xml.search('TOMADOR')
xml.search('TOMADOR*')
xml.css('TOMADOR*')
Company.first
c=Company.first
c.instance_variable_get 'numero'
c.instance_variable_get '@numero'
c.instance_variable_get ':@numero'
c.instance_variable_get ':numero'
c.instance_variable_get '@numero'
c.write_attribute(:numero, '123')
reload!
XmlParser
XmlParser::ParserService
XmlParser::ParserService.new
reload!
XmlParser::ParserService.new
Rails.root
reload!
XmlParser::ParserService.new
nota=XmlParser::ParserService.new
nota.call
reload!
XmlParser::ParserService.new.call
@document.at('USUARIO_CPF_CNPJ').text
CNPJ.new @document.at('USUARIO_CPF_CNPJ').text
Company.find_by_cnpj(CNPJ.new(@document.at('USUARIO_CPF_CNPJ').text))
Company.find_by_cnpj(CNPJ.new(@document.at('USUARIO_CPF_CNPJ').text).to_s)
continue
reload!
XmlParser::ParserService.new.call
CNPJ.new(@document.at('USUARIO_CPF_CNPJ').text).formatted
continue
reload!
CNPJ.new(@document.at('USUARIO_CPF_CNPJ').text).formatted
XmlParser::ParserService.new.call
continue
reload!
XmlParser::ParserService.new.call
reload!
XmlParser::ParserService.new.call
reload!
XmlParser::ParserService.new.call
XmlParser::ParserService.new
Company.first
Company.first.update cnpj: CNPJ.new('18246327000103').formatted
XmlParser::ParserService.new.call
reload!
XmlParser::ParserService.new.call
reload!
XmlParser::ParserService.new.call
reload!
XmlParser::ParserService.new.call
from
next
document.at(from)
continue
document.at(from)
continue
document.at(from)
from
continue
reload!
XmlParser::ParserService.new.call
reload!
XmlParser::ParserService.new.call
@partner.errors
@partner.errors.full_messages
continue
reload!
XmlParser::ParserService.new.call
exit
XmlParser::ParserService.new('invoice_id').call
exit
all_movements
all_movements.keys
all_movements.first
continue
context.error
context.count
movements
conitnue
continue
continue!
?
h
help
exit
exit-all
help
exit-program
continue
exit-program
{x: 1,**hash}
from_yesterday
continue
continue!
continue-all
exit-program
hash
movement.actual_sales
movement.synced
continue
hash
continue
exit-program
'EuricoVidal'.underscore
'EuricoVidal'.humanize
'EuricoVidal'.underscore.humanize
'EuricoVidal'.underscore.titleize
'EuricoVidal'.titleize
XmlInvoiceParser::ParserService.new('invoice_id').call
exit
x = false
x ||= 1
x
false.blank?
exit
XmlInvoiceParser::ParserService.new('invoice_id').call
ParseInvoiceXmlJob.perform_later(Invoice.last.id)
exit
ParseInvoiceXmlJob.perform_later(Invoice.last.id)
nil.respond_to
nil.respond_to?
nil.respond_to? :text
exit
Delayed::Job.first
Delayed::Job.first.last_error
YAML.parse Delayed::Job.first.last_error
YAML.parse(Delayed::Job.first.last_error)['value']
YAML.parse(Delayed::Job.first.last_error)
exit
movements.count
exit!
movements.count
continue
movements.count
ProductMovement.count
ProductMovement.first
context.business_group.id
SummarizedDailyMovement.count
ProcessPendingOfStockAndMovement.count
StockAndPendingOrder.count
exit
index
action_name
quantity
exit
index
exit
exit!
movements.count
ProductMovement.count
StockAndPendingOrder.count
SummarizedDailyMovement.count
puts 1
ProductMovement.all
StockAndPendingOrder.all
exit
movements.count
ProductMovement.count
ProductMovement.pluck(:product_code, :store_code)
StockAndPendingOrder.pluck(:product_code, :store_code)
SummarizedDaily
ProductMovement.pluck(:date)
StockAndPendingOrder.pluck(:date)
StockAndPendingOrder.pluck(:stock_date)
StockAndPendingOrder.all.pluck(:stock_date)
StockAndPendingOrder.first
exit!
SummarizedDailyMovement.first
ProductMovement.all
movements
StockAndPendingOrder.all
movements
exit
all_data_to_process.count
all_data_to_process
whereami
exit!
continue
summarize_product_movement(store, product, date)
continue
hash
exit!
from_to
exit
from_to
fix_value(from_to.keys.first, from_to.values.first)
document.at(form_to.keys.first)
document.at(from_to.keys.first)
document.at(from_to.keys.first.to_s)
exit
continue
all_data_to_process
continue
hash
continue
data.movements
next
from_yesterday
whereami
hash_without_movement_data(
  data.movements.zero?, data.stocks.zero?, from_yesterday
)
exit!
continue
next
hash_without_movement_data(data.movements.zero?, data.stocks.zero?, from_yesterday)
hash
continue
exit!
exit
CNPJ.generate
CNPJ.generate.formatted
CNPJ.generate
CNPJ.generate(1)
exit
less_than_or_equal_to_7_days?
next
vid
vid.zero?
next
vajda
next
calc
calc.nan?
calc.round
next
forecast
continue
next
vajda
continue
next
vajda
continue
vajda
continue
next
less_than_or_equal_to_7_days?
conitnue
continue
next
step
historical
exit!
next
vid
next
vajdea
cvl
next
continue
cvl
continue
exit!
next
vid
next
ndn0
cdn
Σvajnda 
dpvajnd 
Σvajnda / ndn0
dpvajnd 
SupplyPolicy.all
continue
value
to
continue
value
continue
exit
value
continue
company
next
Notification.create(reference: @invoice, titulo: 'xxxx')
x=Notification.create(reference: @invoice, titulo: 'xxxx')
x.errors
continue
partner
subject
continue
@document.at('USUARIO_CPF_CNPJ').text
CNPJ.new(@document.at('USUARIO_CPF_CNPJ').text).formatted
Company.all
exit!
to
next
continue
next
to
continue
to
continue
to
continue
to
continue
to
continue
to
continue
to
continue
to
continue
to
continue
to
next
exit!
subject
Partner.count
Notification.count
Notification.all
continue
@partner
@partner.save
@partner
exit!
@partner.save
exit!
subject
Notification.all
continue
'xx    xxx'.trim
'xx    xxx'.compact
'xx    xxx'.strip
'xx    xxx'.strip!
'xx    xxx'.squish
'xx    xxx    '.squish
exit
continue
Notification.all
subject
Notification.all
exit
continue
next
ndn0de
cdn
Σvajdnde 
dpvajnde 
Σvajdnde / ndn0de + dpvajnde * cdn
step
next
exit!
Σvajdnde 
ndn0de 
dpvajnde 
date
dpvaj_values(date)
dpvaj_values(date).select { |v| v > 0 }
dpvaj_values(date).select { |v| v > 0 }.standard_deviation
x=dpvaj_values(date).select { |v| v > 0 }
x.mean
x.inject(0) { |accum, value| accum + (value - x.mean) ** 2 }
0.0 / 0
exit!
dpvajnde
cdn
Σvajdnde / ndn0de + dpvajnde * cdn
continue
exit!
(Σvajdnde / ndn0de) 
(dpvajnde * cdn) 
cvsl
exit!
store_sale_on?
next
cdn
dpvajnde 
pvdmx_1_and_6_and_7(7.days, :pvdm1) 
pvdmx_1_and_6_and_7(7.days, :pvdm1) + 0
pvdmx_1_and_6_and_7(7.days, :pvdm1) + 0 * 0
continue
exit!
cdn
next
pvdmx_1_and_6_and_7(7.days, :pvdm1) 
dpvajnde 
pvdmx_1_and_6_and_7(7.days, :pvdm1) + dpvajnde * cdn
continue
pvdmx_1_and_6_and_7(7.days, :pvdm1) + dpvajnde * cdn
continue
pvdmx_1_and_6_and_7(7.days, :pvdm1) + dpvajnde * cdn
current_date
continue
current_date
continue
exit!
price
price.to_f
vi_icms
price.round(2)
price.round(2).to_f
exit
exit!
subject 
company
exit!
subject
next
cpf_cnpj_key
exit!
next
cpf_cnpj_key
continue
next
CNPJ.new(@document.at(cpf_cnpj_key).text).formatted
Company.first.cnpj
next
verify_and_update_data
step
next
e
exit
next
sale
next
e
exit!
continue
data
@invoice
company
sale
sale.save
sale.save(data, @invoice, company)
exit!
next
step
next
e
exit
exit!
next
continue
exit!
continue
company
company.company_service_types
municipal_service
MunicipalService.find_by_codigo(document.at('COS_SERVICO').text)
document.at('COS_SERVICO').text
exit!
continue
municipal_service
company.company_service_types.where(municipal_service: municipal_service)
company.company_service_types
company.company_service_types.municipal_service
company.company_service_types.municipal_services
company.company_service_types.first.municipal_service
exit!
continue
company.company_service_types.municipal_services
company.company_service_types.first.municipal_services
company.company_service_types.first.municipal_service
next
@serivce
company.company_service_types.where(municipal_service: municipal_service)
@service
exit!
continue
next
e
exit!
continue
@service
company.company_service_types.find_by_municipal_service(municipal_service) 
company.company_service_types.find_by_municipal_service_id(municipal_service) 
@service = company.company_service_types.find_by_municipal_service_id(municipal_service) 
next
@service = company.company_service_types.find_by_municipal_service_id(municipal_service) 
@service
next
continue
@sale
@sale.valid?
next
sale.id
next
e
continue
subject
Notification.all
exit!
profile_association
exit!
profile_association
profile_association.profile_association_taxes
profile_association.profile_association_taxes.frist
continue
exit!
subject
Notification.all
Notification.pluck(:titulo)
Notification.first
Notification.first.reference
exit!
subject
Notification.first
continue
'aaxaaa'.tr('x', '')
'aaxaxxxaa'.tr('x', '')
nil.tr('x', '')
exit
service_clazz
next
type
partner
whereami
type
partner.tomador
quantity
partner.send(type)
next
save_invoice_action(partner, data, type)
step
next
action_clazz
exit!
next
save_invoice_action(partner, data, type)
save_invoice_action(partner, data, type).errors
step
next
invoice_action
next
invoice_action
action
invoice_action.purchase
invoice_action.purchase.save
invoice_action.purchase.errors
whereami
exit!
continue
@service
codigo_servico
@supplier.city.city_activity.municipal_services
@supplier.city.city_activity
@supplier.city
@supplier.city.city_activity
@supplier.city.city_activities
exit!
Company.first
Company.last
Company.last.attests
@company
session
session.to_a
sessions
session[:company_id]
continue
session[:company_id]
get_company_from_session
continue
get_company_from_session
get_company_from_session.attests
get_company_from_session.attests.take
continue
exit
movement
SummarizedDailyMovement.count
@date
SummarizedDailyMovement.pluck(:movement_date)
continue
movement
@date
SummarizedDailyMovement.pluck(:movement_date)
continue
movement
@date
SummarizedDailyMovement.pluck(:movement_date)
continue
SummarizedDailyMovement.pluck(:movement_date)
@date
Time.zone.today
Time.zone
continue
Time.zone
Time.zone.today
continue
Time.zone.today
exit!
Date.today
Time.zone.now
Time.zone.local
Time.zone.local(2015)
Time.zone.local(2015, 10)
Time.zone.local(2015, 10, 15)
Time.zone.today
Time.zone.local(2015, 10, 15)
exit!
Time.zone.day
Time.zone.today
exit
exit!
Time.zone.today
exit!
continue
exit!
movement
@date
SummarizedDailyMovement.pluck(:movement_date)
exit!
movement
continue
@date
SummarizedDailyMovement.pluck(:movement_date)
exit!
today
subject
exit!
Time.zone.today
Delorean.time_travel_to(today)
today
Delorean.time_travel_to(Date.new(2015, 1, 1))
Time.zone.today
exit!
job
continue
exit!
Delayed::Job.first
exit!
admin.admin?
next
puts page.body
exit!
cliente.cliente?
next
puts page.body
@company
current_company
exit!
puts page.body
exit!
puts page.body
cliente.companies
next
session
request.session
next
puts page.body
exit!
@attests
exit!
puts page.body
exit!
$xxx
Notification.all
next
e
continue
next
step
next
exit!
next
step
next
exit!
next
Notification.all
next
Notification.all
next
Notification.all
next
Notification.all
MunicipalService.all
MunicipalService.last
MunicipalService.last.city_acitivity
MunicipalService.last.city_acitivity_id
MunicipalService.last.city_activity
MunicipalService.last.city_activity.city
exit!
next
Notification.all
next
Notification.all
next
Notification.all
next
continue
next
Notification.all
next
continue
exit!
e
e.trace
e.methods.sort
whereami
e.backtrace
e.backtrace.join("\n")
e.message
exit!
Delayed::Job.first
exit!
Delayed::Job.first
Delayed::Job.destroy_all
Delayed::Job.first
exit
JobProcessManager.destroy_all
exception
@job_manager
next
@job_manager
@job_manager.reload!
@job_manager.reload
exit!
JobProcessManager.first
exception
exception.message
exit!
exit!
Delayed::Job.first
JobProcessManager.first
JobProcessManager.last
exception
exception.message
exit!
JobProcessManager.update process_with_errors: []
JobProcessManager.update :process_with_errors, []
JobProcessManager.last.update :process_with_errors, []
JobProcessManager.last.update process_with_errors: []
JobProcessManager.last
continue
exit!
exit
Delayed::Job.destroy_all;nil
JobProcessManager.destroy_all
Delayed::Job.destroy_all;nil
Delayed::Job.count
Delayed::Job.destroy_all;nil
JobProcessManager.destroy_all
JobProcessManager.first
JobProcessManager.destroy_all
Delayed::Job.destroy_all;nil
job
exit!
exit!
redis
exit
redis
a, b = [1, 2]
a
b
nil.to_date
exit
$redis
$redis.incr('xxxx')
exit
$redis.incr('xxxx')
$redis
exit
$redis
exit
$redis
$redis.incr('xxxx')
reload!
exit
$redis
$redis.incr('xxxx')
exit
$redis
$redis.incr('xxxx')
exit
$redis.get('xxxx')
$redis.get('xxxxz')
$redis.get('xxxxx')
$redis.get('xxxxx').to_i
exit
$redis.get('xxxxx')
$redis.get('xxxx')
$redis.del('xxxx')
$redis.get('xxxx')
$redis.get("xxx:#{Date.today}")
"xxx:#{Date.today}"
exit
JobProcessManager.first
JobProcessManager.first.delete
exit
JobProcessManager.first.delete
DATE_FORMAT
DATE
FORMAT_DATE
exit
Delayed::Job.destroy_all;nil
Delayed::Job.count
exit
JobProcessManager.first
JobProcessManager.first.processing!
exit
User.first
User.first.owner
User.first.clientes
User.first.clients
reload!
User.first
User.first.owner
User.first.clients
exit
User.first.clients
User.first.ownser
User.first.owner
reload!
User.first.owner
User.first.clients
@user.valid?
@user.errors
continue
format
format.to_s
format.html
format.js
request
request.format
continue
exit
SecureRandom.new
SecureRandom.md5
SecureRandom
SecureRandom::MD5
SecureRandom::Md5
Md5
md5
SecureRandom.hex
@user.valid?
continue
exit
Delayed::Job.destroy_all;nil
JobProcessManager.first.with_error!
exit
total_processed
total_process
exit!
total_processed
exit
exit!
total_processed
total_process
processing?
next
self
self.status
continue
continue!
exit!
$redis
$redis.del
$redis.del 'xx'
JobProcessManager.all
JobProcessManager.count(status: 1)
continue
@user
@user.skip_confirmation!
@user
continue
@user
@user.skip_confirmation_notification!
continue
User.first
User.last
User.where(email: 'rep8@cliente.com')
User.find('7af220e9-d208-4f94-b021-c5bd7f209210')
@owner
params
current_path
request.path
continue
@owner
continue
User.where(email: 'rep9@cliente.com')
User.where(email: 'rep9@cliente.com').owner
User.where(email: 'rep9@cliente.com')
User.where(email: 'rep9@cliente.com').first
User.where(email: 'rep9@cliente.com').first.owner
exit
continue
JobProcessManager.all
continue
JobProcessManager.all
continue
super
continue
super
continue
super
continue
exit!
total_processed
exit!
total_processed
$redis
$redis.get
exit!
total_processed
Redis
Redis.new
exit!
total_processed
reference_date
exit!
total_processed
continue
conitnue
continue
exception
continue
exception.to_s
exception.message
continue
exception.message
product_store_id
next
@job_manager
@job_manager.save!
@job_manager.reload
JobProcessManager.count
continue
exit!
nil.days
nil.to_i
nil.to_i.days
nil.to_i.days.zero?
nil.to_i.days.from_now
process_with_error
continue
time_ago_in_words
ApplicationHelper.time_ago_in_words
ApplicationHelper..newtime_ago_in_words
ApplicationHelper..new.time_ago_in_words
helpers.time_ago_in_words
helper.time_ago_in_words
helper
helper.time_ago_in_words
helper.time_ago_in_words 1.day
helper.time_ago_in_words 1.day.form_now
helper.time_ago_in_words 1.day.from_now
helper.time_ago_in_words 50.minutes.from_now
helper.time_ago_in_words 1.day.from_now
exit
helper.time_ago_in_words 0.day.from_now
exit
cliente
cliente_from_cliente
exit!
cliente_from_cliente
continue
puts page.body
exit!
next
puts page.bodu
puts page.body
next
e
continue
next
puts page.body
exit!
next
puts page.body
exit!
@company.representante_legal
continue
puts page.body
continue
puts page.current_path
puts page.body
continue
next
puts page.body
Faker::Name.name
User.count
next
e
continue
nex
next
find('Nome')
puts page.body
find('#name')
find('#user_name')
find('#user_name').value
exit
company_service_type_params
continue
company_service_type_params
params
params[:company_service_type]
continue
company_service_type_params
continue
params
continue
company_service_type_params
continue
3.months.ago
exit
[1,2,3,4,5].avg
exit
puts page.body
exit
exit!
pts page.bod
exit
exit!
SimplesNacionalGroup.first
SimplesNacionalGroup.first.company_service_types
SimplesNacionalGroup.new.company_service_types
exit
SimplesNacionalGroup.create
SimplesNacionalGroup.create name: 'test'
SimplesNacionalGroup.create nome: 'test'
SimplesNacionalGroup.first
SimplesNacionalGroup.first.company_service_types
reload!
SimplesNacionalGroup.first.company_service_types
exit
codigo
method =~ /type_([a-z_])+\?/
$1
$redis
method =~ /type_([a-z_]+)\?/
$1
continue
Hash.new(nil)
Hash.new({a: 1})
Hash.new[{a: 1}]
Hash[{a: 1}]
Hash[nil]
Hash[*nil]
Hash[*{a: 1}]
exit
report_params
params
continue
hash
next
params
next
has
continue
hash
hash[:report_type_id] = params[:report_type_id],
1
continue
Report.new
Report.new data_inicio: ''
Report.new data_inicio: '', data_fim: '', user_id: '6e20c1ed-42dc-42a3-93ce-f057f940fe9f'
Report.new data_inicio: '', data_fim: '', user_id: '6e20c1ed-42dc-42a3-93ce-f057f940fe9f', report_type_id: nil
Report.new data_inicio: '', data_fim: '', user_id: '6e20c1ed-42dc-42a3-93ce-f057f940fe9f', report_type_id: nil, campos: {}
Report.new data_inicio: '', data_fim: '', user_id: '6e20c1ed-42dc-42a3-93ce-f057f940fe9f', report_type_id: nil, campos: {"destinatario"=>"", "finalidade"=>""}
r=Report.new data_inicio: '', data_fim: '', user_id: '6e20c1ed-42dc-42a3-93ce-f057f940fe9f', report_type_id: nil, campos: {"destinatario"=>"", "finalidade"=>""}
r.valid?
r.errors
r=Report.new data_inicio: '', data_fim: '', user_id: '6e20c1ed-42dc-42a3-93ce-f057f940fe9f', report_type_id: nil, campos: {"destinatario"=>"", "finalidade"=>""}, company_id: '02d94e59-e696-4279-9ebe-221d0810a982'
r.valid?
report_params
current_company.reports.new(report_params)
current_company.reports.new data_inicio: '', data_fim: '', report_type_id: nil
current_company.reports.new 'data_inicio' => '', data_fim: '', report_type_id: nil
current_company.reports.new report_params.merge(data_inicio: '', data_fim: '', report_type_id: nil)
current_company.reports.new report_params.merge(campos: {])
current_company.reports.new report_params.merge(campos: {})
report_params
report_params.class
current_company.reports.new {"data_inicio"=>"",
current_company.reports.new {"data_inicio"=>"","data_fim"=>"","campos"=>{"destinatario"=>"", "finalidade"=>""}
}
current_company.reports.new "data_inicio"=>"","data_fim"=>"","campos"=>{"destinatario"=>"", "finalidade"=>""}
current_company.reports.new "data_inicio"=>"","data_fim"=>"","campos"=>{"destinatario"=>"", "finalidade"=>""}, "user_id"=>"6e20c1ed-42dc-42a3-93ce-f057f940fe9f"
report_params
current_company.reports.new "data_inicio"=>"","data_fim"=>"","campos"=>{"destinatario"=>"", "finalidade"=>""}, "user_id"=>"6e20c1ed-42dc-42a3-93ce-f057f940fe9f","report_type_id"=>nil
current_company.reports.new({"data_inicio"=>"","data_fim"=>"","campos"=>{"destinatario"=>"", "finalidade"=>""}, "user_id"=>"6e20c1ed-42dc-42a3-93ce-f057f940fe9f","report_type_id"=>nil})
report_params
current_company.reports.new(report_params)
current_company.reports.new(report_params.dup)
current_company.reports.new(report_params.clone)
report_params
report_params.to_h
Hash[report_params]
current_company.reports.new(Hash[report_params])
current_company.reports.new(report_params.permit(:data_inicio, :data_fim))
continue
exit
report_params
params
continue
Report.first.update attachment_id: '123'
exit
puts page.body
continue
Report.first.update attachment_id: '123'
exit
puts page.body
continue
puts page.body
continue
ReportType.first
exit
next
e
q
exit!
next
e
exit!
next
exit!
pdf
wheami
l=
backend
File.read(pdf)
backend.upload(File.write('output.pdf', pdf))
File.write('output.pdf', pdf)
File.open('output.pdf', 'wb') do |f|
  f << pdf
end
f=File.open('output.pdf', 'wb') { |f| f << pdf }
f.read
f.close
File.read('output.pdf')
TempFile.open('xxx', 'wb')
TmpFile
TempFile
Tempfile
Tempfile.open('xxx', 'wb')
exit!
ReportService::GenerationService.new(Report.first).call
Tempfile.open('xxx', 'wb') { |f| f << pdf }
Tempfile.create('xxx', 'wb') { |f| f << pdf }
Tempfile.create('xxx') { |f| f << pdf }
Tempfile.new('xxx') { |f| f << pdf }
f=Tempfile.new('xxx') { |f| f << pdf }
f.save
f.close
Tempfile.open('xxx')
f=Tempfile.open('xxx')
f.read
f=Tempfile.write('xxx') { |f| f << pdf }
f=Tempfile.new('xxx')
f.write(pdf)
f
f << pdf
f=Tempfile.new('xxx', :encoding => 'ascii-8bit')
f << pdf
f.read
f.write pdf
f.read
f.close
f=Tempfile.read('xxx', :encoding => 'ascii-8bit')
f=Tempfile.open('xxx', :encoding => 'ascii-8bit')
f.read
IO.read f.path
f=Tempfile.new('xxx', :encoding => 'ascii-8bit')
f.write pdf
IO.read f.path
f.rewrind
f.rewind
IO.read f.path
exit
reload!
ReportService::GenerationService.new(Report.first).call
reload!
l=
ReportService::GenerationService.new(Report.first).call
reload!
ReportService::GenerationService.new(Report.first).call
IO.write('output.pdf', pdf, encoding: 'ascii-8bit')
exit
reload!
ReportService::GenerationService.new(Report.first).call
pdf.path
pdf.options
exit
reload!
ReportService::GenerationService.new(Report.first).call
pdf.path
pdf.options
pdf
pdf.config
pdf2
exit
reload!
ReportService::GenerationService.new(Report.first).call
IO.write('output.pdf')
IO.write('output.pdf', pdf)
IO.write('output.pdf', pdf, encoding: 'ASCII-8BIT')
backend.upload(IO.write('output.pdf', pdf, encoding: 'ASCII-8BIT'))
backend.upload(File.write('output.pdf', pdf, encoding: 'ASCII-8BIT'))
File.write('output.pdf', pdf, encoding: 'ASCII-8BIT')
File.read('output.pdf')
backend.upload(File.open('output.pdf'))
exit
reload!
ReportService::GenerationService.new(Report.first).call
Tempfile.write(['output', 'pdf'], pdf, encoding: 'ASCII-8BIT')
Tempfile.new(['output', 'pdf'], encoding: 'ASCII-8BIT')
exit
reload!
ReportService::GenerationService.new(Report.first).call
Tempfile.new(%w(output pdf), encoding: 'ASCII-8BIT') { |f| f << pdf }.close
Tempfile.new(%w(output pdf), encoding: 'ASCII-8BIT') { |f| f << pdf }
f=Tempfile.new(%w(output pdf), encoding: 'ASCII-8BIT') { |f| f << pdf }
f.close
f.read
f.open
f.open.read
f.open.rewind
f.open.read
exit
reload!
ReportService::GenerationService.new(Report.first).call
next
file.rewind
file << pdf
file.rewind
file.read
next
file.id
file.read
continue
reload!
ReportService::GenerationService.new(Report.first).call
StringIO.new(pdf)
next
file.id
continue
reload!
ReportService::GenerationService.new(Report.first).call
@report.attachment = StringIO.new(pdf)
@report.attachment_id
@report.save
@report.attachment_id
reload!
continue
reload!
ReportService::GenerationService.new(Report.first).call
Report.first
Report.first.attachment
Report.first.attachment.url
Report.first.attachment_url
Report.first
continue
relaod!
reload!
ReportService::GenerationService.new(Report.first).call
reload!
ReportService::GenerationService.new(Report.first).call
Report.first
reload!
ReportService::GenerationService.new(Report.first).call
reload!
ReportService::GenerationService.new(Report.first).call
render_to_string()
exit
reload!
ReportService::GenerationService.new(Report.first).call
next
e
exit
reload!
ReportService::GenerationService.new(Report.first).call
next
exit!
ReportService::GenerationService.new(Report.first).call
next
ERB.new(File.read('app/views/reports/template.html.erb'))
ERB.new(File.read('app/views/reports/template.html.erb')).result
ERB.new(File.read('app/views/reports/template.html.erb'))
ERB.new(File.read('app/views/reports/template.html.erb')).result(binding)
b=binding
ERB.new(File.read('app/views/reports/template.html.erb')).result(b)
b
puts b
puts ERB.new(File.read('app/views/reports/template.html.erb'))
ERB.new(File.read('app/views/reports/template.html.erb'))
ERB.new('app/views/reports/template.html.erb')
ERB.new(filename: 'app/views/reports/template.html.erb')
ERB.new(File.open('app/views/reports/template.html.erb'))
ERB.new(File.new('app/views/reports/template.html.erb'))
ERB.new(File.read('app/views/reports/template.html.erb')).result()
ERB.new(File.read('app/views/reports/template.html.erb')).result('')
ERB.new(File.read('app/views/reports/template.html.erb')).result(StringIO)
ERB.new(File.read('app/views/reports/template.html.erb')).result(binding)
require 'erb'
ERB.new
ERB.new 'xxxxxx'
x=ERB.new 'xxxxxx'
x.result
ERB.new(File.read('app/views/reports/template.html.erb')).result
x=ERB.new(File.read('app/views/reports/template.html.erb'))
x.result
continue
reload!
ReportService::GenerationService.new(Report.first).call
ERB.new(File.read('app/views/reports/template.html.erb')).result
continue
reload!
ReportService::GenerationService.new(Report.first).call
ERB.new(File.read('app/views/reports/template.html.erb')).result
ERB.new(File.read('app/views/reports/template.html.erb')).result(binding)
continue
reload!
ReportService::GenerationService.new(Report.first).call
ERB.new(File.read('app/views/reports/template.html.erb')).result(faturamento:[])
ERB.new(File.read('app/views/reports/template.html.erb')).result({faturamento:[]}.send(:binding)
)
{faturamento:[]}.send(:binding)
ERB.new(File.read('app/views/reports/template.html.erb')).result({faturamento:[]}.send(:binding))
ERB.new(File.read('app/views/reports/template.html.erb')).result({faturamento:123}.send(:binding))
exit
reload!
ReportService::GenerationService.new(Report.first).call
ERB.new(File.read('app/views/reports/template.html.erb')).result({faturamento:123}.send(:binding))
faturamento_mes
ERB.new(File.read('app/views/reports/template.html.erb')).result({faturamento:[]}.send(:binding))
exit
reload!
ReportService::GenerationService.new(Report.first).call
ERB.new(File.read('app/views/reports/template.html.erb')).result(:binding)
ERB.new(File.read('app/views/reports/template.html.erb')).result(binding)
faturamento
next
l=
reload!
ReportService::GenerationService.new(Report.first).call
ERB.new(File.read('app/views/reports/template.html.erb')).result(binding)
exit
reload!
ReportService::GenerationService.new(Report.first).call
ERB.new(File.read('app/views/reports/template.html.erb')).result(binding)
ReportType.first
reload!
exit
reload!
ReportService::GenerationService.new(Report.first).call
Report.first
Report.all
Report.destroy_all
reload!
ReportService::GenerationService.new(Report.first).call
Report.all
Report.destroy_all
Report.all
Report.destroy_all
Report.all
parameters
exit
Report.destroy_all
Report.all
reload!
ReportService::GenerationService.new(Report.first).call
reload!
ReportService::GenerationService.new(Report.first).call
exit
exit!
Date.new(2016, 02, 12)
Date.new(2016, 02, '12')
Date.new(2016, 02, 12)
exit
vigencia
vigencia.next_month
next
vencimento.year
vencimento.month
tax_type
tax_type.vencimento
exit!
next
tax_type
FactoryGirl
FactoryGirl.build(:tax_type)
tax_type
exit!
tax_type
exit!
self.tax_type
FactoryGirl.create(:tax_type)
FactoryGirl.build(:tax_type)
TaxType.all
exit!
TaxType.all
tax_type
continue
exit!
Company.first
Company.first.calculate_taxes
Company.first.calculate_taxes.new
Company.first.calculate_taxes.new vigencia: Date.today.beginning_of_month, tax_type: TaxType.first, total: 12.3, 
exit
Company.first.calculate_taxes.new vigencia: Date.today.beginning_of_month, tax_type: TaxType.first, total: 12.3, data_vencimento: Date.today.beginning_of_month.next_month
Company.first.calculate_taxes.create vigencia: Date.today.beginning_of_month, tax_type: TaxType.first, total: 12.3, data_vencimento: Date.today.beginning_of_month.next_month
x=Company.first.calculate_taxes.new vigencia: Date.today.beginning_of_month, tax_type: TaxType.first, total: 12.3, data_vencimento: Date.today.beginning_of_month.next_month
x.valid?
x.errors
TaxType.first
TaxType.new
TaxType.new name: 'texte', vencimento: 20
TaxType.create nome: 'texte', vencimento: 20
Company.first.calculate_taxes.create vigencia: Date.today.beginning_of_month, tax_type: TaxType.first, total: 12.3, data_vencimento: Date.today.beginning_of_month.next_month
Company.first.update data_abertura: Date.new(2015, 01,01)
exit
CalculateTax.first
CalculateTax.first.update data_pagamento: Date.new(2016, 03, 01)
exit
status
status == 'pendente'
continue
bread
next
truncate(call_concern(bread).to_s
, length: 30)
truncate(call_concern(bread).to_s, length: 30)
next
breadcrumb_link_for_list(bread)
bread
continue
bread
continue
bread
continue
bread
continue
exit!
bread
next
have_concern?(bread)
bread.singularize
bread.singularize.parameterize
bread.singularize.parameterize.underscore
'companies'.singularize.parameterize.underscore
continue
have_concern?(bread)
bread.singularize.parameterize.underscore
send("#{bread.singularize.parameterize.underscore}?")
"#{bread.singularize.parameterize.underscore}?"
calculate_tax
calculate_tax?
calculate_tax
calculate_tax_id
params
continue
CalculateTax.first
CalculateTax.first.pendente!
reload!
CalculateTax.first.pendente!
calculate_tax_params
calculate_tax_params.tap do |hash| hash[:data_pagamento] = hash[:data_pagamento].to_date
end
continue
exit
calculate_tax.reload
calculate_tax.receipt_file_name
calculate_tax.receipt_filename
be_truthy
continue
exit!
controller_name
bread
action_name
continue
name
resource
continue
name
resource
resource.to_s
resource.model_name
t(resource.model_name)
resource.model_name.human
resource.human
continue
current_user
continue
x='/auth/users/edit'
x.split('/')
x.split('/').except('auth')
x.split('/').reject('auth')
x.split('/').reject(&'auth')
x.split('/').delete('auth')
y=x.split('/')
y.delete('auth')
y
controller_name
controller_t(controller_name)
continue
I18n.t(:xxxx)
I18n.t(:xxxx, default: '')
I18n.t(:xxxx, default: nil)
exit
puts page.body
I18n.t("activerecord.attributes.user.name")
Faker::Name.name
next
puts page.body
continue
exit!
2.days.ago
exit
continue
fullpath
continue
request.fullpath.split('/')
request.fullpath.split('/')[1..-1]
request.fullpath.split('/')[1...-1]
continue
resource_name
resource
resource(resource_name)
continue
resource_name
continue
resource_name
continue
resource_name
continue
ReportType.first.codifo
ReportType.first.codigo
ReportType.first.codigo.constantize
ReportType.first.codigo.camelize
ReportType.first.codigo.camelize.constantize
ReportType.first.codigo.camelize
exit
Report.first
exit
Delayed::Jobs.count
Delayed::Job.count
Delayed::Job.all
Delayed::Job.first
Delayed::Job.update_all(last_error: nil)
Delayed::Job.first
Delayed::Job.update_all(last_error: nil, run_at: nil)
Delayed::Job.first
Delayed::Job.last
Delayed::Job.update_all(last_error: nil, run_at: nil, attempts: 3)
Delayed::Job.last
Delayed::Job.delete_all
Report.delete_all
next
clazz
"#{clazz}Service".constantize
"ReportService::#{clazz}Service".constantize
"ReportService::#{clazz}Service".constantize.new(@report)
"ReportService::#{clazz}Service".constantize.new(@report).call
exit!
Delayed::Job.delete_all
next
@results
@report.data_inicio
@report.data_fim
@report
@report.date_range
1 unless true
1 unless false
1 unless false && true
d1 = Date.new(2015, 1, 1)
d2 = Date.new(2016, 2, 1)
d1..d2
(d1..d2).to_a
(d1..d2).to_a.select { |d| d.day == 1 }
(d1..d2).to_a.select { |d| d.day == 1\ }
reload!
Report.first.date_range
reload!
Report.first.date_range
Report.first.update data_inicio: '2015-05-01'
r=Report.first
r.data_inicio = '2015-05-01'
r.valid?
r.errors
reload!
r=Report.first
r.data_inicio = '2015-05-01'
r.valid?
r.errors
reload!
r=Report.first
r.data_inicio = '2015-05-01'
r.valid?
r.errors
r.data_inicio > r.data_fim
r.data_inicio < r.data_fim
d1
d23
d
d2
d2 < d32
d1 < d2
reload!
r=Report.first
r.data_inicio = '2015-05-01'
r.valid?
r.save
Report.first.date_range
OpenStruct.new(a: 1)
OpenStruct.new(a: 1).a
OpenStruct.new(a: 1).b
nil > 0
exit
continue
@sales
next
sales_by_month
sales_by_month.each {|x| }
next
continue
@faturamento_mes.each {|x| }
continue
Sales.group_by_month
Sale.group_by_month
reload!
Sale.group_by_month
exit
Sale.group_by_month
Sale.group_by_month.first.vigencia
x=Sale.group_by_month
reload!
x=Sale.group_by_month
x.first.vigencia
x
x.where(vigencia: Date.new(2015, 5, 1))
x.where('vigencia' => Date.new(2015, 5, 1))
x.where('vigencia = ?', Date.new(2015, 5, 1))
x.select { |s| s.vigencia == Date.new(2015, 5, 1) }
x.first { |s| s.vigencia == Date.new(2015, 5, 1) }
exit
continue
Sale.group_by_month
Sale.group_by_month.first {|s| s.vigencia == nil }
Sale.group_by_month.first {|s| s.vigencia == nil }.try(:valor_total)
Sale.group_by_month.first {|s| s.vigencia == nil }.try(:valor_total).to_f
reload!
Sale.group_by_month.first {|s| s.vigencia == nil }.try(:valor_total).to_f
reload!
@report.company.sales.between_two_dates( @report.data_inicio, @report.data_fim)
l=
@report.company.sales.between_two_dates( @report.data_inicio, @report.data_fim).group_by_month
continue
@sales.sum(:valor_total)
@sales.to_a.sum(&:valor_total)
@sales.to_a.sum(&:valor_total).to_f
@sales.to_a.sum(:valor_total).to_f
continue
next
@total
continue
Delayed::Job.delete_all; Company.find('034be950-b804-45d4-bb10-b838404a22df').reports.delete_all
Sale.group_by_month
Company.find('034be950-b804-45d4-bb10-b838404a22df').sales.group_by_month
Company.find('034be950-b804-45d4-bb10-b838404a22df').sales.group_by_month.sum(:valor_total)
Company.find('034be950-b804-45d4-bb10-b838404a22df').sales.group_by_month.first {}
Company.find('034be950-b804-45d4-bb10-b838404a22df').sales.group_by_month
Delayed::Job.delete_all; Company.find('034be950-b804-45d4-bb10-b838404a22df').reports.delete_all
reload!
Delayed::Job.delete_all; Company.find('034be950-b804-45d4-bb10-b838404a22df').reports.delete_all
exit
Report.delete_all
exit
next
clazz
"ReportService::#{clazz}Service"
"ReportService::#{clazz}Service".camelize
"ReportService::#{clazz}Service".constantize
"ReportService::#{clazz}Service".constantize.new(@report).call
x="ReportService::#{clazz}Service".constantize.new(@report).call
x.first.total
x.sum(:total)
x.sum(&:total)
l=
next
e
continue
Delayed::Job.delete_all; Company.find('034be950-b804-45d4-bb10-b838404a22df').reports.delete_all
'12/2015'.to_date
Delayed::Job.delete_all; Company.find('034be950-b804-45d4-bb10-b838404a22df').reports.delete_all
exit
class X
  def a
    puts @x
  end
end
X.new(a: 1)
exit
User.pluck(:email)
exit
continue
call_service
@results
total_of_results
next
step
content
step
next
e
continue
vars
vars.each {|k,v| puts k}
vars.each {|k,v| puts v}
l=
send('@xpto=', 123)
instance_variable_set('@xpto', 123)
@xpto
Delayed::Job.delete_all; Company.find('034be950-b804-45d4-bb10-b838404a22df').reports.delete_all
continue
ReportService::ReportViewService.new(
  company: @company,
  report:  @report,
  total:   total_of_results,
  results: @results
)
view=_
view.@company
)
view
l=
continue
Sale.group()
Delayed::Job.delete_all; Company.find('034be950-b804-45d4-bb10-b838404a22df').reports.delete_all
@sales
key
@sales.group(:client_id)
@sales.group(:client_id).count
@sales.group(:client_id).to_a
@sales.group(:client_id).to_sql
@sales.group_by(:client_id)
@sales.group_by(&:client_id)
x=@sales.group_by(&:client_id)
x.to_a
continue
next
call_service
next
e
continue
next
continue
content
def content
  ReportService::ReportViewService.new(
    company: @company,
    report:  @report,
    total:   total_of_results,
    results: @results
  ).render("#{@report.report_type.codigo}_#{filter}")
  )
end
ReportService::ReportViewService.new(
  company: @company,
  report:  @report,
  total:   total_of_results,
  results: @results
).render("#{@report.report_type.codigo}_#{filter}")
ReportService::ReportViewService.new(
  company: @company,
  report:  @report,
  total:   total_of_results,
  results: @results
)
continue
content
ReportService::ReportViewService.new(
)
vars
instance_variable_set('@zzz', 1)
continue
l=
total_of_results
call_of_service
call_service
call_service.first
call_service.first.respond_to? :xxx
call_service.first.respond_to? :valor_total
call_service.sum(&:valor_total)
call_service.to_a.sum(&:valor_total)
continue
exit
Rails.env
ActiveRecord::Base.connection
exit!
current_url
visit '/'
exit!
continue
exit!
visit '/'
exit!
continue
page.body
page.url
page.current_url
continue
whereami
user.valid?
next
exception
continue
user
exit!
Company.all
user.save
continue
Term.all
User.all
exit!
continue
user.valid?
Term.all
exit!
user.sTerm.alll
user.sTerm.all
Term.all
user_params
continue
Term.all
Term.create!(start_date: Time.zone.today)
Term.all
User.all
continue
User.all
Term.all
conitnue
continue
Term.all
Rails.env
ENV
continue
Term.all
Rails.env
continue
Term.all
continue
Term.all
Term.create!(start_date: Time.zone.today)
next
whereami
Term.all
continue
Term.all
continue
Term.all
continue
Term.all
continue
Term.all
continue
Term.all
continue
Term.all
exit
continue
Term.all
continue
Term.all
exit!
Rails.env
ActiveRecord::Base.connection
ActiveRecord::Base.connection.config
ActiveRecord::Base.connection
ActiveRecord::Base.connection.configuration
ActiveRecord::Base.connection.send('@config')
ActiveRecord::Base.connection
continue
ActiveRecord::Base.connection
exit
exit!
next
Term.all
continue
Term.all
continue
Term.all
exit!
continue
Term.all
continue
Term.all
exit!
continue
Term.all
continue
Term.all
exit!
continue
Term.all
continue
Term.all
continue
Term.all
class ActiveRecord::Base
  mattr_accessor :shared_connection
  @@shared_connection = nil
  def self.connection
    @@shared_connection || retrieve_connection
  end
end
# Forces all threads to share the same connection. This works on
# Capybara because it starts the web server in a thread.
Term.where({}).to_a
exit!
Term.all
continue
Term.all
Term.create!(start_date: Time.zone.today)
exit!
Term.all
continue
exit!
continue
exit!
continue
Term.all
continue
Term.all
continue
page.body
continue
whereami
page.body
continue
email
email.to
email.subject
email.body
email.body.html
email.body.to_html
email.body.raw_source
email.body.raw_source.match =~ /<a href="([^"]*)"/
email.body.raw_source =~ /<a href="([^"]*)"/
/<a href="([^"]*)"/.match email.body.raw_source
(/<a href="([^"]*)"/.match email.body.raw_source).first
(/<a href="([^"]*)"/.match email.body.raw_source)[-]
(/<a href="([^"]*)"/.match email.body.raw_source)[0]
(/<a href="([^"]*)"/.match email.body.raw_source).1
exit!
/<a href="([^"]*)"/.match(email.body.raw_source)
/<a href="([^"]*)"/.match(email.body.raw_source)[1]
/<a href="([^"]*)"/.match(email.body.raw_source)[0]
continue
Rails.env
exit!
Rails.env
Rails.host
request
host_with_port
continue
url
x, y = nil
continue
exit!
url
continue
url
continue
url
continue
url
visit url
continue
url
continue
url
continue
page.url
page.current_url
page.body
continnue
continue
page.url
page.current_url
page_name
continue
page.body
continue
scope
continue
page.body
page
expect(page.body).to have_content content
continue
body
page.body
expect(page).to have_content('xxxx')
continue
User.all
Language.all
continue
User.all
continue
Area.first.name
find_all('*', text: Area.first.name, visible: false).last
find_all('*', text: Area.first.name, visible: false).last.click
exit
visit '/'
include Capybara::Dsl
include Capybara::DSL
require 'capybara/dsl
require 'capybara/dsl'
include Capybara::DSL
visit '/'
Capybara.current_driver = :selenium
visit '/'
exit
visit '/'
whereami
response.body
page.body
fill_in 'user[email]', 'admin@example.com'
fill_in 'user[email]', with: 'admin@example.com'
fill_in 'user[password]', with: '12345678'
click_on 'Entrar'
exit
page.body
attach
attach_file
continue
page.current_url
click_on 'Salvar e Processar Movimentação de produtos'
page.current_url
continue
visit '/'
page.current_url
exit
Slack.auth_test
c = Slack::Web::Client.new
client = Slack::Web::Client.new
client.auth_test
client.chat_postMessage(channel: '#general', text: 'testeeee', as_user: true)
client.chat_postMessage(channel: '#statuses', text: 'testeeee', as_user: true)
client.chat_postMessage(channel: '#statuses', text: 'testeeee', as_user: true, attachments: [{title: 'xxxx', title_link: 'http://www.google.com', text: 'yyyyy'}])
client.chat_postMessage(channel: '#statuses', text: 'testeeee', as_user: true, attachments: [{title: 'xxxx', title_link: 'http://www.google.com', text: 'yyyyy', color: 'red'}])
client.chat_postMessage(channel: '#statuses', text: 'testeeee', as_user: true, attachments: [{title: 'xxxx', title_link: 'http://www.google.com', text: 'yyyyy', color: '#36a64f'}])
exit
next
client.chat_postMessage(channel: '#statuses', text: 'testeeee', as_user: true, attachments: [{title: 'xxxx', title_link: 'http://www.google.com', text: 'yxxx<http://google.com>x', color: 'good'}])
exit
continue
